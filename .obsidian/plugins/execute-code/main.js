/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random2(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options2, guard)) {
            options2 = undefined2;
          }
          string = toString(string);
          options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options2)) {
            var separator = "separator" in options2 ? options2.separator : separator;
            length = "length" in options2 ? toInteger(options2.length) : length;
            omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random2;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/JSCPP/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/JSCPP/lib/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultTypes = exports2.numericTypeOrder = exports2.getDefaultConfig = void 0;
    var _ = require_lodash();
    var config = {
      specifiers: ["const", "inline", "_stdcall", "extern", "static", "auto", "register"],
      charTypes: [
        "char",
        "signed char",
        "unsigned char",
        "wchar_t",
        "unsigned wchar_t",
        "char16_t",
        "unsigned char16_t",
        "char32_t",
        "unsigned char32_t"
      ],
      intTypes: [
        "short",
        "short int",
        "signed short",
        "signed short int",
        "unsigned short",
        "unsigned short int",
        "int",
        "signed int",
        "unsigned",
        "unsigned int",
        "long",
        "long int",
        "long int",
        "signed long",
        "signed long int",
        "unsigned long",
        "unsigned long int",
        "long long",
        "long long int",
        "long long int",
        "signed long long",
        "signed long long int",
        "unsigned long long",
        "unsigned long long int",
        "bool"
      ],
      limits: {
        "char": {
          max: 127,
          min: 0,
          bytes: 1
        },
        "signed char": {
          max: 127,
          min: -128,
          bytes: 1
        },
        "unsigned char": {
          max: 255,
          min: 0,
          bytes: 1
        },
        "wchar_t": {
          max: 2147483647,
          min: -2147483648,
          bytes: 4
        },
        "unsigned wchar_t": {
          max: 4294967295,
          min: 0,
          bytes: 4
        },
        "char16_t": {
          max: 32767,
          min: -32768,
          bytes: 4
        },
        "unsigned char16_t": {
          max: 65535,
          min: 0,
          bytes: 4
        },
        "char32_t": {
          max: 2147483647,
          min: -2147483648,
          bytes: 4
        },
        "unsigned char32_t": {
          max: 4294967295,
          min: 0,
          bytes: 4
        },
        "short": {
          max: 32767,
          min: -32768,
          bytes: 2
        },
        "unsigned short": {
          max: 65535,
          min: 0,
          bytes: 2
        },
        "int": {
          max: 2147483647,
          min: -2147483648,
          bytes: 4
        },
        "unsigned": {
          max: 4294967295,
          min: 0,
          bytes: 4
        },
        "long": {
          max: 2147483647,
          min: -2147483648,
          bytes: 4
        },
        "unsigned long": {
          max: 4294967295,
          min: 0,
          bytes: 4
        },
        "long long": {
          max: 9223372036854776e3,
          min: -9223372036854776e3,
          bytes: 8
        },
        "unsigned long long": {
          max: 18446744073709552e3,
          min: 0,
          bytes: 8
        },
        "float": {
          max: 340282346638529e24,
          min: -340282346638529e24,
          bytes: 4
        },
        "double": {
          max: Infinity,
          min: -Infinity,
          bytes: 8
        },
        "pointer": {
          max: void 0,
          min: void 0,
          bytes: 4
        },
        "bool": {
          max: 1,
          min: 0,
          bytes: 1
        }
      },
      loadedLibraries: []
    };
    function getDefaultConfig() {
      return _.cloneDeep(config);
    }
    exports2.getDefaultConfig = getDefaultConfig;
    config.limits["short int"] = config.limits["short"];
    config.limits["signed short"] = config.limits["short"];
    config.limits["signed short int"] = config.limits["short"];
    config.limits["unsigned short int"] = config.limits["unsigned short"];
    config.limits["signed int"] = config.limits["int"];
    config.limits["unsigned int"] = config.limits["unsigned"];
    config.limits["long int"] = config.limits["long"];
    config.limits["long int"] = config.limits["long"];
    config.limits["signed long"] = config.limits["long"];
    config.limits["signed long int"] = config.limits["long"];
    config.limits["unsigned long int"] = config.limits["unsigned long"];
    config.limits["long long int"] = config.limits["long long"];
    config.limits["long long int"] = config.limits["long long"];
    config.limits["signed long long"] = config.limits["long long"];
    config.limits["signed long long int"] = config.limits["long long"];
    config.limits["unsigned long long int"] = config.limits["unsigned long long"];
    exports2.numericTypeOrder = [
      "char",
      "signed char",
      "short",
      "short int",
      "signed short",
      "signed short int",
      "int",
      "signed int",
      "long",
      "long int",
      "long int",
      "signed long",
      "signed long int",
      "long long",
      "long long int",
      "long long int",
      "signed long long",
      "signed long long int",
      "float",
      "double"
    ];
    var defaultOpHandler = {
      handlers: {
        "o(*)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support * on " + rt2.makeTypeString(r.t));
            } else if (!rt2.isNumericType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support * on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) * rt2.booleanToNumber(r.v);
              const rett = rt2.promoteNumeric(l.t, r.t);
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(/)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support / on " + rt2.makeTypeString(r.t));
            } else if (!rt2.isNumericType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support / on " + rt2.makeTypeString(r.t));
            } else {
              let ret2 = rt2.booleanToNumber(l.v) / rt2.booleanToNumber(r.v);
              if (rt2.isIntegerType(l.t) && rt2.isIntegerType(r.t)) {
                ret2 = Math.floor(ret2);
              }
              const rett = rt2.promoteNumeric(l.t, r.t);
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(%)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r) || !rt2.isIntegerType(l) || !rt2.isIntegerType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support % on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) % rt2.booleanToNumber(r.v);
              const rett = rt2.promoteNumeric(l.t, r.t);
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(+)": {
          default(rt2, l, r) {
            if (r === void 0) {
              return l;
            } else {
              if (rt2.isArrayType(r)) {
                const i2 = rt2.cast(rt2.intTypeLiteral, l).v;
                return rt2.val(r.t, rt2.makeArrayPointerValue(r.v.target, r.v.position + i2));
              } else if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
                rt2.raiseException(rt2.makeTypeString(l.t) + " does not support + on " + rt2.makeTypeString(r.t));
              } else {
                const ret2 = rt2.booleanToNumber(l.v) + rt2.booleanToNumber(r.v);
                const rett = rt2.promoteNumeric(l.t, r.t);
                return rt2.val(rett, ret2);
              }
            }
          }
        },
        "o(-)": {
          default(rt2, l, r) {
            let rett;
            if (r === void 0) {
              rett = l.v > 0 ? rt2.getSignedType(l.t) : l.t;
              return rt2.val(rett, -l.v);
            } else {
              if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
                rt2.raiseException(rt2.makeTypeString(l.t) + " does not support - on " + rt2.makeTypeString(r.t));
              } else {
                const ret2 = rt2.booleanToNumber(l.v) - rt2.booleanToNumber(r.v);
                rett = rt2.promoteNumeric(l.t, r.t);
                return rt2.val(rett, ret2);
              }
            }
          }
        },
        "o(<<)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r) || !rt2.isIntegerType(l) || !rt2.isIntegerType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support << on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) << rt2.booleanToNumber(r.v);
              const rett = l.t;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(>>)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r) || !rt2.isIntegerType(l) || !rt2.isIntegerType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support >> on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) >> rt2.booleanToNumber(r.v);
              const rett = l.t;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(<)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support < on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) < rt2.booleanToNumber(r.v);
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(<=)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support <= on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) <= rt2.booleanToNumber(r.v);
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(>)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support > on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) > rt2.booleanToNumber(r.v);
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(>=)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support >= on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) >= rt2.booleanToNumber(r.v);
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(==)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support == on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) === rt2.booleanToNumber(r.v);
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(!=)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(l) || !rt2.isNumericType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support != on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) !== rt2.booleanToNumber(r.v);
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(&)": {
          default(rt2, l, r) {
            let t;
            if (r === void 0) {
              if ("array" in l) {
                return rt2.val(rt2.arrayPointerType(l.t, l.array.length), rt2.makeArrayPointerValue(l.array, l.arrayIndex));
              } else {
                t = rt2.normalPointerType(l.t);
                return rt2.val(t, rt2.makeNormalPointerValue(l));
              }
            } else {
              if (!rt2.isIntegerType(l) || !rt2.isNumericType(r) || !rt2.isIntegerType(r)) {
                rt2.raiseException(rt2.makeTypeString(l.t) + " does not support & on " + rt2.makeTypeString(r.t));
              } else {
                const ret2 = rt2.booleanToNumber(l.v) & rt2.booleanToNumber(r.v);
                const rett = rt2.promoteNumeric(l.t, r.t);
                return rt2.val(rett, ret2);
              }
            }
          }
        },
        "o(^)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r) || !rt2.isIntegerType(l) || !rt2.isIntegerType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support ^ on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) ^ rt2.booleanToNumber(r.v);
              const rett = rt2.promoteNumeric(l.t, r.t);
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(|)": {
          default(rt2, l, r) {
            if (!rt2.isNumericType(r) || !rt2.isIntegerType(l) || !rt2.isIntegerType(r)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support | on " + rt2.makeTypeString(r.t));
            } else {
              const ret2 = rt2.booleanToNumber(l.v) | rt2.booleanToNumber(r.v);
              const rett = rt2.promoteNumeric(l.t, r.t);
              return rt2.val(rett, ret2);
            }
          }
        },
        "o(,)": {
          default(rt2, l, r) {
            return r;
          }
        },
        "o(=)": {
          default(rt2, l, r) {
            if (l.left) {
              l.v = rt2.cast(l.t, r).v;
              return l;
            } else {
              rt2.raiseException(rt2.makeValString(l) + " is not a left value");
            }
          }
        },
        "o(+=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(+)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(-=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(-)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(*=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(*)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(/=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(/)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(%=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(%)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(<<=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(<<)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(>>=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(>>)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(&=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(&)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(^=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(^)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(|=)": {
          default(rt2, l, r) {
            r = defaultOpHandler.handlers["o(|)"].default(rt2, l, r);
            return defaultOpHandler.handlers["o(=)"].default(rt2, l, r);
          }
        },
        "o(++)": {
          default(rt2, l, dummy) {
            if (!rt2.isNumericType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support increment");
            } else if (!l.left) {
              rt2.raiseException(rt2.makeValString(l) + " is not a left value");
            } else if (dummy) {
              const b2 = l.v;
              l.v = rt2.booleanToNumber(l.v) + 1;
              if (rt2.inrange(l.t, l.v, `overflow during post-increment ${rt2.makeValString(l)}`)) {
                l.v = rt2.ensureUnsigned(l.t, l.v);
                return rt2.val(l.t, b2);
              }
            } else {
              l.v = rt2.booleanToNumber(l.v) + 1;
              if (rt2.inrange(l.t, l.v, `overflow during pre-increment ${rt2.makeValString(l)}`)) {
                l.v = rt2.ensureUnsigned(l.t, l.v);
                return l;
              }
            }
          }
        },
        "o(--)": {
          default(rt2, l, dummy) {
            let b2;
            if (!rt2.isNumericType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support decrement");
            } else if (!l.left) {
              rt2.raiseException(rt2.makeValString(l) + " is not a left value");
            } else if (dummy) {
              b2 = l.v;
              l.v = rt2.booleanToNumber(l.v) - 1;
              if (rt2.inrange(l.t, l.v, "overflow during post-decrement")) {
                l.v = rt2.ensureUnsigned(l.t, l.v);
                return rt2.val(l.t, b2);
              }
            } else {
              l.v = rt2.booleanToNumber(l.v) - 1;
              b2 = l.v;
              if (rt2.inrange(l.t, l.v, "overflow during pre-decrement")) {
                l.v = rt2.ensureUnsigned(l.t, l.v);
                return l;
              }
            }
          }
        },
        "o(~)": {
          default(rt2, l) {
            if (!rt2.isIntegerType(l.t)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support ~ on itself");
            }
            const ret2 = ~l.v;
            const rett = rt2.promoteNumeric(l.t, rt2.intTypeLiteral);
            return rt2.val(rett, ret2);
          }
        },
        "o(!)": {
          default(rt2, l) {
            if (!rt2.isIntegerType(l.t)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support ! on itself");
            }
            const ret2 = l.v ? 0 : 1;
            const rett = l.t;
            return rt2.val(rett, ret2);
          }
        }
      }
    };
    var types = {
      "global": {
        handlers: {}
      }
    };
    function getDefaultTypes() {
      return _.cloneDeep(types);
    }
    exports2.getDefaultTypes = getDefaultTypes;
    types["(char)"] = defaultOpHandler;
    types["(signed char)"] = defaultOpHandler;
    types["(unsigned char)"] = defaultOpHandler;
    types["(short)"] = defaultOpHandler;
    types["(short int)"] = defaultOpHandler;
    types["(signed short)"] = defaultOpHandler;
    types["(signed short int)"] = defaultOpHandler;
    types["(unsigned short)"] = defaultOpHandler;
    types["(unsigned short int)"] = defaultOpHandler;
    types["(int)"] = defaultOpHandler;
    types["(signed int)"] = defaultOpHandler;
    types["(unsigned)"] = defaultOpHandler;
    types["(unsigned int)"] = defaultOpHandler;
    types["(long)"] = defaultOpHandler;
    types["(long int)"] = defaultOpHandler;
    types["(long int)"] = defaultOpHandler;
    types["(signed long)"] = defaultOpHandler;
    types["(signed long int)"] = defaultOpHandler;
    types["(unsigned long)"] = defaultOpHandler;
    types["(unsigned long int)"] = defaultOpHandler;
    types["(long long)"] = defaultOpHandler;
    types["(long long int)"] = defaultOpHandler;
    types["(long long int)"] = defaultOpHandler;
    types["(signed long long)"] = defaultOpHandler;
    types["(signed long long int)"] = defaultOpHandler;
    types["(unsigned long long)"] = defaultOpHandler;
    types["(unsigned long long int)"] = defaultOpHandler;
    types["(float)"] = defaultOpHandler;
    types["(double)"] = defaultOpHandler;
    types["(bool)"] = defaultOpHandler;
    types["pointer"] = {
      handlers: {
        "o(==)": {
          default(rt2, l, r) {
            let ret2 = false;
            if (rt2.isPointerType(l) && rt2.isPointerType(r)) {
              if (rt2.isTypeEqualTo(l.t, r.t)) {
                if (rt2.isArrayType(l) && rt2.isArrayType(r)) {
                  ret2 = l.v.target === r.v.target && (l.v.target === null || l.v.position === r.v.position);
                } else {
                  ret2 = l.v.target === r.v.target;
                }
              }
              const rett = rt2.boolTypeLiteral;
              return rt2.val(rett, ret2);
            } else {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support == on " + rt2.makeTypeString(r.t));
            }
          }
        },
        "o(!=)": {
          default(rt2, l, r) {
            return !rt2.types["pointer"].handlers["=="].default(rt2, l, r);
          }
        },
        "o(,)": {
          default(rt2, l, r) {
            return r;
          }
        },
        "o(=)": {
          default(rt2, l, r) {
            if (!l.left) {
              rt2.raiseException(rt2.makeValString(l) + " is not a left value");
            }
            const t = rt2.cast(l.t, r);
            l.t = t.t;
            l.v = t.v;
            return l;
          }
        },
        "o(&)": {
          default(rt2, l, r) {
            if (r === void 0) {
              if (rt2.isArrayElementType(l)) {
                if (l.array) {
                  return rt2.val(rt2.arrayPointerType(l.t, l.array.length), rt2.makeArrayPointerValue(l.array, l.arrayIndex));
                } else {
                  const t = rt2.normalPointerType(l.t);
                  return rt2.val(t, rt2.makeNormalPointerValue(l));
                }
              } else {
                rt2.raiseException(rt2.makeTypeString(l.t) + " does not support & on " + rt2.makeTypeString(r.t));
              }
            } else {
              rt2.raiseException("you cannot cast bitwise and on pointer");
            }
          }
        },
        "o(())": {
          default(rt2, l, bindThis, ...args) {
            if (!rt2.isPointerType(l) || !rt2.isFunctionPointerType(l)) {
              rt2.raiseException(`pointer target(${rt2.makeValueString(l)}) is not a function`);
            } else {
              return rt2.types["function"].handlers["o(())"].default(rt2, l.v.target, bindThis, ...args);
            }
          }
        }
      }
    };
    types["function"] = {
      handlers: {
        "o(())": {
          default(rt2, l, bindThis, ...args) {
            if (!rt2.isFunctionType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " does not support ()");
            } else {
              if (rt2.isFunctionPointerType(l)) {
                l = l.v.target;
              }
              if (l.v.target === null) {
                rt2.raiseException(`function ${l.v.name} does not seem to be implemented`);
              } else {
                return rt2.getCompatibleFunc(l.v.defineType, l.v.name, args)(rt2, bindThis, ...args);
              }
            }
          }
        },
        "o(&)": {
          default(rt2, l, r) {
            if (r === void 0) {
              if (rt2.isFunctionType(l)) {
                const lt = l.t;
                if ("retType" in lt) {
                  const t = rt2.functionPointerType(lt.retType, lt.signature);
                  return rt2.val(t, rt2.makeFunctionPointerValue(l, l.v.name, l.v.defineType, lt.signature, lt.retType));
                } else {
                  rt2.raiseException(rt2.makeTypeString(lt) + " is an operator function");
                }
              } else {
                rt2.raiseException(rt2.makeValueString(l) + " is not a function");
              }
            } else {
              rt2.raiseException("you cannot cast bitwise and on function");
            }
          }
        }
      }
    };
    types["pointer_normal"] = {
      handlers: {
        "o(*)": {
          default(rt2, l, r) {
            if (r === void 0) {
              if (!rt2.isNormalPointerType(l)) {
                rt2.raiseException(`pointer (${rt2.makeValueString(l)}) is not a normal pointer`);
              } else {
                if (l.v.target === null) {
                  rt2.raiseException("you cannot dereference an unitialized pointer");
                }
                return l.v.target;
              }
            } else {
              rt2.raiseException("you cannot multiply a pointer");
            }
          }
        },
        "o(->)": {
          default(rt2, l) {
            if (!rt2.isNormalPointerType(l)) {
              rt2.raiseException(`pointer (${rt2.makeValueString(l)}) is not a normal pointer`);
            } else {
              return l.v.target;
            }
          }
        }
      }
    };
    types["pointer_array"] = {
      handlers: {
        "o(*)": {
          default(rt2, l, r) {
            if (r === void 0) {
              if (!rt2.isArrayType(l)) {
                rt2.raiseException(`pointer (${rt2.makeValueString(l)}) is not a normal pointer`);
              } else {
                const arr = l.v.target;
                if (l.v.position >= arr.length) {
                  rt2.raiseException("index out of bound " + l.v.position + " >= " + arr.length);
                } else if (l.v.position < 0) {
                  rt2.raiseException("negative index " + l.v.position);
                }
                const ret2 = arr[l.v.position];
                ret2.array = arr;
                ret2.arrayIndex = l.v.position;
                return ret2;
              }
            } else {
              rt2.raiseException("you cannot multiply a pointer");
            }
          }
        },
        "o([])": {
          default(rt2, l, r) {
            r = rt2.types["pointer_array"].handlers["o(+)"].default(rt2, l, r);
            return rt2.types["pointer_array"].handlers["o(*)"].default(rt2, r);
          }
        },
        "o(->)": {
          default(rt2, l) {
            l = rt2.types["pointer_array"].handlers["o(*)"].default(rt2, l);
            return l;
          }
        },
        "o(-)": {
          default(rt2, l, r) {
            if (rt2.isArrayType(l)) {
              if (rt2.isNumericType(r)) {
                const i2 = rt2.cast(rt2.intTypeLiteral, r).v;
                return rt2.val(l.t, rt2.makeArrayPointerValue(l.v.target, l.v.position - i2));
              } else if (rt2.isArrayType(r)) {
                if (l.v.target === r.v.target) {
                  return l.v.position - r.v.position;
                } else {
                  rt2.raiseException("you cannot perform minus on pointers pointing to different arrays");
                }
              } else {
                rt2.raiseException(rt2.makeTypeString(r.t) + " is not an array pointer type");
              }
            } else {
              rt2.raiseException(rt2.makeTypeString(l.t) + " is not an array pointer type");
            }
          }
        },
        "o(<)": {
          default(rt2, l, r) {
            if (rt2.isArrayType(l) && rt2.isArrayType(r)) {
              if (l.v.target === r.v.target) {
                return l.v.position < r.v.position;
              } else {
                rt2.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt2.raiseException(rt2.makeTypeString(r.t) + " is not an array pointer type");
            }
          }
        },
        "o(>)": {
          default(rt2, l, r) {
            if (rt2.isArrayType(l) && rt2.isArrayType(r)) {
              if (l.v.target === r.v.target) {
                return l.v.position > r.v.position;
              } else {
                rt2.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt2.raiseException(rt2.makeTypeString(r.t) + " is not an array pointer type");
            }
          }
        },
        "o(<=)": {
          default(rt2, l, r) {
            if (rt2.isArrayType(l) && rt2.isArrayType(r)) {
              if (l.v.target === r.v.target) {
                return l.v.position <= r.v.position;
              } else {
                rt2.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt2.raiseException(rt2.makeTypeString(r.t) + " is not an array pointer type");
            }
          }
        },
        "o(>=)": {
          default(rt2, l, r) {
            if (rt2.isArrayType(l) && rt2.isArrayType(r)) {
              if (l.v.target === r.v.target) {
                return l.v.position >= r.v.position;
              } else {
                rt2.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt2.raiseException(rt2.makeTypeString(r.t) + " is not an array pointer type");
            }
          }
        },
        "o(+)": {
          default(rt2, l, r) {
            if (rt2.isArrayType(l) && rt2.isNumericType(r)) {
              const i2 = rt2.cast(rt2.intTypeLiteral, r).v;
              return rt2.val(l.t, rt2.makeArrayPointerValue(l.v.target, l.v.position + i2));
            } else {
              rt2.raiseException("cannot add non-numeric to an array pointer");
            }
          }
        },
        "o(+=)": {
          default(rt2, l, r) {
            r = rt2.types["pointer_array"].handlers["o(+)"].default(rt2, l, r);
            return rt2.types["pointer"].handlers["="].default(rt2, l, r);
          }
        },
        "o(-=)": {
          default(rt2, l, r) {
            r = rt2.types["pointer_array"].handlers["o(-)"].default(rt2, l, r);
            return rt2.types["pointer"].handlers["="].default(rt2, l, r);
          }
        },
        "o(++)": {
          default(rt2, l, dummy) {
            if (!l.left) {
              rt2.raiseException(rt2.makeValString(l) + " is not a left value");
            }
            if (!rt2.isArrayType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " is not an array pointer type");
            } else {
              if (dummy) {
                return rt2.val(l.t, rt2.makeArrayPointerValue(l.v.target, l.v.position++));
              } else {
                l.v.position++;
                return l;
              }
            }
          }
        },
        "o(--)": {
          default(rt2, l, dummy) {
            if (!l.left) {
              rt2.raiseException(rt2.makeValString(l) + " is not a left value");
            }
            if (!rt2.isArrayType(l)) {
              rt2.raiseException(rt2.makeTypeString(l.t) + " is not an array pointer type");
            } else {
              if (dummy) {
                return rt2.val(l.t, rt2.makeArrayPointerValue(l.v.target, l.v.position--));
              } else {
                l.v.position--;
                return l;
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/JSCPP/lib/rt.js
var require_rt = __commonJS({
  "node_modules/JSCPP/lib/rt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CRuntime = exports2.mergeConfig = void 0;
    var defaults = require_defaults();
    function mergeConfig(a2, b2) {
      for (const o in b2) {
        if (b2.hasOwnProperty(o)) {
          if (o in a2 && typeof b2[o] === "object") {
            mergeConfig(a2[o], b2[o]);
          } else {
            a2[o] = b2[o];
          }
        }
      }
    }
    exports2.mergeConfig = mergeConfig;
    var CRuntime = class {
      constructor(config) {
        this.makeOperatorFuncName = (name) => `o(${name})`;
        this.config = defaults.getDefaultConfig();
        mergeConfig(this.config, config);
        this.numericTypeOrder = defaults.numericTypeOrder;
        this.types = defaults.getDefaultTypes();
        this.intTypeLiteral = this.primitiveType("int");
        this.unsignedintTypeLiteral = this.primitiveType("unsigned int");
        this.longTypeLiteral = this.primitiveType("long");
        this.floatTypeLiteral = this.primitiveType("float");
        this.doubleTypeLiteral = this.primitiveType("double");
        this.charTypeLiteral = this.primitiveType("char");
        this.unsignedcharTypeLiteral = this.primitiveType("unsigned char");
        this.boolTypeLiteral = this.primitiveType("bool");
        this.voidTypeLiteral = this.primitiveType("void");
        this.nullPointerValue = this.makeNormalPointerValue(null);
        this.voidPointerType = this.normalPointerType(this.voidTypeLiteral);
        this.nullPointer = this.val(this.voidPointerType, this.nullPointerValue);
        this.scope = [{ "$name": "global", variables: {} }];
        this.typedefs = {};
      }
      include(name) {
        const { includes } = this.config;
        if (name in includes) {
          const lib = includes[name];
          if (this.config.loadedLibraries.includes(name)) {
            return;
          }
          this.config.loadedLibraries.push(name);
          lib.load(this);
        } else {
          this.raiseException("cannot find library: " + name);
        }
      }
      getSize(element) {
        let ret2 = 0;
        if (this.isArrayType(element) && element.v.position === 0) {
          let i2 = 0;
          while (i2 < element.v.target.length) {
            ret2 += this.getSize(element.v.target[i2]);
            i2++;
          }
        } else {
          ret2 += this.getSizeByType(element.t);
        }
        return ret2;
      }
      getSizeByType(t) {
        if (this.isPointerType(t)) {
          return this.config.limits["pointer"].bytes;
        } else if (this.isPrimitiveType(t)) {
          return this.config.limits[t.name].bytes;
        } else {
          this.raiseException("not implemented");
        }
      }
      getMember(l, r) {
        const lt = l.t;
        if (this.isClassType(l)) {
          const ltsig = this.getTypeSignature(lt);
          if (this.types.hasOwnProperty(ltsig)) {
            const t = this.types[ltsig].handlers;
            if (t.hasOwnProperty(r)) {
              return {
                t: {
                  type: "function"
                },
                v: {
                  defineType: lt,
                  name: r,
                  bindThis: l
                }
              };
            } else {
              const lv = l.v;
              if (lv.members.hasOwnProperty(r)) {
                return lv.members[r];
              }
            }
          } else {
            this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
          }
        } else {
          this.raiseException("only a class can have members");
        }
      }
      defFunc(lt, name, retType, argTypes, argNames, stmts, interp, optionalArgs) {
        if (stmts != null) {
          const f = function* (rt2, _this2, ...args) {
            rt2.enterScope("function " + name);
            argNames.forEach(function(argName, i2) {
              rt2.defVar(argName, argTypes[i2], args[i2]);
            });
            for (let i2 = 0, end = optionalArgs.length; i2 < end; i2++) {
              const optionalArg = optionalArgs[i2];
              if (args[argNames.length + i2] != null) {
                rt2.defVar(optionalArg.name, optionalArg.type, args[argNames.length + i2]);
              } else {
                const argValue = yield* interp.visit(interp, optionalArg.expression);
                rt2.defVar(optionalArg.name, optionalArg.type, rt2.cast(optionalArg.type, argValue));
              }
            }
            let ret2 = yield* interp.run(stmts, interp.source, { scope: "function" });
            if (!rt2.isTypeEqualTo(retType, rt2.voidTypeLiteral)) {
              if (ret2 instanceof Array && ret2[0] === "return") {
                ret2 = rt2.cast(retType, ret2[1]);
              } else {
                rt2.raiseException("you must return a value");
              }
            } else {
              if (Array.isArray(ret2)) {
                if (ret2[0] === "return" && ret2[1]) {
                  rt2.raiseException("you cannot return a value from a void function");
                }
              }
              ret2 = void 0;
            }
            rt2.exitScope("function " + name);
            return ret2;
          };
          this.regFunc(f, lt, name, argTypes, retType, optionalArgs);
        } else {
          this.regFuncPrototype(lt, name, argTypes, retType, optionalArgs);
        }
      }
      makeParametersSignature(args) {
        const ret2 = new Array(args.length);
        let i2 = 0;
        while (i2 < args.length) {
          const arg = args[i2];
          ret2[i2] = this.getTypeSignature(arg);
          i2++;
        }
        return ret2.join(",");
      }
      getCompatibleFunc(lt, name, args) {
        let ret2;
        const ltsig = this.getTypeSignature(lt);
        if (ltsig in this.types) {
          const t = this.types[ltsig].handlers;
          if (name in t) {
            const ts = args.map((v) => v.t);
            const sig = this.makeParametersSignature(ts);
            if (sig in t[name].functions) {
              ret2 = t[name].functions[sig];
            } else {
              const compatibles = [];
              const reg = t[name].reg;
              Object.keys(reg).forEach((signature) => {
                let newTs;
                const regArgInfo = reg[signature];
                const dts = regArgInfo.args;
                let newDts;
                const { optionalArgs } = regArgInfo;
                if (dts[dts.length - 1] === "?" && dts.length - 1 <= ts.length) {
                  newTs = ts.slice(0, dts.length - 1);
                  newDts = dts.slice(0, -1);
                } else {
                  newTs = ts;
                  newDts = dts;
                }
                if (newDts.length <= newTs.length) {
                  let ok = true;
                  let i2 = 0;
                  while (ok && i2 < newDts.length) {
                    ok = this.castable(newTs[i2], newDts[i2]);
                    i2++;
                  }
                  while (ok && i2 < newTs.length) {
                    ok = this.castable(newTs[i2], optionalArgs[i2 - newDts.length].type);
                    i2++;
                  }
                  if (ok) {
                    compatibles.push(t[name].functions[this.makeParametersSignature(regArgInfo.args)]);
                  }
                }
              });
              if (compatibles.length === 0) {
                if ("#default" in t[name]) {
                  ret2 = t[name].functions["#default"];
                } else {
                  const argsStr = ts.map((v) => {
                    return this.makeTypeString(v);
                  }).join(",");
                  this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts " + argsStr);
                }
              } else if (compatibles.length > 1) {
                this.raiseException("ambiguous method invoking, " + compatibles.length + " compatible methods");
              } else {
                ret2 = compatibles[0];
              }
            }
          } else {
            this.raiseException("method " + name + " is not defined in " + this.makeTypeString(lt));
          }
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
        }
        if (ret2 == null) {
          this.raiseException("method " + name + " does not seem to be implemented");
        }
        return ret2;
      }
      matchVarArg(methods, sig) {
        for (let _sig in methods) {
          if (_sig[_sig.length - 1] === "?") {
            _sig = _sig.slice(0, -1);
            if (sig.startsWith(_sig)) {
              return methods.functions[_sig];
            }
          }
        }
        return null;
      }
      getFunc(lt, name, args) {
        if (lt !== "global" && (this.isPointerType(lt) || this.isFunctionType(lt))) {
          let f;
          if (this.isArrayType(lt)) {
            f = "pointer_array";
          } else if (this.isFunctionType(lt)) {
            f = "function";
          } else {
            f = "pointer_normal";
          }
          let t = null;
          if (name in this.types[f].handlers) {
            t = this.types[f].handlers;
          } else if (name in this.types["pointer"].handlers) {
            t = this.types["pointer"].handlers;
          }
          if (t) {
            const sig = this.makeParametersSignature(args);
            let method;
            if (t[name].functions != null && sig in t[name].functions) {
              return t[name].functions[sig];
            } else if ((method = this.matchVarArg(t[name], sig)) !== null) {
              return method;
            } else if (t[name].default) {
              return t[name].default;
            } else {
              this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts (" + sig + ")");
            }
          }
        }
        const ltsig = this.getTypeSignature(lt);
        if (ltsig in this.types) {
          const t = this.types[ltsig].handlers;
          if (name in t) {
            const sig = this.makeParametersSignature(args);
            let method;
            if (t[name].functions != null && sig in t[name].functions) {
              return t[name].functions[sig];
            } else if ((method = this.matchVarArg(t[name], sig)) !== null) {
              return method;
            } else if (t[name].default) {
              return t[name].default;
            } else {
              this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts (" + sig + ")");
            }
          } else {
            this.raiseException("method " + name + " is not defined in " + this.makeTypeString(lt));
          }
        } else {
          if (lt !== "global" && this.isPointerType(lt)) {
            this.raiseException("this pointer has no proper method overload");
          } else {
            this.raiseException("type " + this.makeTypeString(lt) + " is not defined");
          }
        }
      }
      regOperator(f, lt, name, args, retType) {
        return this.regFunc(f, lt, this.makeOperatorFuncName(name), args, retType);
      }
      regFuncPrototype(lt, name, args, retType, optionalArgs) {
        const ltsig = this.getTypeSignature(lt);
        if (ltsig in this.types) {
          const t = this.types[ltsig].handlers;
          if (!(name in t)) {
            t[name] = {
              functions: {},
              reg: {}
            };
          }
          if (!("reg" in t[name])) {
            t[name]["reg"] = {};
          }
          const sig = this.makeParametersSignature(args);
          if (sig in t[name]) {
            this.raiseException("method " + name + " with parameters (" + sig + ") is already defined");
          }
          const type = this.functionType(retType, args);
          if (lt === "global") {
            this.defVar(name, type, this.val(type, this.makeFunctionPointerValue(null, name, lt, args, retType)));
          }
          t[name].functions[sig] = null;
          if (t[name].reg[sig] == null) {
            t[name].reg[sig] = {
              args,
              optionalArgs
            };
          }
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
        }
      }
      regFunc(f, lt, name, args, retType, optionalArgs) {
        const ltsig = this.getTypeSignature(lt);
        if (ltsig in this.types) {
          if (!optionalArgs) {
            optionalArgs = [];
          }
          const t = this.types[ltsig].handlers;
          if (!(name in t)) {
            t[name] = {
              functions: {},
              reg: {}
            };
          }
          if (t[name].functions == null) {
            t[name].functions = {};
          }
          if (t[name].reg == null) {
            t[name].reg = {};
          }
          const sig = this.makeParametersSignature(args);
          if (t[name].functions[sig] != null && t[name].reg[sig] != null) {
            this.raiseException("method " + name + " with parameters (" + sig + ") is already defined");
          }
          const type = this.functionType(retType, args);
          if (lt === "global") {
            if (this.varAlreadyDefined(name)) {
              const func = this.scope[0].variables[name];
              if (this.isFunctionType(func)) {
                const v = func.v;
                if (v.target !== null) {
                  this.raiseException("global method " + name + " with parameters (" + sig + ") is already defined");
                } else {
                  v.target = f;
                }
              } else {
                this.raiseException(name + " is already defined as " + this.makeTypeString(func.t));
              }
            } else {
              this.defVar(name, type, this.val(type, this.makeFunctionPointerValue({
                t: {
                  type: "function",
                  retType,
                  signature: args
                },
                v: {
                  bindThis: null,
                  defineType: lt,
                  name,
                  target: f
                }
              }, name, lt, args, retType)));
            }
          }
          t[name].functions[sig] = f;
          t[name].reg[sig] = {
            args,
            optionalArgs
          };
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
        }
      }
      registerTypedef(basttype, name) {
        return this.typedefs[name] = basttype;
      }
      promoteNumeric(l, r) {
        if (this.isNumericType(l) && this.isNumericType(r)) {
          if (this.isTypeEqualTo(l, r)) {
            if (this.isTypeEqualTo(l, this.boolTypeLiteral)) {
              return this.intTypeLiteral;
            }
            if (this.isTypeEqualTo(l, this.charTypeLiteral)) {
              return this.intTypeLiteral;
            }
            if (this.isTypeEqualTo(l, this.unsignedcharTypeLiteral)) {
              return this.unsignedintTypeLiteral;
            }
            return l;
          } else if (this.isIntegerType(l) && this.isIntegerType(r)) {
            let rett;
            const slt = this.getSignedType(l);
            const srt = this.getSignedType(r);
            if (this.isTypeEqualTo(slt, srt)) {
              rett = slt;
            } else {
              const slti = this.numericTypeOrder.indexOf(slt.name);
              const srti = this.numericTypeOrder.indexOf(srt.name);
              if (slti <= srti) {
                if (this.isUnsignedType(l) && this.isUnsignedType(r)) {
                  rett = r;
                } else {
                  rett = srt;
                }
              } else {
                if (this.isUnsignedType(l) && this.isUnsignedType(r)) {
                  rett = l;
                } else {
                  rett = slt;
                }
              }
            }
            return rett;
          } else if (!this.isIntegerType(l) && this.isIntegerType(r)) {
            return l;
          } else if (this.isIntegerType(l) && !this.isIntegerType(r)) {
            return r;
          } else if (!this.isIntegerType(l) && !this.isIntegerType(r)) {
            return this.primitiveType("double");
          }
        } else {
          this.raiseException("you cannot promote (to) a non numeric type");
        }
      }
      readVar(varname) {
        let i2 = this.scope.length - 1;
        while (i2 >= 0) {
          const vc = this.scope[i2];
          if (vc.variables[varname] != null) {
            const ret2 = vc.variables[varname];
            return ret2;
          }
          i2--;
        }
        this.raiseException("variable " + varname + " does not exist");
      }
      varAlreadyDefined(varname) {
        const vc = this.scope[this.scope.length - 1];
        return varname in vc;
      }
      defVar(varname, type, initval) {
        if (this.varAlreadyDefined(varname)) {
          this.raiseException("variable " + varname + " already defined");
        }
        const vc = this.scope[this.scope.length - 1];
        initval = this.clone(this.cast(type, initval), true);
        if (initval === void 0) {
          vc.variables[varname] = this.defaultValue(type);
          vc.variables[varname].left = true;
        } else {
          vc.variables[varname] = initval;
          vc.variables[varname].left = true;
        }
      }
      booleanToNumber(b2) {
        if (typeof b2 === "boolean") {
          return b2 ? 1 : 0;
        }
        return b2;
      }
      inrange(type, value, errorMsg) {
        if (this.isPrimitiveType(type)) {
          value = this.booleanToNumber(value);
          const limit = this.config.limits[type.name];
          const overflow = !(value <= limit.max && value >= limit.min);
          if (errorMsg && overflow) {
            if (this.isUnsignedType(type)) {
              if (this.config.unsigned_overflow === "error") {
                this.raiseException(errorMsg);
                return false;
              } else if (this.config.unsigned_overflow === "warn") {
                console.error(errorMsg);
                return true;
              } else {
                return true;
              }
            } else {
              this.raiseException(errorMsg);
            }
          }
          return !overflow;
        } else {
          return true;
        }
      }
      ensureUnsigned(type, value) {
        value = this.booleanToNumber(value);
        if (this.isUnsignedType(type)) {
          const limit = this.config.limits[type.name];
          const period = limit.max - limit.min;
          if (value < limit.min) {
            value += period * Math.ceil((limit.min - value) / period);
          }
          if (value > limit.max) {
            value = (value - limit.min) % period + limit.min;
          }
        }
        return value;
      }
      isNumericType(type) {
        if (typeof type === "string") {
          return this.isFloatType(type) || this.isIntegerType(type);
        }
        if ("t" in type) {
          return type.t !== "dummy" && this.isNumericType(type.t);
        }
        return this.isFloatType(type) || this.isIntegerType(type);
      }
      isUnsignedType(type) {
        if (typeof type === "string") {
          switch (type) {
            case "unsigned char":
            case "unsigned short":
            case "unsigned short int":
            case "unsigned":
            case "unsigned int":
            case "unsigned long":
            case "unsigned long int":
            case "unsigned long long":
            case "unsigned long long int":
              return true;
            default:
              return false;
          }
        } else {
          return type.type === "primitive" && this.isUnsignedType(type.name);
        }
      }
      isIntegerType(type) {
        if (typeof type === "string") {
          return this.config.charTypes.includes(type) || this.config.intTypes.includes(type);
        } else if ("t" in type) {
          return this.isIntegerType(type.t);
        } else {
          return type.type === "primitive" && this.isIntegerType(type.name);
        }
      }
      isFloatType(type) {
        if (typeof type === "string") {
          switch (type) {
            case "float":
            case "double":
              return true;
            default:
              return false;
          }
        } else if ("t" in type) {
          return this.isFloatType(type.t);
        } else {
          return type.type === "primitive" && this.isFloatType(type.name);
        }
      }
      getSignedType(type) {
        if (type.type === "primitive") {
          return this.primitiveType(type.name.replace("unsigned", "").trim());
        } else {
          this.raiseException("Cannot get signed type from non-primitive type " + this.makeTypeString(type));
        }
      }
      castable(type1, type2) {
        if (type1 === "dummy" || type2 === "dummy") {
          this.raiseException("Unexpected dummy");
          return;
        }
        if (this.isTypeEqualTo(type1, type2)) {
          return true;
        }
        if (this.isPrimitiveType(type1) && this.isPrimitiveType(type2)) {
          return this.isNumericType(type2) && this.isNumericType(type1);
        } else if (this.isPointerType(type1) && this.isPointerType(type2)) {
          if (this.isFunctionType(type1)) {
            return this.isPointerType(type2);
          }
          return !this.isFunctionType(type2);
        } else if (this.isClassType(type1) || this.isClassType(type2)) {
          this.raiseException("not implemented");
        }
        return false;
      }
      cast(type, value) {
        let v;
        if (value.t !== "dummy") {
        } else {
          this.raiseException(this.makeValString(value) + " is dummy");
          return;
        }
        if (this.isTypeEqualTo(value.t, type)) {
          return value;
        }
        if (this.isPrimitiveType(type) && this.isPrimitiveType(value.t)) {
          if (type.name === "bool") {
            return this.val(type, value.v ? 1 : 0);
          } else if (["float", "double"].includes(type.name)) {
            if (!this.isNumericType(value)) {
              this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
            } else if (this.inrange(type, value.v, "overflow when casting " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type))) {
              value.v = this.ensureUnsigned(type, value.v);
              return this.val(type, value.v);
            }
          } else {
            if (type.name.slice(0, 8) === "unsigned") {
              if (!this.isNumericType(value)) {
                this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
              } else if (value.v < 0) {
                const { bytes } = this.config.limits[type.name];
                let newValue = this.booleanToNumber(value.v) & (1 << 8 * bytes) - 1;
                if (this.inrange(type, newValue, `cannot cast negative value ${newValue} to ` + this.makeTypeString(type))) {
                  newValue = this.ensureUnsigned(type, newValue);
                  return this.val(type, newValue);
                }
              }
            }
            if (!this.isNumericType(value)) {
              this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
            } else if (this.isFloatType(value)) {
              v = value.v > 0 ? Math.floor(this.booleanToNumber(value.v)) : Math.ceil(this.booleanToNumber(value.v));
              if (this.inrange(type, v, "overflow when casting " + this.makeValString(value) + " to " + this.makeTypeString(type))) {
                v = this.ensureUnsigned(type, v);
                return this.val(type, v);
              }
            } else {
              if (this.inrange(type, value.v, "overflow when casting " + this.makeValString(value) + " to " + this.makeTypeString(type))) {
                value.v = this.ensureUnsigned(type, value.v);
                return this.val(type, value.v);
              }
            }
          }
        } else if (this.isPointerType(type)) {
          if (this.isArrayType(value)) {
            if (this.isNormalPointerType(type)) {
              if (this.isTypeEqualTo(type.targetType, value.t.eleType)) {
                return value;
              } else {
                this.raiseException(this.makeTypeString(type.targetType) + " is not equal to array element type " + this.makeTypeString(value.t.eleType));
              }
            } else if (this.isArrayType(type)) {
              if (this.isTypeEqualTo(type.eleType, value.t.eleType)) {
                return value;
              } else {
                this.raiseException("array element type " + this.makeTypeString(type.eleType) + " is not equal to array element type " + this.makeTypeString(value.t.eleType));
              }
            } else {
              this.raiseException("cannot cast a function to a regular pointer");
            }
          } else {
            if (this.isNormalPointerType(type)) {
              if (this.isNormalPointerType(value)) {
                if (this.isTypeEqualTo(type.targetType, value.t.targetType)) {
                  return value;
                } else {
                  this.raiseException(this.makeTypeString(type.targetType) + " is not equal to " + this.makeTypeString(value.t.targetType));
                }
              } else {
                this.raiseException(this.makeTypeString(value.t) + " is not a normal porinter");
              }
            } else if (this.isArrayType(type)) {
              if (this.isNormalPointerType(value)) {
                if (this.isTypeEqualTo(type.eleType, value.t.targetType)) {
                  return value;
                } else {
                  this.raiseException("array element type " + this.makeTypeString(type.eleType) + " is not equal to " + this.makeTypeString(value.t.targetType));
                }
              } else {
                this.raiseException(this.makeTypeString(value.t) + " is not a normal porinter");
              }
            } else {
              this.raiseException("cannot cast a function to a regular pointer");
            }
          }
        } else if (this.isFunctionType(type)) {
          if (this.isFunctionType(value.t)) {
            return this.val(value.t, value.v);
          } else {
            this.raiseException("cannot cast a regular pointer to a function");
          }
        } else if (this.isClassType(type)) {
          this.raiseException("not implemented");
        } else if (this.isClassType(value.t)) {
          value = this.getCompatibleFunc(value.t, this.makeOperatorFuncName(type.name), [])(this, value);
          return value;
        } else {
          this.raiseException("cast failed from type " + this.makeTypeString(type) + " to " + this.makeTypeString(value.t));
        }
      }
      clone(v, isInitializing) {
        return this.val(v.t, v.v, false, isInitializing);
      }
      enterScope(scopename) {
        this.scope.push({ "$name": scopename, variables: {} });
      }
      exitScope(scopename) {
        while (true) {
          const s2 = this.scope.pop();
          if (!scopename || !(this.scope.length > 1) || s2["$name"] === scopename) {
            break;
          }
        }
      }
      val(t, v, left = false, isInitializing = false) {
        if (this.isNumericType(t)) {
          let checkRange;
          if (isInitializing) {
            if (typeof v !== "number" || isNaN(v)) {
              checkRange = false;
            } else {
              checkRange = true;
            }
          } else {
            checkRange = true;
          }
          if (checkRange) {
            this.inrange(t, v, `overflow of ${this.makeValString({ t, v })}`);
            v = this.ensureUnsigned(t, v);
          }
        }
        if (left === void 0) {
          left = false;
        }
        return {
          t,
          v,
          left
        };
      }
      isTypeEqualTo(type1, type2) {
        if (type1 === "?" || type2 === "?") {
          return type1 === type2;
        }
        if (type1.type === type2.type) {
          switch (type1.type) {
            case "primitive":
              return type1.name === type2.name;
              break;
            case "class":
              return type1.name === type2.name;
              break;
            case "pointer":
              type2 = type2;
              if (type1.ptrType === type2.ptrType || type1.ptrType !== "function" && type2.ptrType !== "function") {
                switch (type1.ptrType) {
                  case "array":
                    return this.isTypeEqualTo(type1.eleType, type2.eleType || type2.targetType);
                    break;
                  case "function":
                    return this.isTypeEqualTo(type1.targetType, type2.targetType);
                    break;
                  case "normal":
                    return this.isTypeEqualTo(type1.targetType, type2.eleType || type2.targetType);
                    break;
                }
              }
              break;
            case "function":
              if (this.isTypeEqualTo(type1.retType, type2.retType) && type1.signature.length === type2.signature.length) {
                return type1.signature.every((type, index, arr) => {
                  const x = this.isTypeEqualTo(type, type2.signature[index]);
                  return x;
                });
              }
              break;
          }
        }
        return type1 === type2;
      }
      isBoolType(type) {
        if (typeof type === "string") {
          return type === "bool";
        } else {
          return type.type === "primitive" && this.isBoolType(type.name);
        }
      }
      isVoidType(type) {
        if (typeof type === "string") {
          return type === "void";
        } else {
          return type.type === "primitive" && this.isVoidType(type.name);
        }
      }
      isPrimitiveType(type) {
        if (typeof type === "string") {
          return this.isNumericType(type) || this.isBoolType(type) || this.isVoidType(type);
        }
        if ("t" in type) {
          return type.t !== "dummy" && this.isPrimitiveType(type.t);
        }
        return this.isNumericType(type) || this.isBoolType(type) || this.isVoidType(type);
      }
      isArrayType(type) {
        if ("t" in type) {
          return type.t !== "dummy" && this.isArrayType(type.t);
        }
        return this.isPointerType(type) && type.ptrType === "array";
      }
      isArrayElementType(type) {
        return type.t !== "dummy" && "array" in type.t;
      }
      isFunctionPointerType(type) {
        if ("t" in type) {
          return type.t !== "dummy" && this.isFunctionPointerType(type.t);
        }
        return this.isPointerType(type) && type.ptrType === "function";
      }
      isFunctionType(type) {
        if ("t" in type) {
          return type.t !== "dummy" && this.isFunctionType(type.t);
        }
        return type.type === "function";
      }
      isNormalPointerType(type) {
        if ("t" in type) {
          return type.t !== "dummy" && this.isNormalPointerType(type.t);
        }
        return this.isPointerType(type) && type.ptrType === "normal";
      }
      isPointerType(type) {
        if ("t" in type) {
          return type.t !== "dummy" && this.isPointerType(type.t);
        }
        return type.type === "pointer";
      }
      isClassType(type) {
        if ("t" in type) {
          return type.t !== "dummy" && this.isClassType(type.t);
        }
        return type.type === "class";
      }
      arrayPointerType(eleType, size) {
        return {
          type: "pointer",
          ptrType: "array",
          eleType,
          size
        };
      }
      makeArrayPointerValue(arr, position) {
        return {
          target: arr,
          position
        };
      }
      functionPointerType(retType, signature) {
        return {
          type: "pointer",
          ptrType: "function",
          targetType: this.functionType(retType, signature)
        };
      }
      functionType(retType, signature) {
        return {
          type: "function",
          retType,
          signature
        };
      }
      makeFunctionPointerValue(f, name, lt, args, retType) {
        return {
          target: f,
          name,
          defineType: lt,
          args,
          retType
        };
      }
      normalPointerType(targetType) {
        if (targetType.type === "function") {
          return {
            type: "pointer",
            ptrType: "function",
            targetType
          };
        }
        return {
          type: "pointer",
          ptrType: "normal",
          targetType
        };
      }
      makeNormalPointerValue(target) {
        return {
          target
        };
      }
      simpleType(type) {
        if (Array.isArray(type)) {
          if (type.length > 1) {
            const typeStr = type.filter((t) => {
              return !this.config.specifiers.includes(t);
            }).join(" ");
            return this.simpleType(typeStr);
          } else {
            return this.typedefs[type[0]] || this.simpleType(type[0]);
          }
        } else {
          if (this.isPrimitiveType(type)) {
            return this.primitiveType(type);
          } else {
            const clsType = {
              type: "class",
              name: type
            };
            if (this.getTypeSignature(clsType) in this.types) {
              return clsType;
            } else {
              this.raiseException("type " + type + " is not defined");
            }
          }
        }
      }
      newClass(classname, members) {
        const clsType = {
          type: "class",
          name: classname
        };
        const sig = this.getTypeSignature(clsType);
        if (sig in this.types) {
          this.raiseException(this.makeTypeString(clsType) + " is already defined");
        }
        this.types[sig] = {
          cConstructor(rt2, _this2) {
            const v = _this2.v;
            v.members = {};
            let i2 = 0;
            while (i2 < members.length) {
              const member = members[i2];
              v.members[member.name] = member.initialize != null ? member.initialize(rt2, _this2) : rt2.defaultValue(member.type, true);
              i2++;
            }
          },
          members,
          handlers: {}
        };
        return clsType;
      }
      primitiveType(type) {
        return {
          type: "primitive",
          name: type
        };
      }
      isCharType(type) {
        return "name" in type && this.config.charTypes.indexOf(type.name) !== -1;
      }
      isStringType(type) {
        if ("t" in type) {
          return this.isStringType(type.t);
        }
        return this.isArrayType(type) && this.isCharType(type.eleType);
      }
      getStringFromCharArray(element) {
        if (this.isStringType(element.t)) {
          const { target } = element.v;
          let result = "";
          let i2 = 0;
          while (i2 < target.length) {
            const charVal = target[i2];
            if (charVal.v === 0) {
              break;
            }
            result += String.fromCharCode(charVal.v);
            i2++;
          }
          return result;
        } else {
          this.raiseException("target is not a string");
        }
      }
      makeCharArrayFromString(str, typename) {
        if (!typename) {
          typename = "char";
        }
        const charType = this.primitiveType(typename);
        const type = this.arrayPointerType(charType, str.length + 1);
        const trailingZero = this.val(charType, 0);
        return {
          t: type,
          v: {
            target: str.split("").map((c2) => this.val(charType, c2.charCodeAt(0))).concat([trailingZero]),
            position: 0
          }
        };
      }
      getTypeSignature(type) {
        if (typeof type === "string") {
          return type;
        }
        let ret2;
        if (type.type === "primitive") {
          ret2 = "(" + type.name + ")";
        } else if (type.type === "class") {
          ret2 = "[" + type.name + "]";
        } else if (type.type === "pointer") {
          ret2 = "{";
          if (type.ptrType === "normal") {
            ret2 += "!" + this.getTypeSignature(type.targetType);
          } else if (type.ptrType === "array") {
            ret2 += "!" + this.getTypeSignature(type.eleType);
          }
          ret2 += "}";
        } else if (type.type === "function") {
          ret2 = "#" + this.getTypeSignature(type.retType) + "!" + type.signature.map((e) => {
            return this.getTypeSignature(e);
          }).join(",");
        }
        return ret2;
      }
      makeTypeString(type) {
        let ret2;
        if (typeof type === "string") {
          ret2 = "$" + type;
        } else if (type.type === "primitive") {
          ret2 = type.name;
        } else if (type.type === "class") {
          ret2 = type.name;
        } else if (type.type === "pointer") {
          ret2 = "";
          if (type.ptrType === "normal") {
            ret2 += this.makeTypeString(type.targetType) + "*";
          } else if (type.ptrType === "array") {
            ret2 += this.makeTypeString(type.eleType) + `[${type.size}]`;
          } else if (type.ptrType === "function") {
            ret2 += this.makeTypeString(type.targetType.retType) + "(*f)(" + type.targetType.signature.map((e) => {
              return this.makeTypeString(e);
            }).join(",") + ")";
          }
        }
        return ret2;
      }
      makeValueString(l, options2) {
        let display;
        if (!options2) {
          options2 = {};
        }
        if (this.isPrimitiveType(l)) {
          if (this.isTypeEqualTo(l.t, this.charTypeLiteral)) {
            display = "'" + String.fromCharCode(l.v) + "'";
          } else if (this.isBoolType(l.t)) {
            display = l.v !== 0 ? "true" : "false";
          } else {
            display = l.v.toString();
          }
        } else if (this.isPointerType(l)) {
          if (this.isFunctionType(l.t)) {
            display = "<function>";
          } else if (this.isArrayType(l)) {
            if (this.isTypeEqualTo(l.t.eleType, this.charTypeLiteral)) {
              display = '"' + this.getStringFromCharArray(l) + '"';
            } else if (options2.noArray) {
              display = "[...]";
            } else {
              options2.noArray = true;
              const displayList = [];
              for (let i2 = l.v.position, end = l.v.target.length, asc = l.v.position <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
                displayList.push(this.makeValueString(l.v.target[i2], options2));
              }
              display = "[" + displayList.join(",") + "]";
            }
          } else if (this.isNormalPointerType(l)) {
            if (options2.noPointer) {
              display = "->?";
            } else {
              options2.noPointer = true;
              display = "->" + this.makeValueString(l.v.target);
            }
          } else {
            this.raiseException("unknown pointer type");
          }
        } else if (this.isClassType(l)) {
          display = "<object>";
        }
        return display;
      }
      makeValString(l) {
        return this.makeValueString(l) + "(" + this.makeTypeString(l.t) + ")";
      }
      defaultValue(type, left = false) {
        if (type.type === "primitive") {
          return this.val(type, NaN, left, true);
        } else if (type.type === "class") {
          const ret2 = this.val(type, {
            members: {}
          }, left);
          this.types[this.getTypeSignature(type)].cConstructor(this, ret2);
          return ret2;
        } else if (type.type === "pointer") {
          if (type.ptrType === "normal") {
            return this.val(type, this.makeNormalPointerValue(null), left);
          } else if (type.ptrType === "array") {
            const init = [];
            for (let i2 = 0, end = type.size, asc = 0 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
              init[i2] = this.defaultValue(type.eleType, true);
            }
            return this.val(type, this.makeArrayPointerValue(init, 0), left);
          } else if (type.ptrType === "function") {
            return this.val(this.functionPointerType(type.targetType.retType, type.targetType.signature), this.makeFunctionPointerValue(null, null, null, type.targetType.signature, type.targetType.retType));
          }
        }
      }
      raiseException(message, currentNode) {
        if (this.interp) {
          if (currentNode == null) {
            ({
              currentNode
            } = this.interp);
          }
          const posInfo = (() => {
            if (currentNode != null) {
              const ln = currentNode.sLine;
              const col = currentNode.sColumn;
              return ln + ":" + col;
            } else {
              return "<position unavailable>";
            }
          })();
          throw new Error(posInfo + " " + message);
        } else {
          throw new Error(message);
        }
      }
    };
    exports2.CRuntime = CRuntime;
  }
});

// node_modules/JSCPP/lib/interpreter.js
var require_interpreter = __commonJS({
  "node_modules/JSCPP/lib/interpreter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Interpreter = exports2.BaseInterpreter = void 0;
    var sampleGeneratorFunction = function* () {
      return yield null;
    };
    var sampleGenerator = sampleGeneratorFunction();
    var isGenerator = (g) => {
      return (g != null ? g.constructor : void 0) === sampleGenerator.constructor;
    };
    var isGeneratorFunction = (f) => {
      return (f != null ? f.constructor : void 0) === sampleGeneratorFunction.constructor;
    };
    var BaseInterpreter = class {
      constructor(rt2) {
        this.rt = rt2;
      }
    };
    exports2.BaseInterpreter = BaseInterpreter;
    function isIterable(obj) {
      if (obj == null) {
        return false;
      }
      return typeof obj[Symbol.iterator] === "function";
    }
    var Interpreter = class extends BaseInterpreter {
      constructor(rt2) {
        super(rt2);
        this.visitors = {
          *TranslationUnit(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            let i2 = 0;
            while (i2 < s2.ExternalDeclarations.length) {
              const dec = s2.ExternalDeclarations[i2];
              yield* interp.visit(interp, dec);
              i2++;
            }
          },
          *DirectDeclarator(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            let { basetype } = param;
            basetype = interp.buildRecursivePointerType(s2.Pointer, basetype, 0);
            if (s2.right.length === 1) {
              let varargs;
              const right = s2.right[0];
              let ptl = null;
              if (right.type === "DirectDeclarator_modifier_ParameterTypeList") {
                ptl = right.ParameterTypeList;
                ({
                  varargs
                } = ptl);
              } else if (right.type === "DirectDeclarator_modifier_IdentifierList" && right.IdentifierList === null) {
                ptl = right.ParameterTypeList;
                varargs = false;
              }
              if (ptl != null) {
                const argTypes = [];
                for (const _param of ptl.ParameterList) {
                  const _basetype = rt2.simpleType(_param.DeclarationSpecifiers);
                  let _type;
                  if (_param.Declarator != null) {
                    const _pointer = _param.Declarator.Pointer;
                    _type = interp.buildRecursivePointerType(_pointer, _basetype, 0);
                    if (_param.Declarator.right != null && _param.Declarator.right.length > 0) {
                      const dimensions = [];
                      for (let j = 0; j < _param.Declarator.right.length; j++) {
                        let dim = _param.Declarator.right[j];
                        if (dim.type !== "DirectDeclarator_modifier_array") {
                          rt2.raiseException("unacceptable array initialization", dim);
                        }
                        if (dim.Expression !== null) {
                          dim = rt2.cast(rt2.intTypeLiteral, yield* interp.visit(interp, dim.Expression, param)).v;
                        } else if (j > 0) {
                          rt2.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                        } else {
                          dim = -1;
                        }
                        dimensions.push(dim);
                      }
                      _type = interp.arrayType(dimensions, _type);
                    }
                  } else {
                    _type = _basetype;
                  }
                  argTypes.push(_type);
                }
                basetype = rt2.functionType(basetype, argTypes);
              }
            }
            if (s2.right.length > 0 && s2.right[0].type === "DirectDeclarator_modifier_array") {
              const dimensions = [];
              for (let j = 0; j < s2.right.length; j++) {
                let dim = s2.right[j];
                if (dim.type !== "DirectDeclarator_modifier_array") {
                  rt2.raiseException("unacceptable array initialization", dim);
                }
                if (dim.Expression !== null) {
                  dim = rt2.cast(rt2.intTypeLiteral, yield* interp.visit(interp, dim.Expression, param)).v;
                } else if (j > 0) {
                  rt2.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                } else {
                  dim = -1;
                }
                dimensions.push(dim);
              }
              basetype = interp.arrayType(dimensions, basetype);
            }
            if (s2.left.type === "Identifier") {
              return { type: basetype, name: s2.left.Identifier };
            } else {
              const _basetype = param.basetype;
              param.basetype = basetype;
              const ret2 = yield* interp.visit(interp, s2.left, param);
              param.basetype = _basetype;
              return ret2;
            }
          },
          *TypedefDeclaration(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const basetype = rt2.simpleType(s2.DeclarationSpecifiers);
            const _basetype = param.basetype;
            param.basetype = basetype;
            for (const declarator of s2.Declarators) {
              const { type, name } = yield* interp.visit(interp, declarator, param);
              rt2.registerTypedef(type, name);
            }
            param.basetype = _basetype;
          },
          *FunctionDefinition(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const { scope } = param;
            const name = s2.Declarator.left.Identifier;
            let basetype = rt2.simpleType(s2.DeclarationSpecifiers);
            const pointer = s2.Declarator.Pointer;
            basetype = interp.buildRecursivePointerType(pointer, basetype, 0);
            const argTypes = [];
            const argNames = [];
            const optionalArgs = [];
            let ptl;
            let varargs;
            if (s2.Declarator.right.type === "DirectDeclarator_modifier_ParameterTypeList") {
              ptl = s2.Declarator.right.ParameterTypeList;
              ({
                varargs
              } = ptl);
            } else if (s2.Declarator.right.type === "DirectDeclarator_modifier_IdentifierList" && s2.Declarator.right.IdentifierList === null) {
              ptl = { ParameterList: [] };
              varargs = false;
            } else {
              rt2.raiseException("unacceptable argument list", s2.Declarator.right);
            }
            let i2 = 0;
            while (i2 < ptl.ParameterList.length) {
              const _param = ptl.ParameterList[i2];
              if (_param.Declarator == null) {
                rt2.raiseException("missing declarator for argument", _param);
              }
              const _init = _param.Declarator.Initializers;
              const _pointer = _param.Declarator.Declarator.Pointer;
              const _basetype = rt2.simpleType(_param.DeclarationSpecifiers);
              let _type = interp.buildRecursivePointerType(_pointer, _basetype, 0);
              const _name = _param.Declarator.Declarator.left.Identifier;
              if (_param.Declarator.Declarator.right.length > 0) {
                const dimensions = [];
                let j = 0;
                while (j < _param.Declarator.Declarator.right.length) {
                  let dim = _param.Declarator.Declarator.right[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt2.raiseException("unacceptable array initialization", dim);
                  }
                  if (dim.Expression !== null) {
                    dim = rt2.cast(rt2.intTypeLiteral, yield* interp.visit(interp, dim.Expression, param)).v;
                  } else if (j > 0) {
                    rt2.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                  } else {
                    dim = -1;
                  }
                  dimensions.push(dim);
                  j++;
                }
                _type = interp.arrayType(dimensions, _type);
              }
              if (_init != null) {
                optionalArgs.push({
                  type: _type,
                  name: _name,
                  expression: _init.Expression
                });
              } else {
                if (optionalArgs.length > 0) {
                  rt2.raiseException("all default arguments must be at the end of arguments list", _param);
                }
                argTypes.push(_type);
                argNames.push(_name);
              }
              i2++;
            }
            const stat = s2.CompoundStatement;
            rt2.defFunc(scope, name, basetype, argTypes, argNames, stat, interp, optionalArgs);
          },
          *Declaration(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const basetype = rt2.simpleType(s2.DeclarationSpecifiers);
            for (const dec of s2.InitDeclaratorList) {
              let init = dec.Initializers;
              if (dec.Declarator.right.length > 0 && dec.Declarator.right[0].type === "DirectDeclarator_modifier_array") {
                const dimensions = [];
                for (let j = 0; j < dec.Declarator.right.length; j++) {
                  let dim = dec.Declarator.right[j];
                  if (dim.Expression !== null) {
                    dim = rt2.cast(rt2.intTypeLiteral, yield* interp.visit(interp, dim.Expression, param)).v;
                  } else if (j > 0) {
                    rt2.raiseException("multidimensional array must have bounds for all dimensions except the first", dim);
                  } else {
                    if (init.type === "Initializer_expr") {
                      const initializer = yield* interp.visit(interp, init, param);
                      if (rt2.isCharType(basetype) && rt2.isArrayType(initializer) && rt2.isCharType(initializer.t.eleType)) {
                        dim = initializer.v.target.length;
                        init = {
                          type: "Initializer_array",
                          Initializers: initializer.v.target.map((e) => ({
                            type: "Initializer_expr",
                            shorthand: e
                          }))
                        };
                      } else {
                        rt2.raiseException("cannot initialize an array to " + rt2.makeValString(initializer), init);
                      }
                    } else {
                      dim = init.Initializers.length;
                    }
                  }
                  dimensions.push(dim);
                }
                param.node = init;
                init = yield* interp.arrayInit(dimensions, init, basetype, param);
                delete param.node;
                const _basetype = param.basetype;
                param.basetype = basetype;
                const { name, type } = yield* interp.visit(interp, dec.Declarator, param);
                param.basetype = _basetype;
                rt2.defVar(name, init.t, init);
              } else {
                const _basetype = param.basetype;
                param.basetype = basetype;
                const { name, type } = yield* interp.visit(interp, dec.Declarator, param);
                param.basetype = _basetype;
                if (init == null) {
                  init = rt2.defaultValue(type, true);
                } else {
                  init = yield* interp.visit(interp, init.Expression);
                }
                rt2.defVar(name, type, init);
              }
            }
          },
          *Initializer_expr(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return yield* interp.visit(interp, s2.Expression, param);
          },
          *Label_case(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ce = yield* interp.visit(interp, s2.ConstantExpression);
            if (param["switch"] === void 0) {
              rt2.raiseException("you cannot use case outside switch block");
            }
            if (param.scope === "SelectionStatement_switch_cs") {
              return [
                "switch",
                rt2.cast(ce.t, param["switch"]).v === ce.v
              ];
            } else {
              rt2.raiseException("you can only use case directly in a switch block");
            }
          },
          Label_default(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            if (param["switch"] === void 0) {
              rt2.raiseException("you cannot use default outside switch block");
            }
            if (param.scope === "SelectionStatement_switch_cs") {
              return [
                "switch",
                true
              ];
            } else {
              rt2.raiseException("you can only use default directly in a switch block");
            }
          },
          *CompoundStatement(interp, s2, param) {
            let stmt;
            ({
              rt: rt2
            } = interp);
            const stmts = s2.Statements;
            let r;
            let i2;
            const _scope = param.scope;
            if (param.scope === "SelectionStatement_switch") {
              param.scope = "SelectionStatement_switch_cs";
              rt2.enterScope(param.scope);
              let switchon = false;
              i2 = 0;
              while (i2 < stmts.length) {
                stmt = stmts[i2];
                if (stmt.type === "Label_case" || stmt.type === "Label_default") {
                  r = yield* interp.visit(interp, stmt, param);
                  if (r[1]) {
                    switchon = true;
                  }
                } else if (switchon) {
                  r = yield* interp.visit(interp, stmt, param);
                  if (r instanceof Array) {
                    return r;
                  }
                }
                i2++;
              }
              rt2.exitScope(param.scope);
              param.scope = _scope;
            } else {
              param.scope = "CompoundStatement";
              rt2.enterScope(param.scope);
              for (stmt of stmts) {
                r = yield* interp.visit(interp, stmt, param);
                if (r instanceof Array) {
                  break;
                }
              }
              rt2.exitScope(param.scope);
              param.scope = _scope;
              return r;
            }
          },
          *ExpressionStatement(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            if (s2.Expression != null) {
              yield* interp.visit(interp, s2.Expression, param);
            }
          },
          *SelectionStatement_if(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const scope_bak = param.scope;
            param.scope = "SelectionStatement_if";
            rt2.enterScope(param.scope);
            const e = yield* interp.visit(interp, s2.Expression, param);
            let ret2;
            if (rt2.cast(rt2.boolTypeLiteral, e).v) {
              ret2 = yield* interp.visit(interp, s2.Statement, param);
            } else if (s2.ElseStatement) {
              ret2 = yield* interp.visit(interp, s2.ElseStatement, param);
            }
            rt2.exitScope(param.scope);
            param.scope = scope_bak;
            return ret2;
          },
          *SelectionStatement_switch(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const scope_bak = param.scope;
            param.scope = "SelectionStatement_switch";
            rt2.enterScope(param.scope);
            const e = yield* interp.visit(interp, s2.Expression, param);
            const switch_bak = param["switch"];
            param["switch"] = e;
            const r = yield* interp.visit(interp, s2.Statement, param);
            param["switch"] = switch_bak;
            let ret2;
            if (r instanceof Array) {
              if (r[0] !== "break") {
                ret2 = r;
              }
            }
            rt2.exitScope(param.scope);
            param.scope = scope_bak;
            return ret2;
          },
          *IterationStatement_while(interp, s2, param) {
            let return_val;
            ({
              rt: rt2
            } = interp);
            const scope_bak = param.scope;
            param.scope = "IterationStatement_while";
            rt2.enterScope(param.scope);
            while (true) {
              if (s2.Expression != null) {
                let cond = yield* interp.visit(interp, s2.Expression, param);
                cond = rt2.cast(rt2.boolTypeLiteral, cond).v;
                if (!cond) {
                  break;
                }
              }
              const r = yield* interp.visit(interp, s2.Statement, param);
              if (r instanceof Array) {
                let end_loop;
                switch (r[0]) {
                  case "continue":
                    break;
                  case "break":
                    end_loop = true;
                    break;
                  case "return":
                    return_val = r;
                    end_loop = true;
                    break;
                }
                if (end_loop) {
                  break;
                }
              }
            }
            rt2.exitScope(param.scope);
            param.scope = scope_bak;
            return return_val;
          },
          *IterationStatement_do(interp, s2, param) {
            let return_val;
            ({
              rt: rt2
            } = interp);
            const scope_bak = param.scope;
            param.scope = "IterationStatement_do";
            rt2.enterScope(param.scope);
            while (true) {
              const r = yield* interp.visit(interp, s2.Statement, param);
              if (r instanceof Array) {
                let end_loop;
                switch (r[0]) {
                  case "continue":
                    break;
                  case "break":
                    end_loop = true;
                    break;
                  case "return":
                    return_val = r;
                    end_loop = true;
                    break;
                }
                if (end_loop) {
                  break;
                }
              }
              if (s2.Expression != null) {
                let cond = yield* interp.visit(interp, s2.Expression, param);
                cond = rt2.cast(rt2.boolTypeLiteral, cond).v;
                if (!cond) {
                  break;
                }
              }
            }
            rt2.exitScope(param.scope);
            param.scope = scope_bak;
            return return_val;
          },
          *IterationStatement_for(interp, s2, param) {
            let return_val;
            ({
              rt: rt2
            } = interp);
            const scope_bak = param.scope;
            param.scope = "IterationStatement_for";
            rt2.enterScope(param.scope);
            if (s2.Initializer) {
              if (s2.Initializer.type === "Declaration") {
                yield* interp.visit(interp, s2.Initializer, param);
              } else {
                yield* interp.visit(interp, s2.Initializer, param);
              }
            }
            while (true) {
              if (s2.Expression != null) {
                let cond = yield* interp.visit(interp, s2.Expression, param);
                cond = rt2.cast(rt2.boolTypeLiteral, cond).v;
                if (!cond) {
                  break;
                }
              }
              const r = yield* interp.visit(interp, s2.Statement, param);
              if (r instanceof Array) {
                let end_loop;
                switch (r[0]) {
                  case "continue":
                    break;
                  case "break":
                    end_loop = true;
                    break;
                  case "return":
                    return_val = r;
                    end_loop = true;
                    break;
                }
                if (end_loop) {
                  break;
                }
              }
              if (s2.Loop) {
                yield* interp.visit(interp, s2.Loop, param);
              }
            }
            rt2.exitScope(param.scope);
            param.scope = scope_bak;
            return return_val;
          },
          JumpStatement_goto(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            rt2.raiseException("not implemented");
          },
          JumpStatement_continue(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return ["continue"];
          },
          JumpStatement_break(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return ["break"];
          },
          *JumpStatement_return(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            if (s2.Expression) {
              const ret2 = yield* interp.visit(interp, s2.Expression, param);
              return [
                "return",
                ret2
              ];
            }
            return ["return"];
          },
          IdentifierExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.readVar(s2.Identifier);
          },
          *ParenthesesExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return yield* interp.visit(interp, s2.Expression, param);
          },
          *PostfixExpression_ArrayAccess(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const index = yield* interp.visit(interp, s2.index, param);
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("[]"), [index.t])(rt2, ret2, index);
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *PostfixExpression_MethodInvocation(interp, s2, param) {
            let bindThis;
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const args = yield* function* () {
              const result = [];
              for (const e of s2.args) {
                const thisArg = yield* interp.visit(interp, e, param);
                result.push(thisArg);
              }
              return result;
            }.call(this);
            if (ret2.v.bindThis != null) {
              ({
                bindThis
              } = ret2.v);
            } else {
              bindThis = ret2;
            }
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("()"), args.map((e) => e.t))(rt2, ret2, bindThis, ...args);
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *PostfixExpression_MemberAccess(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            return rt2.getMember(ret2, s2.member);
          },
          *PostfixExpression_MemberPointerAccess(interp, s2, param) {
            let r;
            ({
              rt: rt2
            } = interp);
            let ret2 = yield* interp.visit(interp, s2.Expression, param);
            if (rt2.isPointerType(ret2.t) && !rt2.isFunctionType(ret2.t)) {
              const { member } = s2;
              ret2 = yield* rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("->"), [])(rt2, ret2);
              return rt2.getMember(ret2, member);
            } else {
              const member = yield* interp.visit(interp, {
                type: "IdentifierExpression",
                Identifier: s2.member
              }, param);
              ret2 = yield* rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("->"), [member.t])(rt2, ret2);
              return rt2.getMember(ret2, member);
            }
          },
          *PostfixExpression_PostIncrement(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("++"), ["dummy"])(rt2, ret2, {
              t: "dummy",
              v: null
            });
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *PostfixExpression_PostDecrement(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("--"), ["dummy"])(rt2, ret2, {
              t: "dummy",
              v: null
            });
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *UnaryExpression_PreIncrement(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("++"), [])(rt2, ret2);
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *UnaryExpression_PreDecrement(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName("--"), [])(rt2, ret2);
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *UnaryExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const r = rt2.getFunc(ret2.t, rt2.makeOperatorFuncName(s2.op), [])(rt2, ret2);
            if (isGenerator(r)) {
              return yield* r;
            } else {
              return r;
            }
          },
          *UnaryExpression_Sizeof_Expr(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            return rt2.val(rt2.intTypeLiteral, rt2.getSize(ret2));
          },
          *UnaryExpression_Sizeof_Type(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const type = yield* interp.visit(interp, s2.TypeName, param);
            return rt2.val(rt2.intTypeLiteral, rt2.getSizeByType(type));
          },
          *CastExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const ret2 = yield* interp.visit(interp, s2.Expression, param);
            const type = yield* interp.visit(interp, s2.TypeName, param);
            return rt2.cast(type, ret2);
          },
          TypeName(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const typename = [];
            for (const baseType of s2.base) {
              if (baseType !== "const") {
                typename.push(baseType);
              }
            }
            return rt2.simpleType(typename);
          },
          *BinOpExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const { op } = s2;
            if (op === "&&") {
              s2.type = "LogicalANDExpression";
              return yield* interp.visit(interp, s2, param);
            } else if (op === "||") {
              s2.type = "LogicalORExpression";
              return yield* interp.visit(interp, s2, param);
            } else {
              const left = yield* interp.visit(interp, s2.left, param);
              const right = yield* interp.visit(interp, s2.right, param);
              const r = rt2.getFunc(left.t, rt2.makeOperatorFuncName(op), [right.t])(rt2, left, right);
              if (isGenerator(r)) {
                return yield* r;
              } else {
                return r;
              }
            }
          },
          *LogicalANDExpression(interp, s2, param) {
            let right;
            ({
              rt: rt2
            } = interp);
            const left = yield* interp.visit(interp, s2.left, param);
            const lt = rt2.types[rt2.getTypeSignature(left.t)];
            if ("&&" in lt) {
              right = yield* interp.visit(interp, s2.right, param);
              const r = rt2.getFunc(left.t, rt2.makeOperatorFuncName("&&"), [right.t])(rt2, left, right);
              if (isGenerator(r)) {
                return yield* r;
              } else {
                return r;
              }
            } else {
              if (rt2.cast(rt2.boolTypeLiteral, left).v) {
                return yield* interp.visit(interp, s2.right, param);
              } else {
                return left;
              }
            }
          },
          *LogicalORExpression(interp, s2, param) {
            let right;
            ({
              rt: rt2
            } = interp);
            const left = yield* interp.visit(interp, s2.left, param);
            const lt = rt2.types[rt2.getTypeSignature(left.t)];
            if ("||" in lt) {
              right = yield* interp.visit(interp, s2.right, param);
              const r = rt2.getFunc(left.t, rt2.makeOperatorFuncName("||"), [right.t])(rt2, left, right);
              if (isGenerator(r)) {
                return yield* r;
              } else {
                return r;
              }
            } else {
              if (rt2.cast(rt2.boolTypeLiteral, left).v) {
                return left;
              } else {
                return yield* interp.visit(interp, s2.right, param);
              }
            }
          },
          *ConditionalExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const cond = rt2.cast(rt2.boolTypeLiteral, yield* interp.visit(interp, s2.cond, param)).v;
            if (cond) {
              return yield* interp.visit(interp, s2.t, param);
            } else {
              return yield* interp.visit(interp, s2.f, param);
            }
          },
          *ConstantExpression(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return yield* interp.visit(interp, s2.Expression, param);
          },
          *StringLiteralExpression(interp, s2, param) {
            return yield* interp.visit(interp, s2.value, param);
          },
          StringLiteral(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            switch (s2.prefix) {
              case null:
                let maxCode = -1;
                let minCode = 1;
                for (const i2 of s2.value) {
                  const code = i2.charCodeAt(0);
                  if (maxCode < code) {
                    maxCode = code;
                  }
                  if (minCode > code) {
                    minCode = code;
                  }
                }
                const { limits } = rt2.config;
                const typeName = maxCode <= limits["char"].max && minCode >= limits["char"].min ? "char" : "wchar_t";
                return rt2.makeCharArrayFromString(s2.value, typeName);
              case "L":
                return rt2.makeCharArrayFromString(s2.value, "wchar_t");
              case "u8":
                return rt2.makeCharArrayFromString(s2.value, "char");
              case "u":
                return rt2.makeCharArrayFromString(s2.value, "char16_t");
              case "U":
                return rt2.makeCharArrayFromString(s2.value, "char32_t");
            }
          },
          BooleanConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.boolTypeLiteral, s2.value === "true" ? 1 : 0);
          },
          CharacterConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const a2 = s2.Char;
            if (a2.length !== 1) {
              rt2.raiseException("a character constant must have and only have one character.");
            }
            return rt2.val(rt2.charTypeLiteral, a2[0].charCodeAt(0));
          },
          *FloatConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const val = yield* interp.visit(interp, s2.Expression, param);
            return rt2.val(rt2.floatTypeLiteral, val.v);
          },
          DecimalConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.unsignedintTypeLiteral, parseInt(s2.value, 10));
          },
          HexConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.unsignedintTypeLiteral, parseInt(s2.value, 16));
          },
          BinaryConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.unsignedintTypeLiteral, parseInt(s2.value, 2));
          },
          DecimalFloatConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.doubleTypeLiteral, parseFloat(s2.value));
          },
          HexFloatConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.doubleTypeLiteral, parseInt(s2.value, 16));
          },
          OctalConstant(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            return rt2.val(rt2.unsignedintTypeLiteral, parseInt(s2.value, 8));
          },
          NamespaceDefinition(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            rt2.raiseException("not implemented");
          },
          UsingDirective(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            const id = s2.Identifier;
          },
          UsingDeclaration(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            rt2.raiseException("not implemented");
          },
          NamespaceAliasDefinition(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            rt2.raiseException("not implemented");
          },
          unknown(interp, s2, param) {
            ({
              rt: rt2
            } = interp);
            rt2.raiseException("unhandled syntax " + s2.type);
          }
        };
      }
      *visit(interp, s2, param) {
        let ret2;
        const { rt: rt2 } = interp;
        if ("type" in s2) {
          if (param === void 0) {
            param = { scope: "global" };
          }
          const _node = this.currentNode;
          this.currentNode = s2;
          if (s2.type in this.visitors) {
            const f = this.visitors[s2.type];
            if (isGeneratorFunction(f)) {
              const x = f(interp, s2, param);
              if (x != null) {
                if (isIterable(x)) {
                  ret2 = yield* x;
                } else {
                  ret2 = yield x;
                }
              } else {
                ret2 = yield null;
              }
            } else {
              yield ret2 = f(interp, s2, param);
            }
          } else {
            ret2 = this.visitors["unknown"](interp, s2, param);
          }
          this.currentNode = _node;
        } else {
          this.currentNode = s2;
          this.rt.raiseException("untyped syntax structure");
        }
        return ret2;
      }
      *run(tree, source, param) {
        this.rt.interp = this;
        this.source = source;
        return yield* this.visit(this, tree, param);
      }
      *arrayInit(dimensions, init, type, param) {
        if (dimensions.length > 0) {
          let val;
          const curDim = dimensions[0];
          if (init) {
            if (init.type === "Initializer_array" && (init.Initializers != null && curDim >= init.Initializers.length)) {
              if (init.Initializers.length === 0) {
                const arr = new Array(curDim);
                let i2 = 0;
                while (i2 < curDim) {
                  arr[i2] = {
                    type: "Initializer_expr",
                    shorthand: this.rt.defaultValue(type)
                  };
                  i2++;
                }
                init.Initializers = arr;
              } else if (init.Initializers.length === 1 && this.rt.isIntegerType(type)) {
                val = this.rt.cast(type, yield* this.visit(this, init.Initializers[0].Expression, param));
                if (val.v === -1 || val.v === 0) {
                  const arr = new Array(curDim);
                  let i2 = 0;
                  while (i2 < curDim) {
                    arr[i2] = {
                      type: "Initializer_expr",
                      shorthand: this.rt.val(type, val.v)
                    };
                    i2++;
                  }
                  init.Initializers = arr;
                } else {
                  const arr = new Array(curDim);
                  arr[0] = this.rt.val(type, -1);
                  let i2 = 1;
                  while (i2 < curDim) {
                    arr[i2] = {
                      type: "Initializer_expr",
                      shorthand: this.rt.defaultValue(type)
                    };
                    i2++;
                  }
                  init.Initializers = arr;
                }
              } else {
                const arr = new Array(curDim);
                let i2 = 0;
                while (i2 < init.Initializers.length) {
                  const _init = init.Initializers[i2];
                  let initval;
                  if ("shorthand" in _init) {
                    initval = _init;
                  } else {
                    if (_init.type === "Initializer_expr") {
                      initval = {
                        type: "Initializer_expr",
                        shorthand: yield* this.visit(this, _init.Expression, param)
                      };
                    } else if (_init.type === "Initializer_array") {
                      initval = {
                        type: "Initializer_expr",
                        shorthand: yield* this.arrayInit(dimensions.slice(1), _init, type, param)
                      };
                    } else {
                      this.rt.raiseException("Not implemented initializer type: " + _init.type);
                    }
                  }
                  arr[i2] = initval;
                  i2++;
                }
                i2 = init.Initializers.length;
                while (i2 < curDim) {
                  arr[i2] = {
                    type: "Initializer_expr",
                    shorthand: this.rt.defaultValue(this.arrayType(dimensions.slice(1), type))
                  };
                  i2++;
                }
                init.Initializers = arr;
              }
            } else if (init.type === "Initializer_expr") {
              let initializer;
              if ("shorthand" in init) {
                initializer = init.shorthand;
              } else {
                initializer = yield* this.visit(this, init, param);
              }
              if (this.rt.isArrayType(initializer) && this.rt.isTypeEqualTo(type, initializer.t.eleType)) {
                init = {
                  type: "Initializer_array",
                  Initializers: initializer.v.target.map((e) => ({
                    type: "Initializer_expr",
                    shorthand: e
                  }))
                };
              } else {
                this.rt.raiseException("cannot initialize an array to " + this.rt.makeValString(initializer), param.node);
              }
            } else {
              this.rt.raiseException("dimensions do not agree, " + curDim + " != " + init.Initializers.length, param.node);
            }
          }
          {
            const arr = [];
            const ret2 = this.rt.val(this.arrayType(dimensions, type), this.rt.makeArrayPointerValue(arr, 0), true);
            let i2 = 0;
            while (i2 < curDim) {
              if (init && i2 < init.Initializers.length) {
                arr[i2] = yield* this.arrayInit(dimensions.slice(1), init.Initializers[i2], type, param);
              } else {
                arr[i2] = yield* this.arrayInit(dimensions.slice(1), null, type, param);
              }
              i2++;
            }
            return ret2;
          }
        } else {
          if (init && init.type !== "Initializer_expr") {
            this.rt.raiseException("dimensions do not agree, too few initializers", param.node);
          }
          let initval;
          if (init) {
            if ("shorthand" in init) {
              initval = init.shorthand;
            } else {
              initval = yield* this.visit(this, init.Expression, param);
            }
          } else {
            initval = this.rt.defaultValue(type);
          }
          const ret2 = this.rt.cast(this.arrayType(dimensions, type), initval);
          ret2.left = true;
          return ret2;
        }
      }
      arrayType(dimensions, type) {
        if (dimensions.length > 0) {
          return this.rt.arrayPointerType(this.arrayType(dimensions.slice(1), type), dimensions[0]);
        } else {
          return type;
        }
      }
      buildRecursivePointerType(pointer, basetype, level) {
        if (pointer && pointer.length > level) {
          const type = this.rt.normalPointerType(basetype);
          return this.buildRecursivePointerType(pointer, type, level + 1);
        } else {
          return basetype;
        }
      }
    };
    exports2.Interpreter = Interpreter;
  }
});

// node_modules/JSCPP/lib/ast.js
var require_ast = __commonJS({
  "node_modules/JSCPP/lib/ast.js"(exports, module) {
    module.exports = function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected2, found, location2) {
        this.message = message;
        this.expected = expected2;
        this.found = found;
        this.location = location2;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { TranslationUnit: peg$parseTranslationUnit }, peg$startRuleFunction = peg$parseTranslationUnit, peg$c0 = function(a2) {
          return addPositionInfo({ type: "TranslationUnit", ExternalDeclarations: a2 });
        }, peg$c1 = function(a2, b2) {
          return addPositionInfo({ type: "NamespaceDefinition", Identifier: a2, ExternalDeclarations: b2 });
        }, peg$c2 = function(a2) {
          return addPositionInfo({ type: "UsingDirective", Identifier: a2 });
        }, peg$c3 = function(a2, b2) {
          return addPositionInfo({ type: "UsingDeclaration", scope: a2, Identifier: b2 });
        }, peg$c4 = function(a2, b2) {
          return addPositionInfo({ type: "NamespaceAliasDefinition", target: b2, Identifier: a2 });
        }, peg$c5 = function(a2, b2) {
          return a2;
        }, peg$c6 = function(a2, b2, c2) {
          return addPositionInfo({ type: "TypedefDeclaration", DeclarationSpecifiers: a2, Declarators: [b2].concat(c2) });
        }, peg$c7 = function(a2, b_pointer, b2) {
          return null;
        }, peg$c8 = function(a2, b_pointer, b2, c2) {
          b2.Pointer = b_pointer;
          return addPositionInfo({ type: "FunctionDefinition", DeclarationSpecifiers: a2, Declarator: b2, CompoundStatement: c2 });
        }, peg$c9 = function(a2) {
          return addPositionInfo({ type: "DeclarationList", Declarations: a2 });
        }, peg$c10 = function(a2) {
          return addPositionInfo({ type: "Label_case", ConstantExpression: a2 });
        }, peg$c11 = function() {
          return addPositionInfo({ type: "Label_default" });
        }, peg$c12 = function(a2) {
          return addPositionInfo({ type: "CompoundStatement", Statements: a2 });
        }, peg$c13 = function(a2) {
          return addPositionInfo({ type: "ExpressionStatement", Expression: a2 });
        }, peg$c14 = function(a2, b2, c2) {
          return addPositionInfo({ type: "SelectionStatement_if", Expression: a2, Statement: b2, ElseStatement: c2 ? c2[1] : null });
        }, peg$c15 = function(a2, b2) {
          return addPositionInfo({ type: "SelectionStatement_switch", Expression: a2, Statement: b2 });
        }, peg$c16 = function(a2, b2) {
          return addPositionInfo({ type: "IterationStatement_while", Expression: a2, Statement: b2 });
        }, peg$c17 = function(a2, b2) {
          return addPositionInfo({ type: "IterationStatement_do", Expression: b2, Statement: a2 });
        }, peg$c18 = function(a2, c2, d2, e) {
          return addPositionInfo({ type: "IterationStatement_for", Initializer: a2, Expression: c2, Loop: d2, Statement: e });
        }, peg$c19 = function(a2) {
          return addPositionInfo({ type: "JumpStatement_goto", Identifier: a2 });
        }, peg$c20 = function() {
          return addPositionInfo({ type: "JumpStatement_continue" });
        }, peg$c21 = function() {
          return addPositionInfo({ type: "JumpStatement_break" });
        }, peg$c22 = function(a2) {
          return addPositionInfo({ type: "JumpStatement_return", Expression: a2 });
        }, peg$c23 = function(a2, b2) {
          return addPositionInfo({ type: "Declaration", DeclarationSpecifiers: a2, InitDeclaratorList: b2 });
        }, peg$c24 = function(a2, b2, c2) {
          return a2.concat([b2]).concat(c2);
        }, peg$c25 = function(a2) {
          return a2;
        }, peg$c26 = function(a2) {
          return a2;
        }, peg$c27 = function(a2) {
          return a2;
        }, peg$c28 = function(a2, x) {
          return x;
        }, peg$c29 = function(a2, b2) {
          return [a2].concat(b2);
        }, peg$c30 = function(a2, b2) {
          return addPositionInfo({ type: "InitDeclarator", Declarator: a2, Initializers: b2 });
        }, peg$c31 = function(a2) {
          return a2;
        }, peg$c32 = function(a2) {
          return addPositionInfo({ type: "Identifier", Identifier: a2 });
        }, peg$c33 = function(a2) {
          return addPositionInfo({ type: "DirectDeclarator_modifier_ParameterTypeList", ParameterTypeList: a2 });
        }, peg$c34 = function(a2, b2) {
          return addPositionInfo({ type: "DirectDeclarator", left: a2, right: b2 });
        }, peg$c35 = function(a2, b2) {
          b2.Pointer = a2;
          return b2;
        }, peg$c36 = function(a2, b2) {
          return addPositionInfo({ type: "DirectDeclarator_modifier_array", Modifier: a2 || [], Expression: b2 });
        }, peg$c37 = function(a2, b2) {
          return addPositionInfo({ type: "DirectDeclarator_modifier_array", Modifier: ["static"].concat(a2), Expression: b2 });
        }, peg$c38 = function(a2) {
          return addPositionInfo({ type: "DirectDeclarator_modifier_star_array", Modifier: a2.concat["*"] });
        }, peg$c39 = function(a2) {
          return addPositionInfo({ type: "DirectDeclarator_modifier_IdentifierList", IdentifierList: a2 });
        }, peg$c40 = function(a2, b2) {
          return addPositionInfo({ type: "ParameterTypeList", ParameterList: a2, varargs: b2 !== null });
        }, peg$c41 = function(a2, b2) {
          if (a2)
            return [a2].concat(b2);
          else
            return b2;
        }, peg$c42 = function(a2, b2) {
          return addPositionInfo({ type: "ParameterDeclaration", DeclarationSpecifiers: a2, Declarator: b2 });
        }, peg$c43 = function(a2, b2) {
          return addPositionInfo({ type: "TypeName", base: a2, extra: b2 });
        }, peg$c44 = function(a2) {
          return addPositionInfo({ type: "AbstractDeclarator", Pointer: a2 });
        }, peg$c45 = function(a2) {
          return addPositionInfo({ type: "Initializer_expr", Expression: a2 });
        }, peg$c46 = function(a2) {
          return addPositionInfo({ type: "Initializer_array", Initializers: a2 });
        }, peg$c47 = function(a2, b2) {
          return [a2].concat(b2);
        }, peg$c48 = function(a2) {
          return addPositionInfo({ type: "IdentifierExpression", Identifier: a2 });
        }, peg$c49 = function(a2) {
          return addPositionInfo({ type: "ConstantExpression", Expression: a2 });
        }, peg$c50 = function(a2) {
          return addPositionInfo({ type: "StringLiteralExpression", value: a2 });
        }, peg$c51 = function(a2) {
          return addPositionInfo({ type: "ParenthesesExpression", Expression: a2 });
        }, peg$c52 = function(a2, c2) {
          return [0, c2];
        }, peg$c53 = function(a2, c2) {
          return [1, c2 ? c2 : []];
        }, peg$c54 = function(a2, c2) {
          return [2, c2];
        }, peg$c55 = function(a2, c2) {
          return [3, c2];
        }, peg$c56 = function(a2, c2) {
          return [4];
        }, peg$c57 = function(a2, c2) {
          return [5];
        }, peg$c58 = function(a2, b2) {
          if (b2.length > 0) {
            var ret2 = addPositionInfo({
              Expression: a2
            });
            for (var i2 = 0; i2 < b2.length; i2++) {
              var o = b2[i2][1];
              switch (b2[i2][0]) {
                case 0:
                  ret2.type = "PostfixExpression_ArrayAccess";
                  ret2.index = o;
                  break;
                case 1:
                  ret2.type = "PostfixExpression_MethodInvocation";
                  ret2.args = o;
                  break;
                case 2:
                  ret2.type = "PostfixExpression_MemberAccess";
                  ret2.member = o;
                  break;
                case 3:
                  ret2.type = "PostfixExpression_MemberPointerAccess";
                  ret2.member = o;
                  break;
                case 4:
                  ret2.type = "PostfixExpression_PostIncrement";
                  break;
                case 5:
                  ret2.type = "PostfixExpression_PostDecrement";
                  break;
              }
              ret2 = addPositionInfo({ Expression: ret2 });
            }
            return ret2.Expression;
          } else
            return a2;
        }, peg$c59 = function(a2, b2) {
          var ret2 = [a2];
          for (var i2 = 0; i2 < b2.length; i2++)
            ret2.push(b2[i2][1]);
          return ret2;
        }, peg$c60 = function(a2) {
          return addPositionInfo({ type: "UnaryExpression_PreIncrement", Expression: a2 });
        }, peg$c61 = function(a2) {
          return addPositionInfo({ type: "UnaryExpression_PreDecrement", Expression: a2 });
        }, peg$c62 = function(a2, b2) {
          return addPositionInfo({ type: "UnaryExpression", op: a2, Expression: b2 });
        }, peg$c63 = function(a2) {
          return addPositionInfo({ type: "UnaryExpression_Sizeof_Expr", Expression: a2 });
        }, peg$c64 = function(a2) {
          return addPositionInfo({ type: "UnaryExpression_Sizeof_Type", TypeName: a2 });
        }, peg$c65 = function(a2, b2) {
          return addPositionInfo({ type: "CastExpression", TypeName: a2[1], Expression: b2 });
        }, peg$c66 = function(a2, b2) {
          return buildRecursiveBinop(a2, b2);
        }, peg$c67 = function(a2, b2) {
          var ret2 = a2;
          for (var i2 = 0; i2 < b2.length; i2++) {
            ret2 = addPositionInfo({ type: "ConditionalExpression", cond: ret2, t: b2[i2][1], f: b2[i2][3] });
          }
          return ret2;
        }, peg$c68 = function(a2, b2, c2) {
          return addPositionInfo({ type: "BinOpExpression", op: b2, left: a2, right: c2 });
        }, peg$c69 = function(a2) {
          return a2.join("");
        }, peg$c70 = /^[ \n\r\t\x0B\f]/, peg$c71 = { type: "class", value: "[ \\n\\r\\t\\u000B\\u000C]", description: "[ \\n\\r\\t\\u000B\\u000C]" }, peg$c72 = "/*", peg$c73 = { type: "literal", value: "/*", description: '"/*"' }, peg$c74 = "*/", peg$c75 = { type: "literal", value: "*/", description: '"*/"' }, peg$c76 = function(a2) {
          return a2.join("");
        }, peg$c77 = "//", peg$c78 = { type: "literal", value: "//", description: '"//"' }, peg$c79 = "\n", peg$c80 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c81 = "auto", peg$c82 = { type: "literal", value: "auto", description: '"auto"' }, peg$c83 = "break", peg$c84 = { type: "literal", value: "break", description: '"break"' }, peg$c85 = "case", peg$c86 = { type: "literal", value: "case", description: '"case"' }, peg$c87 = "char", peg$c88 = { type: "literal", value: "char", description: '"char"' }, peg$c89 = "const", peg$c90 = { type: "literal", value: "const", description: '"const"' }, peg$c91 = "continue", peg$c92 = { type: "literal", value: "continue", description: '"continue"' }, peg$c93 = "default", peg$c94 = { type: "literal", value: "default", description: '"default"' }, peg$c95 = "double", peg$c96 = { type: "literal", value: "double", description: '"double"' }, peg$c97 = "do", peg$c98 = { type: "literal", value: "do", description: '"do"' }, peg$c99 = "else", peg$c100 = { type: "literal", value: "else", description: '"else"' }, peg$c101 = "enum", peg$c102 = { type: "literal", value: "enum", description: '"enum"' }, peg$c103 = "extern", peg$c104 = { type: "literal", value: "extern", description: '"extern"' }, peg$c105 = "float", peg$c106 = { type: "literal", value: "float", description: '"float"' }, peg$c107 = "for", peg$c108 = { type: "literal", value: "for", description: '"for"' }, peg$c109 = "goto", peg$c110 = { type: "literal", value: "goto", description: '"goto"' }, peg$c111 = "if", peg$c112 = { type: "literal", value: "if", description: '"if"' }, peg$c113 = "int", peg$c114 = { type: "literal", value: "int", description: '"int"' }, peg$c115 = "inline", peg$c116 = { type: "literal", value: "inline", description: '"inline"' }, peg$c117 = "long", peg$c118 = { type: "literal", value: "long", description: '"long"' }, peg$c119 = "register", peg$c120 = { type: "literal", value: "register", description: '"register"' }, peg$c121 = "restrict", peg$c122 = { type: "literal", value: "restrict", description: '"restrict"' }, peg$c123 = "return", peg$c124 = { type: "literal", value: "return", description: '"return"' }, peg$c125 = "short", peg$c126 = { type: "literal", value: "short", description: '"short"' }, peg$c127 = "signed", peg$c128 = { type: "literal", value: "signed", description: '"signed"' }, peg$c129 = "sizeof", peg$c130 = { type: "literal", value: "sizeof", description: '"sizeof"' }, peg$c131 = "static", peg$c132 = { type: "literal", value: "static", description: '"static"' }, peg$c133 = "struct", peg$c134 = { type: "literal", value: "struct", description: '"struct"' }, peg$c135 = "switch", peg$c136 = { type: "literal", value: "switch", description: '"switch"' }, peg$c137 = "typedef", peg$c138 = { type: "literal", value: "typedef", description: '"typedef"' }, peg$c139 = "union", peg$c140 = { type: "literal", value: "union", description: '"union"' }, peg$c141 = "unsigned", peg$c142 = { type: "literal", value: "unsigned", description: '"unsigned"' }, peg$c143 = "void", peg$c144 = { type: "literal", value: "void", description: '"void"' }, peg$c145 = "volatile", peg$c146 = { type: "literal", value: "volatile", description: '"volatile"' }, peg$c147 = "while", peg$c148 = { type: "literal", value: "while", description: '"while"' }, peg$c149 = "_Bool", peg$c150 = { type: "literal", value: "_Bool", description: '"_Bool"' }, peg$c151 = "_Complex", peg$c152 = { type: "literal", value: "_Complex", description: '"_Complex"' }, peg$c153 = "_stdcall", peg$c154 = { type: "literal", value: "_stdcall", description: '"_stdcall"' }, peg$c155 = "__declspec", peg$c156 = { type: "literal", value: "__declspec", description: '"__declspec"' }, peg$c157 = "__attribute__", peg$c158 = { type: "literal", value: "__attribute__", description: '"__attribute__"' }, peg$c159 = "namespace", peg$c160 = { type: "literal", value: "namespace", description: '"namespace"' }, peg$c161 = "using", peg$c162 = { type: "literal", value: "using", description: '"using"' }, peg$c163 = "true", peg$c164 = { type: "literal", value: "true", description: '"true"' }, peg$c165 = "false", peg$c166 = { type: "literal", value: "false", description: '"false"' }, peg$c167 = "_Imaginary", peg$c168 = { type: "literal", value: "_Imaginary", description: '"_Imaginary"' }, peg$c169 = function(a2, b2, c2) {
          var scope = a2 ? "global" : null;
          for (var i2 = 0; i2 < b2.length; i2++) {
            scope = addPositionInfo({ type: "ScopedIdentifier", scope, Identifier: b2[i2] });
          }
          return addPositionInfo({ type: "ScopedIdentifier", scope, Identifier: c2 });
        }, peg$c170 = function(a2, b2) {
          return a2 + b2.join("");
        }, peg$c171 = /^[a-z]/, peg$c172 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c173 = /^[A-Z]/, peg$c174 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c175 = /^[_]/, peg$c176 = { type: "class", value: "[_]", description: "[_]" }, peg$c177 = /^[0-9]/, peg$c178 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c179 = "\\u", peg$c180 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$c181 = function(a) {
          return eval('"\\u' + a.join("") + '"');
        }, peg$c182 = "\\U", peg$c183 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c184 = function(a, b) {
          return eval('"\\U' + a.join("") + b.join("") + '"');
        }, peg$c185 = function(a2) {
          return addPositionInfo({ type: "BooleanConstant", value: a2 });
        }, peg$c186 = /^[1-9]/, peg$c187 = { type: "class", value: "[1-9]", description: "[1-9]" }, peg$c188 = function(a2, b2) {
          return addPositionInfo({ type: "DecimalConstant", value: a2 + b2.join("") });
        }, peg$c189 = "0", peg$c190 = { type: "literal", value: "0", description: '"0"' }, peg$c191 = /^[0-7]/, peg$c192 = { type: "class", value: "[0-7]", description: "[0-7]" }, peg$c193 = function(a2) {
          if (a2.length > 0)
            return addPositionInfo({ type: "OctalConstant", value: a2.join("") });
          else
            return addPositionInfo({ type: "OctalConstant", value: "0" });
        }, peg$c194 = function(a2) {
          return addPositionInfo({ type: "HexConstant", value: a2.join("") });
        }, peg$c195 = "0x", peg$c196 = { type: "literal", value: "0x", description: '"0x"' }, peg$c197 = "0X", peg$c198 = { type: "literal", value: "0X", description: '"0X"' }, peg$c199 = /^[a-f]/, peg$c200 = { type: "class", value: "[a-f]", description: "[a-f]" }, peg$c201 = /^[A-F]/, peg$c202 = { type: "class", value: "[A-F]", description: "[A-F]" }, peg$c203 = "0b", peg$c204 = { type: "literal", value: "0b", description: '"0b"' }, peg$c205 = /^[0-1]/, peg$c206 = { type: "class", value: "[0-1]", description: "[0-1]" }, peg$c207 = function(a2) {
          return addPositionInfo({ type: "BinaryConstant", value: a2.join("") });
        }, peg$c208 = /^[uU]/, peg$c209 = { type: "class", value: "[uU]", description: "[uU]" }, peg$c210 = "ll", peg$c211 = { type: "literal", value: "ll", description: '"ll"' }, peg$c212 = "LL", peg$c213 = { type: "literal", value: "LL", description: '"LL"' }, peg$c214 = /^[lL]/, peg$c215 = { type: "class", value: "[lL]", description: "[lL]" }, peg$c216 = function(a2, b2) {
          if (b2)
            return addPositionInfo({ type: "FloatConstant", Expression: a2 });
          else
            return a2;
        }, peg$c217 = function(a2, b2) {
          return addPositionInfo({ type: "DecimalFloatConstant", value: a2 + b2 || "" });
        }, peg$c218 = function(a2, b2) {
          return addPositionInfo({ type: "DecimalFloatConstant", value: a2.join("") + b2 });
        }, peg$c219 = function(a2, b2, c2) {
          return addPositionInfo({ type: "HexFloatConstant", value: a2 + b2 + c2 || "" });
        }, peg$c220 = function(a2, b2, c2) {
          return addPositionInfo({ type: "HexFloatConstant", value: a2 + b2.join("") + c2 });
        }, peg$c221 = ".", peg$c222 = { type: "literal", value: ".", description: '"."' }, peg$c223 = function(a2, b2) {
          return a2.join("") + "." + b2.join("");
        }, peg$c224 = function(a2) {
          return a2.join("") + ".";
        }, peg$c225 = /^[eE]/, peg$c226 = { type: "class", value: "[eE]", description: "[eE]" }, peg$c227 = /^[+\-]/, peg$c228 = { type: "class", value: "[+\\-]", description: "[+\\-]" }, peg$c229 = function(a2, b2, c2) {
          return a2 + (b2 || "") + c2.join("");
        }, peg$c230 = /^[pP]/, peg$c231 = { type: "class", value: "[pP]", description: "[pP]" }, peg$c232 = function(a2, b2) {
          return a2 + b2.join("");
        }, peg$c233 = /^[flFL]/, peg$c234 = { type: "class", value: "[flFL]", description: "[flFL]" }, peg$c235 = function(a2) {
          return addPositionInfo({ type: "EnumerationConstant", Identifier: a2 });
        }, peg$c236 = "L", peg$c237 = { type: "literal", value: "L", description: '"L"' }, peg$c238 = "'", peg$c239 = { type: "literal", value: "'", description: `"'"` }, peg$c240 = function(a2) {
          return addPositionInfo({ type: "CharacterConstant", Char: a2 });
        }, peg$c241 = /^['\n\\]/, peg$c242 = { type: "class", value: "['\\n\\\\]", description: "['\\n\\\\]" }, peg$c243 = "\\", peg$c244 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c245 = /^['"?\\abfnrtv]/, peg$c246 = { type: "class", value: `['\\"?\\\\abfnrtv]`, description: `['\\"?\\\\abfnrtv]` }, peg$c247 = function(a, b) {
          return eval('"' + a + b + '"');
        }, peg$c248 = function(a, b, c, d) {
          var ret = '"';
          ret += a;
          ret += b;
          if (c)
            ret += c;
          if (d)
            ret += d;
          ret += '"';
          return eval(ret);
        }, peg$c249 = "\\x", peg$c250 = { type: "literal", value: "\\x", description: '"\\\\x"' }, peg$c251 = function(a, b) {
          return eval('"' + a + b.join("") + '"');
        }, peg$c252 = "u8", peg$c253 = { type: "literal", value: "u8", description: '"u8"' }, peg$c254 = "u", peg$c255 = { type: "literal", value: "u", description: '"u"' }, peg$c256 = "U", peg$c257 = { type: "literal", value: "U", description: '"U"' }, peg$c258 = function(a2, b2) {
          return addPositionInfo({ type: "StringLiteral", prefix: a2, value: b2 });
        }, peg$c259 = "R", peg$c260 = { type: "literal", value: "R", description: '"R"' }, peg$c261 = /^["]/, peg$c262 = { type: "class", value: '["]', description: '["]' }, peg$c263 = function(a2) {
          return a2.join("");
        }, peg$c264 = /^["\n]/, peg$c265 = { type: "class", value: '[\\"\\n]', description: '[\\"\\n]' }, peg$c266 = /^["\n\\]/, peg$c267 = { type: "class", value: '[\\"\\n\\\\]', description: '[\\"\\n\\\\]' }, peg$c268 = "[", peg$c269 = { type: "literal", value: "[", description: '"["' }, peg$c270 = "]", peg$c271 = { type: "literal", value: "]", description: '"]"' }, peg$c272 = "(", peg$c273 = { type: "literal", value: "(", description: '"("' }, peg$c274 = ")", peg$c275 = { type: "literal", value: ")", description: '")"' }, peg$c276 = "{", peg$c277 = { type: "literal", value: "{", description: '"{"' }, peg$c278 = "}", peg$c279 = { type: "literal", value: "}", description: '"}"' }, peg$c280 = "->", peg$c281 = { type: "literal", value: "->", description: '"->"' }, peg$c282 = "++", peg$c283 = { type: "literal", value: "++", description: '"++"' }, peg$c284 = "--", peg$c285 = { type: "literal", value: "--", description: '"--"' }, peg$c286 = "&", peg$c287 = { type: "literal", value: "&", description: '"&"' }, peg$c288 = /^[&]/, peg$c289 = { type: "class", value: "[&]", description: "[&]" }, peg$c290 = "*", peg$c291 = { type: "literal", value: "*", description: '"*"' }, peg$c292 = /^[=]/, peg$c293 = { type: "class", value: "[=]", description: "[=]" }, peg$c294 = "+", peg$c295 = { type: "literal", value: "+", description: '"+"' }, peg$c296 = /^[+=]/, peg$c297 = { type: "class", value: "[+=]", description: "[+=]" }, peg$c298 = "-", peg$c299 = { type: "literal", value: "-", description: '"-"' }, peg$c300 = /^[\-=>]/, peg$c301 = { type: "class", value: "[\\-=>]", description: "[\\-=>]" }, peg$c302 = "~", peg$c303 = { type: "literal", value: "~", description: '"~"' }, peg$c304 = "!", peg$c305 = { type: "literal", value: "!", description: '"!"' }, peg$c306 = "/", peg$c307 = { type: "literal", value: "/", description: '"/"' }, peg$c308 = "%", peg$c309 = { type: "literal", value: "%", description: '"%"' }, peg$c310 = /^[=>]/, peg$c311 = { type: "class", value: "[=>]", description: "[=>]" }, peg$c312 = "<<", peg$c313 = { type: "literal", value: "<<", description: '"<<"' }, peg$c314 = ">>", peg$c315 = { type: "literal", value: ">>", description: '">>"' }, peg$c316 = "<", peg$c317 = { type: "literal", value: "<", description: '"<"' }, peg$c318 = ">", peg$c319 = { type: "literal", value: ">", description: '">"' }, peg$c320 = "<=", peg$c321 = { type: "literal", value: "<=", description: '"<="' }, peg$c322 = ">=", peg$c323 = { type: "literal", value: ">=", description: '">="' }, peg$c324 = "==", peg$c325 = { type: "literal", value: "==", description: '"=="' }, peg$c326 = "!=", peg$c327 = { type: "literal", value: "!=", description: '"!="' }, peg$c328 = "^", peg$c329 = { type: "literal", value: "^", description: '"^"' }, peg$c330 = "|", peg$c331 = { type: "literal", value: "|", description: '"|"' }, peg$c332 = "&&", peg$c333 = { type: "literal", value: "&&", description: '"&&"' }, peg$c334 = "||", peg$c335 = { type: "literal", value: "||", description: '"||"' }, peg$c336 = "?", peg$c337 = { type: "literal", value: "?", description: '"?"' }, peg$c338 = ":", peg$c339 = { type: "literal", value: ":", description: '":"' }, peg$c340 = /^[>]/, peg$c341 = { type: "class", value: "[>]", description: "[>]" }, peg$c342 = ";", peg$c343 = { type: "literal", value: ";", description: '";"' }, peg$c344 = "...", peg$c345 = { type: "literal", value: "...", description: '"..."' }, peg$c346 = "=", peg$c347 = { type: "literal", value: "=", description: '"="' }, peg$c348 = "*=", peg$c349 = { type: "literal", value: "*=", description: '"*="' }, peg$c350 = "/=", peg$c351 = { type: "literal", value: "/=", description: '"/="' }, peg$c352 = "%=", peg$c353 = { type: "literal", value: "%=", description: '"%="' }, peg$c354 = "+=", peg$c355 = { type: "literal", value: "+=", description: '"+="' }, peg$c356 = "-=", peg$c357 = { type: "literal", value: "-=", description: '"-="' }, peg$c358 = "<<=", peg$c359 = { type: "literal", value: "<<=", description: '"<<="' }, peg$c360 = ">>=", peg$c361 = { type: "literal", value: ">>=", description: '">>="' }, peg$c362 = "&=", peg$c363 = { type: "literal", value: "&=", description: '"&="' }, peg$c364 = "^=", peg$c365 = { type: "literal", value: "^=", description: '"^="' }, peg$c366 = "|=", peg$c367 = { type: "literal", value: "|=", description: '"|="' }, peg$c368 = ",", peg$c369 = { type: "literal", value: ",", description: '","' }, peg$c370 = "::", peg$c371 = { type: "literal", value: "::", description: '"::"' }, peg$c372 = { type: "any", description: "any character" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description) {
          throw peg$buildException(null, [{ type: "other", description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function error(message) {
          throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos], p, ch;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };
            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, found, location2) {
          function cleanupExpected(expected3) {
            var i2 = 1;
            expected3.sort(function(a2, b2) {
              if (a2.description < b2.description) {
                return -1;
              } else if (a2.description > b2.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i2 < expected3.length) {
              if (expected3[i2 - 1] === expected3[i2]) {
                expected3.splice(i2, 1);
              } else {
                i2++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s2) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0100-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1000-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i2;
            for (i2 = 0; i2 < expected3.length; i2++) {
              expectedDescs[i2] = expected3[i2].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new peg$SyntaxError(message !== null ? message : buildMessage(expected2, found), expected2, found, location2);
        }
        function peg$parseTranslationUnit() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseSpacing();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseExternalDeclaration();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseExternalDeclaration();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEOT();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExternalDeclaration() {
          var s0;
          s0 = peg$parseNamespace();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTypedefDeclaration();
            if (s0 === peg$FAILED) {
              s0 = peg$parseFunctionDefinition();
              if (s0 === peg$FAILED) {
                s0 = peg$parseDeclaration();
              }
            }
          }
          return s0;
        }
        function peg$parseNamespace() {
          var s0;
          s0 = peg$parseNamespaceDefinition();
          if (s0 === peg$FAILED) {
            s0 = peg$parseUsingDirective();
            if (s0 === peg$FAILED) {
              s0 = peg$parseUsingDeclaration();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNamespaceAliasDefinition();
              }
            }
          }
          return s0;
        }
        function peg$parseNamespaceDefinition() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseNAMESPACE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLWING();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseExternalDeclaration();
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseExternalDeclaration();
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseRWING();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c1(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUsingDirective() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseUSING();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNAMESPACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseScopedIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseSEMI();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c2(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUsingDeclaration() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseUSING();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseScopedIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSCOPEOP();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseIdentifier();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c3(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNamespaceAliasDefinition() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseNAMESPACE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEQU();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseScopedIdentifier();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c4(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypedefDeclaration() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = peg$parseTYPEDEF();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDeclarationSpecifiers();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$parseCOMMA();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDeclarator();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s6 = peg$c5(s7, s3);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = peg$parseCOMMA();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDeclarator();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c5(s7, s3);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s2, s3, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFunctionDefinition() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSTAR();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseFunctionDirectDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parseSEMI();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c7(s1, s2, s3);
                }
                s4 = s5;
                if (s4 === peg$FAILED) {
                  s4 = peg$parseCompoundStatement();
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c8(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarationList() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseDeclaration();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseDeclaration();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStatementORDeclaration() {
          var s0;
          s0 = peg$parseStatement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseDeclaration();
          }
          return s0;
        }
        function peg$parseStatement() {
          var s0;
          s0 = peg$parseLabel();
          if (s0 === peg$FAILED) {
            s0 = peg$parseCompoundStatement();
            if (s0 === peg$FAILED) {
              s0 = peg$parseExpressionStatement();
              if (s0 === peg$FAILED) {
                s0 = peg$parseSelectionStatement();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseIterationStatement();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseJumpStatement();
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseLabel() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseCASE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseConditionalExpression();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseCOLON();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c10(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDEFAULT();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseCOLON();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseCompoundStatement() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseLWING();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseStatement();
            if (s3 === peg$FAILED) {
              s3 = peg$parseDeclaration();
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseStatement();
              if (s3 === peg$FAILED) {
                s3 = peg$parseDeclaration();
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseRWING();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExpressionStatement() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseExpression();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSEMI();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSelectionStatement() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$parseIF();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseStatement();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$currPos;
                    s7 = peg$parseELSE();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseStatement();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 === peg$FAILED) {
                      s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c14(s3, s5, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSWITCH();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLPAR();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseExpression();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRPAR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseStatement();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c15(s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseIterationStatement() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$parseWHILE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseStatement();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c16(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDO();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseStatement();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseWHILE();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseLPAR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseExpression();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseRPAR();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseSEMI();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c17(s2, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseFOR();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLPAR();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseDeclaration();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseExpressionStatement();
                  }
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseExpression();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseSEMI();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseExpression();
                        if (s6 === peg$FAILED) {
                          s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseRPAR();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parseStatement();
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c18(s3, s4, s6, s8);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
          return s0;
        }
        function peg$parseJumpStatement() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseGOTO();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseCONTINUE();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseSEMI();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c20();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseBREAK();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseSEMI();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c21();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseRETURN();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseExpression();
                  if (s2 === peg$FAILED) {
                    s2 = null;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseSEMI();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c22(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          return s0;
        }
        function peg$parseDeclaration() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInitDeclaratorList();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c23(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarationSpecifiers() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parseStorageClassSpecifier();
          if (s3 === peg$FAILED) {
            s3 = peg$parseTypeQualifier();
            if (s3 === peg$FAILED) {
              s3 = peg$parseFunctionSpecifier();
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseStorageClassSpecifier();
            if (s3 === peg$FAILED) {
              s3 = peg$parseTypeQualifier();
              if (s3 === peg$FAILED) {
                s3 = peg$parseFunctionSpecifier();
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseIdentifier();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseStorageClassSpecifier();
              if (s5 === peg$FAILED) {
                s5 = peg$parseTypeQualifier();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseFunctionSpecifier();
                }
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseStorageClassSpecifier();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseTypeQualifier();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseFunctionSpecifier();
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c24(s2, s3, s4);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            s3 = peg$parseStorageClassSpecifier();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c26(s3);
            }
            s2 = s3;
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseTypeSpecifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c26(s3);
              }
              s2 = s3;
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseTypeQualifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c26(s3);
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseFunctionSpecifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c26(s3);
                  }
                  s2 = s3;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parseStorageClassSpecifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c26(s3);
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseTypeSpecifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c26(s3);
                  }
                  s2 = s3;
                  if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseTypeQualifier();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c26(s3);
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      s3 = peg$parseFunctionSpecifier();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c26(s3);
                      }
                      s2 = s3;
                    }
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseInitDeclaratorList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseInitDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInitDeclarator();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s1, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInitDeclarator();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c28(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInitDeclarator() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseEQU();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseInitializer();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c28(s1, s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c30(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStorageClassSpecifier() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$parseEXTERN();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSTATIC();
            if (s1 === peg$FAILED) {
              s1 = peg$parseAUTO();
              if (s1 === peg$FAILED) {
                s1 = peg$parseREGISTER();
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s2 = peg$parseATTRIBUTE();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseLPAR();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$currPos;
                        s7 = peg$currPos;
                        peg$silentFails++;
                        s8 = peg$parseRPAR();
                        peg$silentFails--;
                        if (s8 === peg$FAILED) {
                          s7 = void 0;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                        while (s6 !== peg$FAILED) {
                          s5.push(s6);
                          s6 = peg$currPos;
                          s7 = peg$currPos;
                          peg$silentFails++;
                          s8 = peg$parseRPAR();
                          peg$silentFails--;
                          if (s8 === peg$FAILED) {
                            s7 = void 0;
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parse_();
                            if (s8 !== peg$FAILED) {
                              s7 = [s7, s8];
                              s6 = s7;
                            } else {
                              peg$currPos = s6;
                              s6 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parseRPAR();
                            if (s7 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseTypeSpecifier() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseVOID();
          if (s1 === peg$FAILED) {
            s1 = peg$parseCHAR();
            if (s1 === peg$FAILED) {
              s1 = peg$parseSHORT();
              if (s1 === peg$FAILED) {
                s1 = peg$parseINT();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseLONG();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseFLOAT();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseDOUBLE();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseSIGNED();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parseUNSIGNED();
                          if (s1 === peg$FAILED) {
                            s1 = peg$parseBOOL();
                            if (s1 === peg$FAILED) {
                              s1 = peg$parseCOMPLEX();
                              if (s1 === peg$FAILED) {
                                s1 = peg$parseStructOrUnionSpecifier();
                                if (s1 === peg$FAILED) {
                                  s1 = peg$parseEnumSpecifier();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStructOrUnionSpecifier() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parseStructOrUnion();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseIdentifier();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseLWING();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseStructDeclaration();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseStructDeclaration();
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRWING();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c27(s3);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseIdentifier();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStructOrUnion() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseSTRUCT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseUNION();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStructDeclaration() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseSpecifierQualifierList();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseStructDeclaratorList();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSpecifierQualifierList() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseTypeQualifier();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseTypeQualifier();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseTypeQualifier();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseTypeQualifier();
              }
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = [];
            s1 = peg$parseTypeSpecifier();
            if (s1 === peg$FAILED) {
              s1 = peg$parseTypeQualifier();
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parseTypeSpecifier();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseTypeQualifier();
                }
              }
            } else {
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseStructDeclaratorList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseStructDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseStructDeclarator();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseStructDeclarator();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStructDeclarator() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseDeclarator();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseCOLON();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseConditionalExpression();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseDeclarator();
          }
          return s0;
        }
        function peg$parseEnumSpecifier() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = peg$parseENUM();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseIdentifier();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseLWING();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEnumeratorList();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseCOMMA();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRWING();
                    if (s7 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6, s7];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseIdentifier();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEnumeratorList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseEnumerator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEnumerator();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEnumerator();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEnumerator() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseEnumerationConstant();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseEQU();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseConditionalExpression();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypeQualifier() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseCONST();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseFunctionSpecifier() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseINLINE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSTDCALL();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseFunctionDirectDeclarator() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c32(s2);
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseLPAR();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseParameterTypeList();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRPAR();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c33(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarator() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsePointer();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDirectDeclarator();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDirectDeclarator() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c32(s2);
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseTypeQualifier();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseTypeQualifier();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseAssignmentExpression();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseRBRK();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c36(s5, s6);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSTATIC();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseTypeQualifier();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseTypeQualifier();
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseAssignmentExpression();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseRBRK();
                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c37(s6, s7);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLBRK();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseTypeQualifier();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseTypeQualifier();
                    }
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSTATIC();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseAssignmentExpression();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseRBRK();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c37(s5, s7);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseLBRK();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseTypeQualifier();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseTypeQualifier();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseSTAR();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseRBRK();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c38(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseLPAR();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseParameterTypeList();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseRPAR();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c33(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parseIdentifierList();
                        if (s5 === peg$FAILED) {
                          s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c39(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseTypeQualifier();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseTypeQualifier();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseAssignmentExpression();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRBRK();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c36(s5, s6);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLBRK();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSTATIC();
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parseTypeQualifier();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parseTypeQualifier();
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseAssignmentExpression();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseRBRK();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c37(s6, s7);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseLBRK();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseTypeQualifier();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseTypeQualifier();
                      }
                    } else {
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseSTATIC();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseAssignmentExpression();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseRBRK();
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c37(s5, s7);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseLBRK();
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseTypeQualifier();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseTypeQualifier();
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseSTAR();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseRBRK();
                          if (s7 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c38(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parseParameterTypeList();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c33(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseLPAR();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parseIdentifierList();
                          if (s5 === peg$FAILED) {
                            s5 = null;
                          }
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parseRPAR();
                            if (s6 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s4 = peg$c39(s5);
                              s3 = s4;
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePointer() {
          var s0, s1, s2, s3, s4;
          s0 = [];
          s1 = peg$currPos;
          s2 = peg$parseSTAR();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseTypeQualifier();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseTypeQualifier();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c26(s3);
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              s1 = peg$currPos;
              s2 = peg$parseSTAR();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseTypeQualifier();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseTypeQualifier();
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterTypeList() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseParameterList();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseCOMMA();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseELLIPSIS();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c40(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseParameterDeclaration();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseParameterDeclaration();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseParameterDeclaration();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c41(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterDeclaration() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInitDeclarator();
            if (s2 === peg$FAILED) {
              s2 = peg$parseAbstractDeclarator();
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c42(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifierList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseIdentifier();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s1, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseIdentifier();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c28(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypeName() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseSpecifierQualifierList();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAbstractDeclarator();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c43(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAbstractDeclarator() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsePointer();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDirectAbstractDeclarator();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePointer();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseDirectAbstractDeclarator() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseLPAR();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseAbstractDeclarator();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseRPAR();
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLBRK();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAssignmentExpression();
              if (s3 === peg$FAILED) {
                s3 = peg$parseSTAR();
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRBRK();
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = peg$parseLPAR();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseParameterTypeList();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRPAR();
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 === peg$FAILED) {
                s5 = peg$parseSTAR();
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRK();
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLPAR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseParameterTypeList();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRPAR();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseSTAR();
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRBRK();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseParameterTypeList();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRPAR();
                    if (s6 !== peg$FAILED) {
                      s4 = [s4, s5, s6];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInitializer() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c45(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLWING();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseInitializerList();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseCOMMA();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRWING();
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c46(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseInitializerList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseInitializer();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInitializer();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInitializer();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrimaryExpression() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseConstant();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c49(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseStringLiteral();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseLPAR();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseExpression();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseRPAR();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c51(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          return s0;
        }
        function peg$parsePostfixExpression() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parsePrimaryExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRK();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c52(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLPAR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseArgumentExpressionList();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRPAR();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c53(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseDOT();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseIdentifier();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c54(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parsePTR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseIdentifier();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c55(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseINC();
                    if (s4 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c56(s1, s4);
                    }
                    s3 = s4;
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseDEC();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c57(s1, s4);
                      }
                      s3 = s4;
                    }
                  }
                }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRBRK();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c52(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseArgumentExpressionList();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRPAR();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c53(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseDOT();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseIdentifier();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c54(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parsePTR();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseIdentifier();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c55(s1, s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseINC();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c56(s1, s4);
                      }
                      s3 = s4;
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseDEC();
                        if (s4 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c57(s1, s4);
                        }
                        s3 = s4;
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c58(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseArgumentExpressionList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUnaryExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$parsePostfixExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseINC();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseUnaryExpression();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c60(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseDEC();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseUnaryExpression();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseUnaryOperator();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseCastExpression();
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c62(s1, s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseSIZEOF();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseUnaryExpression();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c63(s3);
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      s3 = peg$parseLPAR();
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parseTypeName();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parseRPAR();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c64(s4);
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    }
                    if (s2 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c26(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUnaryOperator() {
          var s0;
          s0 = peg$parseAND();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSTAR();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePLUS();
              if (s0 === peg$FAILED) {
                s0 = peg$parseMINUS();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseTILDA();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseBANG();
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseCastExpression() {
          var s0, s1, s2, s3, s4;
          s0 = peg$parseUnaryExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseTypeName();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseCastExpression();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseMultiplicativeExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseCastExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseSTAR();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDIV();
              if (s4 === peg$FAILED) {
                s4 = peg$parseMOD();
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseCastExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseSTAR();
              if (s4 === peg$FAILED) {
                s4 = peg$parseDIV();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseMOD();
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseCastExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAdditiveExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseMultiplicativeExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsePLUS();
            if (s4 === peg$FAILED) {
              s4 = peg$parseMINUS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMultiplicativeExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parsePLUS();
              if (s4 === peg$FAILED) {
                s4 = peg$parseMINUS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseMultiplicativeExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseShiftExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseAdditiveExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLEFT();
            if (s4 === peg$FAILED) {
              s4 = peg$parseRIGHT();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAdditiveExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLEFT();
              if (s4 === peg$FAILED) {
                s4 = peg$parseRIGHT();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAdditiveExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRelationalExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseShiftExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLE();
            if (s4 === peg$FAILED) {
              s4 = peg$parseGE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseLT();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseGT();
                }
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseShiftExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseGE();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseLT();
                  if (s4 === peg$FAILED) {
                    s4 = peg$parseGT();
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseShiftExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEqualityExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseRelationalExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseEQUEQU();
            if (s4 === peg$FAILED) {
              s4 = peg$parseBANGEQU();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseRelationalExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseEQUEQU();
              if (s4 === peg$FAILED) {
                s4 = peg$parseBANGEQU();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRelationalExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseEqualityExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseAND();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEqualityExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseAND();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEqualityExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExclusiveORExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseANDExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseHAT();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseANDExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseHAT();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseANDExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInclusiveORExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseExclusiveORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseOR();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExclusiveORExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseOR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExclusiveORExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLogicalANDExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseInclusiveORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseANDAND();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInclusiveORExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseANDAND();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInclusiveORExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLogicalORExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseLogicalANDExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseOROR();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseLogicalANDExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseOROR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseLogicalANDExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseConditionalExpression() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = peg$parseLogicalORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseQUERY();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseCOLON();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseLogicalORExpression();
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseQUERY();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseCOLON();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseLogicalORExpression();
                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c67(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAssignmentExpression() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseUnaryExpression();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAssignmentOperator();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAssignmentExpression();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c68(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseConditionalExpression();
          }
          return s0;
        }
        function peg$parseAssignmentOperator() {
          var s0;
          s0 = peg$parseEQU();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSTAREQU();
            if (s0 === peg$FAILED) {
              s0 = peg$parseDIVEQU();
              if (s0 === peg$FAILED) {
                s0 = peg$parseMODEQU();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsePLUSEQU();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseMINUSEQU();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseLEFTEQU();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseRIGHTEQU();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseANDEQU();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseHATEQU();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseOREQU();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseExpression() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSpacing() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseWhiteSpace() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c70.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c71);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseLongComment() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c72) {
            s1 = peg$c72;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c73);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c74) {
              s5 = peg$c74;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c75);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c74) {
                s5 = peg$c74;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c74) {
                s3 = peg$c74;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLineComment() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c79;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c80);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c79;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c80);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c76(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAUTO() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBREAK() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCASE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCHAR() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c87) {
            s1 = peg$c87;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONST() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONTINUE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFAULT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c94);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDO() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENUM() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEXTERN() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFLOAT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c105) {
            s1 = peg$c105;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFOR() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c107) {
            s1 = peg$c107;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c108);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGOTO() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c109) {
            s1 = peg$c109;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c110);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c111) {
            s1 = peg$c111;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINLINE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLONG() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c117) {
            s1 = peg$c117;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c118);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseREGISTER() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c119) {
            s1 = peg$c119;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRESTRICT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRETURN() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c123) {
            s1 = peg$c123;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHORT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c125) {
            s1 = peg$c125;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIGNED() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c127) {
            s1 = peg$c127;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c128);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIZEOF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c129) {
            s1 = peg$c129;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c130);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTATIC() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c131) {
            s1 = peg$c131;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c132);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRUCT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c133) {
            s1 = peg$c133;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSWITCH() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c135) {
            s1 = peg$c135;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c136);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTYPEDEF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c137) {
            s1 = peg$c137;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c138);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNION() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c139) {
            s1 = peg$c139;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c140);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNSIGNED() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c141) {
            s1 = peg$c141;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c142);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOID() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c143) {
            s1 = peg$c143;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c144);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOLATILE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c145) {
            s1 = peg$c145;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c146);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseWHILE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c147) {
            s1 = peg$c147;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c148);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOOL() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c149) {
            s1 = peg$c149;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c150);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMPLEX() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c151) {
            s1 = peg$c151;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c152);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTDCALL() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c153) {
            s1 = peg$c153;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c154);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDECLSPEC() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c155) {
            s1 = peg$c155;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c156);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseATTRIBUTE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 13) === peg$c157) {
            s1 = peg$c157;
            peg$currPos += 13;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNAMESPACE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 9) === peg$c159) {
            s1 = peg$c159;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c160);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUSING() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c161) {
            s1 = peg$c161;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c162);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTRUE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c163) {
            s1 = peg$c163;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c164);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFALSE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c165) {
            s1 = peg$c165;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c166);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseKeyword() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c83) {
              s1 = peg$c83;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c85) {
                s1 = peg$c85;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c86);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c87) {
                  s1 = peg$c87;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c88);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c89) {
                    s1 = peg$c89;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c90);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c91) {
                      s1 = peg$c91;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c92);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c93) {
                        s1 = peg$c93;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c94);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c95) {
                          s1 = peg$c95;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c96);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c97) {
                            s1 = peg$c97;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c98);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c99) {
                              s1 = peg$c99;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c100);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c101) {
                                s1 = peg$c101;
                                peg$currPos += 4;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c102);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c103) {
                                  s1 = peg$c103;
                                  peg$currPos += 6;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c104);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c105) {
                                    s1 = peg$c105;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c106);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c107) {
                                      s1 = peg$c107;
                                      peg$currPos += 3;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c108);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c109) {
                                        s1 = peg$c109;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c110);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c111) {
                                          s1 = peg$c111;
                                          peg$currPos += 2;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c112);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 3) === peg$c113) {
                                            s1 = peg$c113;
                                            peg$currPos += 3;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c114);
                                            }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c115) {
                                              s1 = peg$c115;
                                              peg$currPos += 6;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c116);
                                              }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4) === peg$c117) {
                                                s1 = peg$c117;
                                                peg$currPos += 4;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c118);
                                                }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c119) {
                                                  s1 = peg$c119;
                                                  peg$currPos += 8;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c120);
                                                  }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 8) === peg$c121) {
                                                    s1 = peg$c121;
                                                    peg$currPos += 8;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c122);
                                                    }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c123) {
                                                      s1 = peg$c123;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c124);
                                                      }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c125) {
                                                        s1 = peg$c125;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c126);
                                                        }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c127) {
                                                          s1 = peg$c127;
                                                          peg$currPos += 6;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c128);
                                                          }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 6) === peg$c129) {
                                                            s1 = peg$c129;
                                                            peg$currPos += 6;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c130);
                                                            }
                                                          }
                                                          if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 6) === peg$c131) {
                                                              s1 = peg$c131;
                                                              peg$currPos += 6;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c132);
                                                              }
                                                            }
                                                            if (s1 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 6) === peg$c133) {
                                                                s1 = peg$c133;
                                                                peg$currPos += 6;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c134);
                                                                }
                                                              }
                                                              if (s1 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 6) === peg$c135) {
                                                                  s1 = peg$c135;
                                                                  peg$currPos += 6;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c136);
                                                                  }
                                                                }
                                                                if (s1 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 7) === peg$c137) {
                                                                    s1 = peg$c137;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                      peg$fail(peg$c138);
                                                                    }
                                                                  }
                                                                  if (s1 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 5) === peg$c139) {
                                                                      s1 = peg$c139;
                                                                      peg$currPos += 5;
                                                                    } else {
                                                                      s1 = peg$FAILED;
                                                                      if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c140);
                                                                      }
                                                                    }
                                                                    if (s1 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 8) === peg$c141) {
                                                                        s1 = peg$c141;
                                                                        peg$currPos += 8;
                                                                      } else {
                                                                        s1 = peg$FAILED;
                                                                        if (peg$silentFails === 0) {
                                                                          peg$fail(peg$c142);
                                                                        }
                                                                      }
                                                                      if (s1 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c143) {
                                                                          s1 = peg$c143;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s1 = peg$FAILED;
                                                                          if (peg$silentFails === 0) {
                                                                            peg$fail(peg$c144);
                                                                          }
                                                                        }
                                                                        if (s1 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 8) === peg$c145) {
                                                                            s1 = peg$c145;
                                                                            peg$currPos += 8;
                                                                          } else {
                                                                            s1 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                              peg$fail(peg$c146);
                                                                            }
                                                                          }
                                                                          if (s1 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 5) === peg$c147) {
                                                                              s1 = peg$c147;
                                                                              peg$currPos += 5;
                                                                            } else {
                                                                              s1 = peg$FAILED;
                                                                              if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c148);
                                                                              }
                                                                            }
                                                                            if (s1 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 5) === peg$c149) {
                                                                                s1 = peg$c149;
                                                                                peg$currPos += 5;
                                                                              } else {
                                                                                s1 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                  peg$fail(peg$c150);
                                                                                }
                                                                              }
                                                                              if (s1 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 8) === peg$c151) {
                                                                                  s1 = peg$c151;
                                                                                  peg$currPos += 8;
                                                                                } else {
                                                                                  s1 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$c152);
                                                                                  }
                                                                                }
                                                                                if (s1 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 10) === peg$c167) {
                                                                                    s1 = peg$c167;
                                                                                    peg$currPos += 10;
                                                                                  } else {
                                                                                    s1 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) {
                                                                                      peg$fail(peg$c168);
                                                                                    }
                                                                                  }
                                                                                  if (s1 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 8) === peg$c153) {
                                                                                      s1 = peg$c153;
                                                                                      peg$currPos += 8;
                                                                                    } else {
                                                                                      s1 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) {
                                                                                        peg$fail(peg$c154);
                                                                                      }
                                                                                    }
                                                                                    if (s1 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 10) === peg$c155) {
                                                                                        s1 = peg$c155;
                                                                                        peg$currPos += 10;
                                                                                      } else {
                                                                                        s1 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) {
                                                                                          peg$fail(peg$c156);
                                                                                        }
                                                                                      }
                                                                                      if (s1 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 13) === peg$c157) {
                                                                                          s1 = peg$c157;
                                                                                          peg$currPos += 13;
                                                                                        } else {
                                                                                          s1 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) {
                                                                                            peg$fail(peg$c158);
                                                                                          }
                                                                                        }
                                                                                        if (s1 === peg$FAILED) {
                                                                                          if (input.substr(peg$currPos, 9) === peg$c159) {
                                                                                            s1 = peg$c159;
                                                                                            peg$currPos += 9;
                                                                                          } else {
                                                                                            s1 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) {
                                                                                              peg$fail(peg$c160);
                                                                                            }
                                                                                          }
                                                                                          if (s1 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 5) === peg$c161) {
                                                                                              s1 = peg$c161;
                                                                                              peg$currPos += 5;
                                                                                            } else {
                                                                                              s1 = peg$FAILED;
                                                                                              if (peg$silentFails === 0) {
                                                                                                peg$fail(peg$c162);
                                                                                              }
                                                                                            }
                                                                                            if (s1 === peg$FAILED) {
                                                                                              if (input.substr(peg$currPos, 4) === peg$c163) {
                                                                                                s1 = peg$c163;
                                                                                                peg$currPos += 4;
                                                                                              } else {
                                                                                                s1 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) {
                                                                                                  peg$fail(peg$c164);
                                                                                                }
                                                                                              }
                                                                                              if (s1 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 5) === peg$c165) {
                                                                                                  s1 = peg$c165;
                                                                                                  peg$currPos += 5;
                                                                                                } else {
                                                                                                  s1 = peg$FAILED;
                                                                                                  if (peg$silentFails === 0) {
                                                                                                    peg$fail(peg$c166);
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseScopedIdentifier() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseSCOPEOP();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseIdentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSCOPEOP();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s4);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseIdentifier();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSCOPEOP();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s4);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c169(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifier() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseKeyword();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdNondigit();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIdChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIdChar();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseSpacing();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c170(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdNondigit() {
          var s0;
          if (peg$c171.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c173.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c175.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c176);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseUniversalCharacter();
              }
            }
          }
          return s0;
        }
        function peg$parseIdChar() {
          var s0;
          if (peg$c171.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c173.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s0 === peg$FAILED) {
                if (peg$c175.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c176);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseUniversalCharacter();
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUniversalCharacter() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c179) {
            s1 = peg$c179;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c180);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexQuad();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c181(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c182) {
              s1 = peg$c182;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c183);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseHexQuad();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseHexQuad();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c184(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexQuad() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseHexDigit();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHexDigit();
                if (s4 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseConstant() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseIntegerConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseEnumerationConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseCharacterConstant();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseBooleanConstant();
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseBooleanConstant() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseTRUE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseFALSE();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c185(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseIntegerConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseDecimalConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseOctalConstant();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIntegerSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (peg$c186.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c187);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c188(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c189;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c190);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c191.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c192);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c191.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c192);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c193(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c194(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c195) {
            s0 = peg$c195;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c196);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c197) {
              s0 = peg$c197;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c198);
              }
            }
          }
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c199.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c200);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c201.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c202);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseBinaryPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c203) {
            s0 = peg$c203;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c204);
            }
          }
          return s0;
        }
        function peg$parseBinaryDigit() {
          var s0;
          if (peg$c205.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c206);
            }
          }
          return s0;
        }
        function peg$parseBinaryConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseBinaryDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseBinaryDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c207(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIntegerSuffix() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (peg$c208.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c209);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLsuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLsuffix();
            if (s1 !== peg$FAILED) {
              if (peg$c208.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c209);
                }
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLsuffix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c210) {
            s0 = peg$c210;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c211);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c212) {
              s0 = peg$c212;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c213);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c214.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c215);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseFloatConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseDecimalFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseHexFloatConstant();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseFloatSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c216(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalFloatConstant() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseFraction();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExponent();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c217(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c177.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseExponent();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c218(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFloatConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexFraction();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseBinaryExponent();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c219(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseHexPrefix();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseHexDigit();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseBinaryExponent();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c220(s1, s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseFraction() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          if (peg$c177.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c178);
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c221;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c222);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c223(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c177.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c221;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c222);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFraction() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseHexDigit();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseHexDigit();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c221;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c222);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseHexDigit();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c223(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseHexDigit();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c221;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c222);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c224(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseExponent() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (peg$c225.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c226);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c227.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c228);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c229(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBinaryExponent() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (peg$c230.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c231);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c227.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c228);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c232(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFloatSuffix() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c233.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c234);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseEnumerationConstant() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c235(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseCharacterConstant() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c236;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c237);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c238;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c239);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseChar();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s4 = peg$c238;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c239);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c240(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseChar() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseEscape();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c241.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c242);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseEscape() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseSimpleEscape();
          if (s1 === peg$FAILED) {
            s1 = peg$parseOctalEscape();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexEscape();
              if (s1 === peg$FAILED) {
                s1 = peg$parseUniversalCharacter();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSimpleEscape() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c243;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c244);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c245.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c246);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c247(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalEscape() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c243;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c244);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c191.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c192);
              }
            }
            if (s2 !== peg$FAILED) {
              if (peg$c191.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c192);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                if (peg$c191.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c192);
                  }
                }
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c248(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexEscape() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c249) {
            s1 = peg$c249;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c250);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c251(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringLiteral() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c236;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c237);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c252) {
              s1 = peg$c252;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c253);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 117) {
                s1 = peg$c254;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c255);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 85) {
                  s1 = peg$c256;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c257);
                  }
                }
              }
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseRawStringLiteral();
            if (s2 === peg$FAILED) {
              s2 = peg$parseEscapedStringLiteral();
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c258(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRawStringLiteral() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 82) {
            s1 = peg$c259;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c260);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (peg$c261.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c262);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseRawStringChar();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseRawStringChar();
              }
              if (s5 !== peg$FAILED) {
                if (peg$c261.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c262);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseSpacing();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c76(s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (peg$c261.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c262);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseRawStringChar();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseRawStringChar();
                  }
                  if (s5 !== peg$FAILED) {
                    if (peg$c261.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c262);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseSpacing();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c76(s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c263(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEscapedStringLiteral() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          if (peg$c261.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c262);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseStringChar();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseStringChar();
            }
            if (s4 !== peg$FAILED) {
              if (peg$c261.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c262);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseSpacing();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c76(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              if (peg$c261.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c262);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseStringChar();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseStringChar();
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c261.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c262);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSpacing();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c76(s4);
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c263(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseRawStringChar() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (peg$c264.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c265);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringChar() {
          var s0, s1, s2;
          s0 = peg$parseEscape();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c266.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c267);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLBRK() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c268;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c269);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRBRK() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 93) {
            s1 = peg$c270;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c271);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLPAR() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c272;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c273);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRPAR() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 41) {
            s1 = peg$c274;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c275);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLWING() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c276;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c277);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRWING() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 125) {
            s1 = peg$c278;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c279);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOT() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c221;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c222);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePTR() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c280) {
            s1 = peg$c280;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c281);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINC() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c282) {
            s1 = peg$c282;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c283);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEC() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c284) {
            s1 = peg$c284;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c285);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAND() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c286;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c287);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c288.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c289);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTAR() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c290;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c291);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLUS() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c294;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c295);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c296.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c297);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMINUS() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c298;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c299);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c300.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c301);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTILDA() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c302;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c303);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBANG() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c304;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c305);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDIV() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c306;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c307);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMOD() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 37) {
            s1 = peg$c308;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c309);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c310.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c311);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLEFT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c312) {
            s1 = peg$c312;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c313);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRIGHT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c314) {
            s1 = peg$c314;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c315);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c316;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c317);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c318;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c319);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLE() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c320) {
            s1 = peg$c320;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c321);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGE() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c322) {
            s1 = peg$c322;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c323);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEQUEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c324) {
            s1 = peg$c324;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c325);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBANGEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c326) {
            s1 = peg$c326;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c327);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHAT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 94) {
            s1 = peg$c328;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c329);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOR() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 124) {
            s1 = peg$c330;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c331);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c292.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c293);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDAND() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c332) {
            s1 = peg$c332;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c333);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOROR() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c334) {
            s1 = peg$c334;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c335);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseQUERY() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 63) {
            s1 = peg$c336;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c337);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOLON() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c338;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c339);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c340.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c341);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSEMI() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s1 = peg$c342;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c343);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELLIPSIS() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c344) {
            s1 = peg$c344;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c345);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEQU() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c346;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c347);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c346;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c347);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTAREQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c348) {
            s1 = peg$c348;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c349);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDIVEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c350) {
            s1 = peg$c350;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c351);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMODEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c352) {
            s1 = peg$c352;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c353);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLUSEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c354) {
            s1 = peg$c354;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c355);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMINUSEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c356) {
            s1 = peg$c356;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c357);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLEFTEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c358) {
            s1 = peg$c358;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c359);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRIGHTEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c360) {
            s1 = peg$c360;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c361);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c362) {
            s1 = peg$c362;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c363);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHATEQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c364) {
            s1 = peg$c364;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c365);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOREQU() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c366) {
            s1 = peg$c366;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c367);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMMA() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c368;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c369);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSCOPEOP() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c370) {
            s1 = peg$c370;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c371);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOT() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          s1 = peg$parse_();
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_() {
          var s0;
          if (input.length > peg$currPos) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c372);
            }
          }
          return s0;
        }
        function buildRecursiveBinop(a2, b2) {
          var ret2 = a2;
          for (var i2 = 0; i2 < b2.length; i2++) {
            ret2 = addPositionInfo({ type: "BinOpExpression", left: ret2, op: b2[i2][0], right: b2[i2][1] });
          }
          return ret2;
        }
        ;
        function addPositionInfo(r) {
          var posDetails = peg$computePosDetails(peg$currPos);
          r.eLine = posDetails.line;
          r.eColumn = posDetails.column;
          r.eOffset = peg$currPos;
          posDetails = peg$computePosDetails(peg$savedPos);
          r.sLine = posDetails.line;
          r.sColumn = posDetails.column;
          r.sOffset = peg$savedPos;
          return r;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    }();
  }
});

// node_modules/JSCPP/lib/prepast.js
var require_prepast = __commonJS({
  "node_modules/JSCPP/lib/prepast.js"(exports, module) {
    module.exports = function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected2, found, location2) {
        this.message = message;
        this.expected = expected2;
        this.found = found;
        this.location = location2;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { TranslationUnit: peg$parseTranslationUnit }, peg$startRuleFunction = peg$parseTranslationUnit, peg$c0 = function(a2, b2) {
          return addPositionInfo({ type: "Code", val: a2, space: b2 });
        }, peg$c1 = function(a2) {
          return addPositionInfo({ type: "TranslationUnit", lines: a2 });
        }, peg$c2 = function(a2, b2) {
          a2.space = b2;
          return a2;
        }, peg$c3 = function(a2) {
          return addPositionInfo({ type: "PrepUndef", Identifier: a2 });
        }, peg$c4 = function(a2, b2) {
          return addPositionInfo({ type: "PrepSimpleMacro", Identifier: a2, Replacement: b2 });
        }, peg$c5 = function(a2, b2, c2) {
          return addPositionInfo({ type: "PrepFunctionMacro", Identifier: a2, Args: b2, Replacement: c2 });
        }, peg$c6 = function(a2) {
          return a2;
        }, peg$c7 = function(a2, b2) {
          return [a2].concat(b2);
        }, peg$c8 = function(a2, b2, c2) {
          return { type: "PrepFunctionMacroCall", Identifier: a2, Args: b2, space: c2 };
        }, peg$c9 = function(a2) {
          var ret2 = [];
          var lastString = null;
          for (var i2 = 0; i2 < a2.length; i2++) {
            if (a2[i2].type === "Seperator") {
              if (lastString === null) {
                lastString = a2[i2];
              } else {
                lastString.val += lastString.space + a2[i2].val;
                lastString.space = a2[i2].space;
              }
            } else {
              if (lastString !== null) {
                ret2.push(lastString);
                lastString = null;
              }
              ret2.push(a2[i2]);
            }
          }
          if (lastString !== null)
            ret2.push(lastString);
          return ret2;
        }, peg$c10 = function(a2) {
          return addPositionInfo({ type: "PrepIncludeLib", name: a2 });
        }, peg$c11 = function(a2) {
          return addPositionInfo({ type: "PrepIncludeLocal", name: a2 });
        }, peg$c12 = /^[\/\\.]/, peg$c13 = { type: "class", value: "[/\\\\.]", description: "[/\\\\.]" }, peg$c14 = function(a2) {
          return a2.join("");
        }, peg$c15 = function(a2) {
          return addPositionInfo({ type: "PrepIfdef", Identifier: a2 });
        }, peg$c16 = function(a2) {
          return addPositionInfo({ type: "PrepIfndef", Identifier: a2 });
        }, peg$c17 = function() {
          return addPositionInfo({ type: "PrepEndif" });
        }, peg$c18 = function() {
          return addPositionInfo({ type: "PrepElse" });
        }, peg$c19 = "#", peg$c20 = { type: "literal", value: "#", description: '"#"' }, peg$c21 = "define", peg$c22 = { type: "literal", value: "define", description: '"define"' }, peg$c23 = "undef", peg$c24 = { type: "literal", value: "undef", description: '"undef"' }, peg$c25 = "include", peg$c26 = { type: "literal", value: "include", description: '"include"' }, peg$c27 = "ifdef", peg$c28 = { type: "literal", value: "ifdef", description: '"ifdef"' }, peg$c29 = "ifndef", peg$c30 = { type: "literal", value: "ifndef", description: '"ifndef"' }, peg$c31 = "endif", peg$c32 = { type: "literal", value: "endif", description: '"endif"' }, peg$c33 = "else", peg$c34 = { type: "literal", value: "else", description: '"else"' }, peg$c35 = function(a2) {
          return a2.join("");
        }, peg$c36 = /^[ \t\x0B\f]/, peg$c37 = { type: "class", value: "[ \\t\\u000B\\u000C]", description: "[ \\t\\u000B\\u000C]" }, peg$c38 = /^[ \n\r\t\x0B\f]/, peg$c39 = { type: "class", value: "[ \\n\\r\\t\\u000B\\u000C]", description: "[ \\n\\r\\t\\u000B\\u000C]" }, peg$c40 = "/*", peg$c41 = { type: "literal", value: "/*", description: '"/*"' }, peg$c42 = "*/", peg$c43 = { type: "literal", value: "*/", description: '"*/"' }, peg$c44 = function(a2) {
          return "";
        }, peg$c45 = "//", peg$c46 = { type: "literal", value: "//", description: '"//"' }, peg$c47 = "\n", peg$c48 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c49 = "auto", peg$c50 = { type: "literal", value: "auto", description: '"auto"' }, peg$c51 = "break", peg$c52 = { type: "literal", value: "break", description: '"break"' }, peg$c53 = "case", peg$c54 = { type: "literal", value: "case", description: '"case"' }, peg$c55 = "char", peg$c56 = { type: "literal", value: "char", description: '"char"' }, peg$c57 = "const", peg$c58 = { type: "literal", value: "const", description: '"const"' }, peg$c59 = "continue", peg$c60 = { type: "literal", value: "continue", description: '"continue"' }, peg$c61 = "default", peg$c62 = { type: "literal", value: "default", description: '"default"' }, peg$c63 = "double", peg$c64 = { type: "literal", value: "double", description: '"double"' }, peg$c65 = "do", peg$c66 = { type: "literal", value: "do", description: '"do"' }, peg$c67 = "enum", peg$c68 = { type: "literal", value: "enum", description: '"enum"' }, peg$c69 = "extern", peg$c70 = { type: "literal", value: "extern", description: '"extern"' }, peg$c71 = "float", peg$c72 = { type: "literal", value: "float", description: '"float"' }, peg$c73 = "for", peg$c74 = { type: "literal", value: "for", description: '"for"' }, peg$c75 = "goto", peg$c76 = { type: "literal", value: "goto", description: '"goto"' }, peg$c77 = "if", peg$c78 = { type: "literal", value: "if", description: '"if"' }, peg$c79 = "int", peg$c80 = { type: "literal", value: "int", description: '"int"' }, peg$c81 = "inline", peg$c82 = { type: "literal", value: "inline", description: '"inline"' }, peg$c83 = "long", peg$c84 = { type: "literal", value: "long", description: '"long"' }, peg$c85 = "register", peg$c86 = { type: "literal", value: "register", description: '"register"' }, peg$c87 = "restrict", peg$c88 = { type: "literal", value: "restrict", description: '"restrict"' }, peg$c89 = "return", peg$c90 = { type: "literal", value: "return", description: '"return"' }, peg$c91 = "short", peg$c92 = { type: "literal", value: "short", description: '"short"' }, peg$c93 = "signed", peg$c94 = { type: "literal", value: "signed", description: '"signed"' }, peg$c95 = "sizeof", peg$c96 = { type: "literal", value: "sizeof", description: '"sizeof"' }, peg$c97 = "static", peg$c98 = { type: "literal", value: "static", description: '"static"' }, peg$c99 = "struct", peg$c100 = { type: "literal", value: "struct", description: '"struct"' }, peg$c101 = "switch", peg$c102 = { type: "literal", value: "switch", description: '"switch"' }, peg$c103 = "typedef", peg$c104 = { type: "literal", value: "typedef", description: '"typedef"' }, peg$c105 = "union", peg$c106 = { type: "literal", value: "union", description: '"union"' }, peg$c107 = "unsigned", peg$c108 = { type: "literal", value: "unsigned", description: '"unsigned"' }, peg$c109 = "void", peg$c110 = { type: "literal", value: "void", description: '"void"' }, peg$c111 = "volatile", peg$c112 = { type: "literal", value: "volatile", description: '"volatile"' }, peg$c113 = "while", peg$c114 = { type: "literal", value: "while", description: '"while"' }, peg$c115 = "_Bool", peg$c116 = { type: "literal", value: "_Bool", description: '"_Bool"' }, peg$c117 = "_Complex", peg$c118 = { type: "literal", value: "_Complex", description: '"_Complex"' }, peg$c119 = "_stdcall", peg$c120 = { type: "literal", value: "_stdcall", description: '"_stdcall"' }, peg$c121 = "__declspec", peg$c122 = { type: "literal", value: "__declspec", description: '"__declspec"' }, peg$c123 = "__attribute__", peg$c124 = { type: "literal", value: "__attribute__", description: '"__attribute__"' }, peg$c125 = "namespace", peg$c126 = { type: "literal", value: "namespace", description: '"namespace"' }, peg$c127 = "using", peg$c128 = { type: "literal", value: "using", description: '"using"' }, peg$c129 = "true", peg$c130 = { type: "literal", value: "true", description: '"true"' }, peg$c131 = "false", peg$c132 = { type: "literal", value: "false", description: '"false"' }, peg$c133 = "_Imaginary", peg$c134 = { type: "literal", value: "_Imaginary", description: '"_Imaginary"' }, peg$c135 = function(a2, b2, c2) {
          return { type: "Identifier", val: a2 + b2.join(""), space: c2 };
        }, peg$c136 = /^[\r\n,)]/, peg$c137 = { type: "class", value: "[\\r\\n,)]", description: "[\\r\\n,)]" }, peg$c138 = function(a2, b2) {
          return { type: "Seperator", val: a2, space: b2 };
        }, peg$c139 = /^[\r\n]/, peg$c140 = { type: "class", value: "[\\r\\n]", description: "[\\r\\n]" }, peg$c141 = function(a2, b2) {
          return { type: "Seperator", val: handleConstant(input, a2), space: b2 };
        }, peg$c142 = /^[a-z]/, peg$c143 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c144 = /^[A-Z]/, peg$c145 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c146 = /^[_]/, peg$c147 = { type: "class", value: "[_]", description: "[_]" }, peg$c148 = /^[0-9]/, peg$c149 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c150 = "\\u", peg$c151 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$c152 = function(a2) {
          return String.fromCharCode(a2);
        }, peg$c153 = "\\U", peg$c154 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c155 = function(a2) {
          return parseInt(a2.join(""), 16);
        }, peg$c156 = /^[a-f]/, peg$c157 = { type: "class", value: "[a-f]", description: "[a-f]" }, peg$c158 = /^[A-F]/, peg$c159 = { type: "class", value: "[A-F]", description: "[A-F]" }, peg$c160 = function(a2) {
          return a2;
        }, peg$c161 = function(a2, b2) {
          return a2;
        }, peg$c162 = /^[1-9]/, peg$c163 = { type: "class", value: "[1-9]", description: "[1-9]" }, peg$c164 = function(a2, b2) {
          return addPositionInfo({ type: "DecimalConstant", value: a2 + b2.join("") });
        }, peg$c165 = "0", peg$c166 = { type: "literal", value: "0", description: '"0"' }, peg$c167 = /^[0-7]/, peg$c168 = { type: "class", value: "[0-7]", description: "[0-7]" }, peg$c169 = function(a2) {
          if (a2.length > 0)
            return addPositionInfo({ type: "OctalConstant", value: a2.join("") });
          else
            return addPositionInfo({ type: "OctalConstant", value: "0" });
        }, peg$c170 = function(a2) {
          return addPositionInfo({ type: "HexConstant", value: a2.join("") });
        }, peg$c171 = "0x", peg$c172 = { type: "literal", value: "0x", description: '"0x"' }, peg$c173 = "0X", peg$c174 = { type: "literal", value: "0X", description: '"0X"' }, peg$c175 = "0b", peg$c176 = { type: "literal", value: "0b", description: '"0b"' }, peg$c177 = /^[0-1]/, peg$c178 = { type: "class", value: "[0-1]", description: "[0-1]" }, peg$c179 = function(a2) {
          return addPositionInfo({ type: "BinaryConstant", value: a2.join("") });
        }, peg$c180 = /^[uU]/, peg$c181 = { type: "class", value: "[uU]", description: "[uU]" }, peg$c182 = "ll", peg$c183 = { type: "literal", value: "ll", description: '"ll"' }, peg$c184 = "LL", peg$c185 = { type: "literal", value: "LL", description: '"LL"' }, peg$c186 = /^[lL]/, peg$c187 = { type: "class", value: "[lL]", description: "[lL]" }, peg$c188 = function(a2, b2) {
          if (b2)
            return addPositionInfo({ type: "FloatConstant", Expression: a2 });
          else
            return a2;
        }, peg$c189 = function(a2, b2) {
          return addPositionInfo({ type: "DecimalFloatConstant", value: a2 + b2 || "" });
        }, peg$c190 = function(a2, b2) {
          return addPositionInfo({ type: "DecimalFloatConstant", value: a2.join("") + b2 });
        }, peg$c191 = function(a2, b2, c2) {
          return addPositionInfo({ type: "HexFloatConstant", value: a2 + b2 + c2 || "" });
        }, peg$c192 = function(a2, b2, c2) {
          return addPositionInfo({ type: "HexFloatConstant", value: a2 + b2.join("") + c2 });
        }, peg$c193 = ".", peg$c194 = { type: "literal", value: ".", description: '"."' }, peg$c195 = function(a2, b2) {
          return a2.join("") + "." + b2.join("");
        }, peg$c196 = function(a2) {
          return a2.join("") + ".";
        }, peg$c197 = /^[eE]/, peg$c198 = { type: "class", value: "[eE]", description: "[eE]" }, peg$c199 = /^[+\-]/, peg$c200 = { type: "class", value: "[+\\-]", description: "[+\\-]" }, peg$c201 = function(a2, b2, c2) {
          return a2 + (b2 || "") + c2.join("");
        }, peg$c202 = /^[pP]/, peg$c203 = { type: "class", value: "[pP]", description: "[pP]" }, peg$c204 = function(a2, b2) {
          return a2 + b2.join("");
        }, peg$c205 = /^[flFL]/, peg$c206 = { type: "class", value: "[flFL]", description: "[flFL]" }, peg$c207 = function(a2) {
          return addPositionInfo({ type: "EnumerationConstant", Identifier: a2 });
        }, peg$c208 = "L", peg$c209 = { type: "literal", value: "L", description: '"L"' }, peg$c210 = "'", peg$c211 = { type: "literal", value: "'", description: `"'"` }, peg$c212 = function(a2) {
          return addPositionInfo({ type: "CharacterConstant", Char: a2 });
        }, peg$c213 = /^['\n\\]/, peg$c214 = { type: "class", value: "['\\n\\\\]", description: "['\\n\\\\]" }, peg$c215 = "\\", peg$c216 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c217 = /^['"?\\abfnrtv]/, peg$c218 = { type: "class", value: `['\\"?\\\\abfnrtv]`, description: `['\\"?\\\\abfnrtv]` }, peg$c219 = function(a, b) {
          return eval('"' + a + b + '"');
        }, peg$c220 = function(a, b, c, d) {
          var ret = '"';
          ret += a;
          ret += b;
          if (c)
            ret += c;
          if (d)
            ret += d;
          ret += '"';
          return eval(ret);
        }, peg$c221 = "\\x", peg$c222 = { type: "literal", value: "\\x", description: '"\\\\x"' }, peg$c223 = function(a, b) {
          return eval('"' + a + b.join("") + '"');
        }, peg$c224 = "u8", peg$c225 = { type: "literal", value: "u8", description: '"u8"' }, peg$c226 = "u", peg$c227 = { type: "literal", value: "u", description: '"u"' }, peg$c228 = "U", peg$c229 = { type: "literal", value: "U", description: '"U"' }, peg$c230 = function(a2, b2) {
          return addPositionInfo({ type: "StringLiteral", prefix: a2, value: b2 });
        }, peg$c231 = "R", peg$c232 = { type: "literal", value: "R", description: '"R"' }, peg$c233 = /^["]/, peg$c234 = { type: "class", value: '["]', description: '["]' }, peg$c235 = function(a2) {
          return a2.join("");
        }, peg$c236 = /^["\n]/, peg$c237 = { type: "class", value: '[\\"\\n]', description: '[\\"\\n]' }, peg$c238 = /^["\n\\]/, peg$c239 = { type: "class", value: '[\\"\\n\\\\]', description: '[\\"\\n\\\\]' }, peg$c240 = "(", peg$c241 = { type: "literal", value: "(", description: '"("' }, peg$c242 = ")", peg$c243 = { type: "literal", value: ")", description: '")"' }, peg$c244 = ",", peg$c245 = { type: "literal", value: ",", description: '","' }, peg$c246 = "<", peg$c247 = { type: "literal", value: "<", description: '"<"' }, peg$c248 = /^[=]/, peg$c249 = { type: "class", value: "[=]", description: "[=]" }, peg$c250 = ">", peg$c251 = { type: "literal", value: ">", description: '">"' }, peg$c252 = '"', peg$c253 = { type: "literal", value: '"', description: '"\\""' }, peg$c254 = { type: "any", description: "any character" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description) {
          throw peg$buildException(null, [{ type: "other", description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function error(message) {
          throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos], p, ch;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };
            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildException(message, expected2, found, location2) {
          function cleanupExpected(expected3) {
            var i2 = 1;
            expected3.sort(function(a2, b2) {
              if (a2.description < b2.description) {
                return -1;
              } else if (a2.description > b2.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i2 < expected3.length) {
              if (expected3[i2 - 1] === expected3[i2]) {
                expected3.splice(i2, 1);
              } else {
                i2++;
              }
            }
          }
          function buildMessage(expected3, found2) {
            function stringEscape(s2) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return "\\x" + hex(ch);
              }).replace(/[\u0100-\u0FFF]/g, function(ch) {
                return "\\u0" + hex(ch);
              }).replace(/[\u1000-\uFFFF]/g, function(ch) {
                return "\\u" + hex(ch);
              });
            }
            var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i2;
            for (i2 = 0; i2 < expected3.length; i2++) {
              expectedDescs[i2] = expected3[i2].description;
            }
            expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
            foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          if (expected2 !== null) {
            cleanupExpected(expected2);
          }
          return new peg$SyntaxError(message !== null ? message : buildMessage(expected2, found), expected2, found, location2);
        }
        function peg$parseTranslationUnit() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseSpacing();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsePreprocessor();
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parsePrepMacroText();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSpacing();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c0(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsePreprocessor();
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parsePrepMacroText();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseSpacing();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c0(s4, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEOT();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePreprocessor() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsePrepDefine();
          if (s1 === peg$FAILED) {
            s1 = peg$parsePrepInclude();
            if (s1 === peg$FAILED) {
              s1 = peg$parseConditionalInclusion();
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c2(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepDefine() {
          var s0;
          s0 = peg$parsePrepFunctionMacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepSimpleMacro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePrepUndef();
            }
          }
          return s0;
        }
        function peg$parsePrepUndef() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseUNDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c3(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepSimpleMacro() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDEFINE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepMacroText();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c4(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacro() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDEFINE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsePrepMacroText();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c5(s3, s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacroArgs() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parseLPAR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseCOMMA();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseIdentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c6(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseCOMMA();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseIdentifier();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c6(s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacroCallArgs() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parseLPAR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsePrepMacroMacroCallText();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseCOMMA();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsePrepMacroMacroCallText();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c6(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseCOMMA();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsePrepMacroMacroCallText();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c6(s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepMacroMacroCallText() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePrepFunctionMacroCallArgs();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInlineSpacing();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3, s4, s5);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSeperatorArgs();
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroCallArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseInlineSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c8(s3, s4, s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSeperatorArgs();
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsePrepMacroText() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePrepFunctionMacroCallArgs();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInlineSpacing();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3, s4, s5);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSeperator();
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroCallArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseInlineSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c8(s3, s4, s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSeperator();
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsePrepInclude() {
          var s0;
          s0 = peg$parsePrepIncludeLib();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepIncludeLocal();
          }
          return s0;
        }
        function peg$parsePrepIncludeLib() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseINCLUDE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLT();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseFilename();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseGT();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepIncludeLocal() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseINCLUDE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseQUO();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseFilename();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseQUO();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFilename() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIdChar();
          if (s2 === peg$FAILED) {
            if (peg$c12.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c13);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIdChar();
              if (s2 === peg$FAILED) {
                if (peg$c12.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseConditionalInclusion() {
          var s0;
          s0 = peg$parsePrepIfdef();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepIfndef();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePrepEndif();
              if (s0 === peg$FAILED) {
                s0 = peg$parsePrepElse();
              }
            }
          }
          return s0;
        }
        function peg$parsePrepIfdef() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIFDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c15(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepIfndef() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIFNDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepEndif() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseENDIF();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepElse() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseELSE();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c18();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHARP() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c19;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFINE() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c21) {
            s1 = peg$c21;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c22);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNDEF() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINCLUDE() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c25) {
            s1 = peg$c25;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIFDEF() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c27) {
            s1 = peg$c27;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIFNDEF() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENDIF() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c31) {
            s1 = peg$c31;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInlineSpacing() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseInlineWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseInlineWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSpacing() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseInlineWhiteSpace() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseWhiteSpace() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseLongComment() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c40) {
            s1 = peg$c40;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c41);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c42) {
              s5 = peg$c42;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c42) {
                s5 = peg$c42;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c42) {
                s3 = peg$c42;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c44(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLineComment() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c45) {
            s1 = peg$c45;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c47;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c47;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAUTO() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c49) {
            s1 = peg$c49;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBREAK() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCASE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c53) {
            s1 = peg$c53;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c54);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCHAR() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c55) {
            s1 = peg$c55;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c56);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONST() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c57) {
            s1 = peg$c57;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONTINUE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c59) {
            s1 = peg$c59;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c60);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFAULT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c62);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c63) {
            s1 = peg$c63;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c64);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDO() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c65) {
            s1 = peg$c65;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENUM() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c67) {
            s1 = peg$c67;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c68);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEXTERN() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c69) {
            s1 = peg$c69;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c70);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFLOAT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c71) {
            s1 = peg$c71;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFOR() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGOTO() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c75) {
            s1 = peg$c75;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c79) {
            s1 = peg$c79;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c80);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINLINE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLONG() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseREGISTER() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRESTRICT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c87) {
            s1 = peg$c87;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRETURN() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHORT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIGNED() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c94);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIZEOF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTATIC() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRUCT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSWITCH() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTYPEDEF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNION() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c105) {
            s1 = peg$c105;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNSIGNED() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c107) {
            s1 = peg$c107;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c108);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOID() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c109) {
            s1 = peg$c109;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c110);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOLATILE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c111) {
            s1 = peg$c111;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseWHILE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOOL() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMPLEX() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c117) {
            s1 = peg$c117;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c118);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTDCALL() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c119) {
            s1 = peg$c119;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDECLSPEC() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseATTRIBUTE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 13) === peg$c123) {
            s1 = peg$c123;
            peg$currPos += 13;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNAMESPACE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 9) === peg$c125) {
            s1 = peg$c125;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUSING() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c127) {
            s1 = peg$c127;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c128);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTRUE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c129) {
            s1 = peg$c129;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c130);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFALSE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c131) {
            s1 = peg$c131;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c132);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseKeyword() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c49) {
            s1 = peg$c49;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c53) {
                s1 = peg$c53;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c54);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c55) {
                  s1 = peg$c55;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c56);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c57) {
                    s1 = peg$c57;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c58);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c59) {
                      s1 = peg$c59;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c60);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c61) {
                        s1 = peg$c61;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c62);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c63) {
                          s1 = peg$c63;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c64);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c65) {
                            s1 = peg$c65;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c66);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c33) {
                              s1 = peg$c33;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c34);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c67) {
                                s1 = peg$c67;
                                peg$currPos += 4;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c68);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c69) {
                                  s1 = peg$c69;
                                  peg$currPos += 6;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c70);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c71) {
                                    s1 = peg$c71;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c72);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c73) {
                                      s1 = peg$c73;
                                      peg$currPos += 3;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c74);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c75) {
                                        s1 = peg$c75;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c76);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c77) {
                                          s1 = peg$c77;
                                          peg$currPos += 2;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c78);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 3) === peg$c79) {
                                            s1 = peg$c79;
                                            peg$currPos += 3;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c80);
                                            }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c81) {
                                              s1 = peg$c81;
                                              peg$currPos += 6;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c82);
                                              }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4) === peg$c83) {
                                                s1 = peg$c83;
                                                peg$currPos += 4;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c84);
                                                }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c85) {
                                                  s1 = peg$c85;
                                                  peg$currPos += 8;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c86);
                                                  }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 8) === peg$c87) {
                                                    s1 = peg$c87;
                                                    peg$currPos += 8;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c88);
                                                    }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c89) {
                                                      s1 = peg$c89;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c90);
                                                      }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c91) {
                                                        s1 = peg$c91;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c92);
                                                        }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c93) {
                                                          s1 = peg$c93;
                                                          peg$currPos += 6;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c94);
                                                          }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 6) === peg$c95) {
                                                            s1 = peg$c95;
                                                            peg$currPos += 6;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c96);
                                                            }
                                                          }
                                                          if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 6) === peg$c97) {
                                                              s1 = peg$c97;
                                                              peg$currPos += 6;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c98);
                                                              }
                                                            }
                                                            if (s1 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 6) === peg$c99) {
                                                                s1 = peg$c99;
                                                                peg$currPos += 6;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c100);
                                                                }
                                                              }
                                                              if (s1 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 6) === peg$c101) {
                                                                  s1 = peg$c101;
                                                                  peg$currPos += 6;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c102);
                                                                  }
                                                                }
                                                                if (s1 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 7) === peg$c103) {
                                                                    s1 = peg$c103;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                      peg$fail(peg$c104);
                                                                    }
                                                                  }
                                                                  if (s1 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 5) === peg$c105) {
                                                                      s1 = peg$c105;
                                                                      peg$currPos += 5;
                                                                    } else {
                                                                      s1 = peg$FAILED;
                                                                      if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c106);
                                                                      }
                                                                    }
                                                                    if (s1 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 8) === peg$c107) {
                                                                        s1 = peg$c107;
                                                                        peg$currPos += 8;
                                                                      } else {
                                                                        s1 = peg$FAILED;
                                                                        if (peg$silentFails === 0) {
                                                                          peg$fail(peg$c108);
                                                                        }
                                                                      }
                                                                      if (s1 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c109) {
                                                                          s1 = peg$c109;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s1 = peg$FAILED;
                                                                          if (peg$silentFails === 0) {
                                                                            peg$fail(peg$c110);
                                                                          }
                                                                        }
                                                                        if (s1 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 8) === peg$c111) {
                                                                            s1 = peg$c111;
                                                                            peg$currPos += 8;
                                                                          } else {
                                                                            s1 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                              peg$fail(peg$c112);
                                                                            }
                                                                          }
                                                                          if (s1 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 5) === peg$c113) {
                                                                              s1 = peg$c113;
                                                                              peg$currPos += 5;
                                                                            } else {
                                                                              s1 = peg$FAILED;
                                                                              if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c114);
                                                                              }
                                                                            }
                                                                            if (s1 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 5) === peg$c115) {
                                                                                s1 = peg$c115;
                                                                                peg$currPos += 5;
                                                                              } else {
                                                                                s1 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                  peg$fail(peg$c116);
                                                                                }
                                                                              }
                                                                              if (s1 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 8) === peg$c117) {
                                                                                  s1 = peg$c117;
                                                                                  peg$currPos += 8;
                                                                                } else {
                                                                                  s1 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$c118);
                                                                                  }
                                                                                }
                                                                                if (s1 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 10) === peg$c133) {
                                                                                    s1 = peg$c133;
                                                                                    peg$currPos += 10;
                                                                                  } else {
                                                                                    s1 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) {
                                                                                      peg$fail(peg$c134);
                                                                                    }
                                                                                  }
                                                                                  if (s1 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 8) === peg$c119) {
                                                                                      s1 = peg$c119;
                                                                                      peg$currPos += 8;
                                                                                    } else {
                                                                                      s1 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) {
                                                                                        peg$fail(peg$c120);
                                                                                      }
                                                                                    }
                                                                                    if (s1 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 10) === peg$c121) {
                                                                                        s1 = peg$c121;
                                                                                        peg$currPos += 10;
                                                                                      } else {
                                                                                        s1 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) {
                                                                                          peg$fail(peg$c122);
                                                                                        }
                                                                                      }
                                                                                      if (s1 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 13) === peg$c123) {
                                                                                          s1 = peg$c123;
                                                                                          peg$currPos += 13;
                                                                                        } else {
                                                                                          s1 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) {
                                                                                            peg$fail(peg$c124);
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifier() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseKeyword();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdNondigit();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIdChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIdChar();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseInlineSpacing();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c135(s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSeperatorArgs() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseKeyword();
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdNondigit();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (peg$c136.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c137);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c6(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c138(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSeperator() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$parseKeyword();
          if (s1 === peg$FAILED) {
            s1 = peg$parseConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseStringLiteral();
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = peg$currPos;
                peg$silentFails++;
                s3 = peg$parseIdNondigit();
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                  s2 = void 0;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$currPos;
                  peg$silentFails++;
                  if (peg$c139.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c140);
                    }
                  }
                  peg$silentFails--;
                  if (s4 === peg$FAILED) {
                    s3 = void 0;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                      peg$savedPos = s1;
                      s2 = peg$c6(s4);
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c141(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdNondigit() {
          var s0;
          if (peg$c142.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c143);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c144.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c145);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c146.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c147);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseUniversalCharacter();
              }
            }
          }
          return s0;
        }
        function peg$parseIdChar() {
          var s0;
          if (peg$c142.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c143);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c144.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c145);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
              if (s0 === peg$FAILED) {
                if (peg$c146.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c147);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseUniversalCharacter();
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUniversalCharacter() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c150) {
            s1 = peg$c150;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c151);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexQuad();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c152(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c153) {
              s1 = peg$c153;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c154);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseHexOcto();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c152(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexOcto() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseHexDigit();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHexDigit();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHexDigit();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHexDigit();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHexDigit();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHexDigit();
                        if (s9 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c155(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseHexQuad() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseHexDigit();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHexDigit();
                if (s5 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c155(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c156.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c157);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c158.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c159);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseConstant() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseIntegerConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseEnumerationConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseCharacterConstant();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseBooleanConstant();
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseBooleanConstant() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseTRUE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseFALSE();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c160(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseIntegerConstant() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseBinaryConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseDecimalConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseOctalConstant();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIntegerSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c161(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (peg$c162.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c163);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c148.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c149);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c164(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c165;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c166);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c167.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c168);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c167.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c168);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c169(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c170(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c171) {
            s0 = peg$c171;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c173) {
              s0 = peg$c173;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
          }
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c156.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c157);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c158.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c159);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseBinaryPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c175) {
            s0 = peg$c175;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c176);
            }
          }
          return s0;
        }
        function peg$parseBinaryDigit() {
          var s0;
          if (peg$c177.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c178);
            }
          }
          return s0;
        }
        function peg$parseBinaryConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseBinaryDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseBinaryDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c179(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIntegerSuffix() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (peg$c180.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c181);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLsuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLsuffix();
            if (s1 !== peg$FAILED) {
              if (peg$c180.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c181);
                }
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLsuffix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c182) {
            s0 = peg$c182;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c183);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c184) {
              s0 = peg$c184;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c185);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c186.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c187);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseFloatConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseDecimalFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseHexFloatConstant();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseFloatSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c188(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalFloatConstant() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseFraction();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExponent();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c189(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c148.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c149);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c148.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c149);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseExponent();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c190(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFloatConstant() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexFraction();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseBinaryExponent();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c191(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseHexPrefix();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseHexDigit();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseBinaryExponent();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c192(s1, s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseFraction() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          if (peg$c148.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c149);
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c148.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c149);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c193;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c194);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c148.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c149);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c195(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c148.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c149);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c148.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c149);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c193;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c194);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c14(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFraction() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseHexDigit();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseHexDigit();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c193;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c194);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseHexDigit();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c195(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseHexDigit();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c193;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c194);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c196(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseExponent() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (peg$c197.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c198);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c199.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c200);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c148.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c149);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c201(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBinaryExponent() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (peg$c202.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c203);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c199.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c200);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c148.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c149);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c148.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c149);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c204(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFloatSuffix() {
          var s0, s1;
          s0 = peg$currPos;
          if (peg$c205.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c206);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseEnumerationConstant() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c207(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseCharacterConstant() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c208;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c209);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c210;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c211);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseChar();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s4 = peg$c210;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c211);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c212(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseChar() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parseEscape();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c213.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c214);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseEscape() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parseSimpleEscape();
          if (s1 === peg$FAILED) {
            s1 = peg$parseOctalEscape();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexEscape();
              if (s1 === peg$FAILED) {
                s1 = peg$parseUniversalCharacter();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSimpleEscape() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c215;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c216);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c217.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c218);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c219(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalEscape() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c215;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c216);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c167.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c168);
              }
            }
            if (s2 !== peg$FAILED) {
              if (peg$c167.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c168);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                if (peg$c167.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c168);
                  }
                }
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c220(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexEscape() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c221) {
            s1 = peg$c221;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c222);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c223(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringLiteral() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c208;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c209);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c224) {
              s1 = peg$c224;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c225);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 117) {
                s1 = peg$c226;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c227);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 85) {
                  s1 = peg$c228;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c229);
                  }
                }
              }
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseRawStringLiteral();
            if (s2 === peg$FAILED) {
              s2 = peg$parseEscapedStringLiteral();
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c230(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRawStringLiteral() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 82) {
            s1 = peg$c231;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c232);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (peg$c233.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c234);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseRawStringChar();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseRawStringChar();
              }
              if (s5 !== peg$FAILED) {
                if (peg$c233.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c234);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseSpacing();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c14(s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (peg$c233.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c234);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseRawStringChar();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseRawStringChar();
                  }
                  if (s5 !== peg$FAILED) {
                    if (peg$c233.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c234);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseSpacing();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c14(s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c235(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEscapedStringLiteral() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          if (peg$c233.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c234);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseStringChar();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseStringChar();
            }
            if (s4 !== peg$FAILED) {
              if (peg$c233.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c234);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseSpacing();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c14(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              if (peg$c233.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c234);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseStringChar();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseStringChar();
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c233.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c234);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSpacing();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c14(s4);
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c235(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseRawStringChar() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (peg$c236.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c237);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringChar() {
          var s0, s1, s2;
          s0 = peg$parseEscape();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c238.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c239);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLPAR() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c240;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c241);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRPAR() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 41) {
            s1 = peg$c242;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c243);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMMA() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c244;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c245);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c246;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c247);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c248.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c249);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseInlineSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c250;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c251);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c248.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c249);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseInlineSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseQUO() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c252;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c253);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOT() {
          var s0, s1;
          s0 = peg$currPos;
          peg$silentFails++;
          s1 = peg$parse_();
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_() {
          var s0;
          if (input.length > peg$currPos) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c254);
            }
          }
          return s0;
        }
        function addPositionInfo(r) {
          var posDetails = peg$computePosDetails(peg$currPos);
          r.eLine = posDetails.line;
          r.eColumn = posDetails.column;
          r.eOffset = peg$currPos;
          posDetails = peg$computePosDetails(peg$savedPos);
          r.sLine = posDetails.line;
          r.sColumn = posDetails.column;
          r.sOffset = peg$savedPos;
          return r;
        }
        function handleConstant(input2, r) {
          if (r.eOffset == null) {
            return r;
          }
          return input2.substring(r.sOffset, r.eOffset);
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({ type: "end", description: "end of input" });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    }();
  }
});

// node_modules/pegjs-util/PEGUtil.js
var require_PEGUtil = __commonJS({
  "node_modules/pegjs-util/PEGUtil.js"(exports2, module2) {
    (function(root, name, factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object")
        module2.exports = factory(root);
      else if (typeof define === "function" && typeof define.amd !== "undefined")
        define(name, function() {
          return factory(root);
        });
      else
        root[name] = factory(root);
    })(typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : exports2, "PEGUtil", function() {
      var PEGUtil = {};
      PEGUtil.makeAST = function makeAST(location2, options2) {
        return function() {
          return options2.util.__makeAST.call(null, location2().start.line, location2().start.column, location2().start.offset, arguments);
        };
      };
      PEGUtil.makeUnroll = function(location2, options2) {
        return function(first, list, take) {
          if (typeof list !== "object" || !(list instanceof Array))
            throw new options2.util.__SyntaxError("unroll: invalid list argument for unrolling", typeof list, "Array", location2());
          if (typeof take !== "undefined") {
            if (typeof take === "number")
              take = [take];
            var result = [];
            if (first !== null)
              result.push(first);
            for (var i2 = 0; i2 < list.length; i2++) {
              for (var j = 0; j < take.length; j++)
                result.push(list[i2][take[j]]);
            }
            return result;
          } else {
            if (first !== null)
              list.unshift(first);
            return list;
          }
        };
      };
      var excerpt = function(txt, o) {
        var l = txt.length;
        var b2 = o - 20;
        if (b2 < 0)
          b2 = 0;
        var e = o + 20;
        if (e > l)
          e = l;
        var hex = function(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        };
        var extract = function(txt2, pos, len) {
          return txt2.substr(pos, len).replace(/\\/g, "\\\\").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
          }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
            return "\\x" + hex(ch);
          }).replace(/[\u0100-\u0FFF]/g, function(ch) {
            return "\\u0" + hex(ch);
          }).replace(/[\u1000-\uFFFF]/g, function(ch) {
            return "\\u" + hex(ch);
          });
        };
        return {
          prolog: extract(txt, b2, o - b2),
          token: extract(txt, o, 1),
          epilog: extract(txt, o + 1, e - (o + 1))
        };
      };
      PEGUtil.parse = function(parser2, txt, options2) {
        if (typeof parser2 !== "object")
          throw new Error("invalid parser object (not an object)");
        if (typeof parser2.parse !== "function")
          throw new Error('invalid parser object (no "parse" function)');
        if (typeof txt !== "string")
          throw new Error("invalid input text (not a string)");
        if (typeof options2 !== "undefined" && typeof options2 !== "object")
          throw new Error("invalid options (not an object)");
        if (typeof options2 === "undefined")
          options2 = {};
        var result = { ast: null, error: null };
        try {
          var makeAST;
          if (typeof options2.makeAST === "function")
            makeAST = options2.makeAST;
          else {
            makeAST = function(location2, args) {
              return {
                line: location2().start.line,
                column: location2().start.column,
                offset: location2().start.offset,
                args
              };
            };
          }
          options2.util = {
            makeUnroll: PEGUtil.makeUnroll,
            makeAST: PEGUtil.makeAST,
            __makeAST: makeAST,
            __SyntaxError: parser2.SyntaxError
          };
          result.ast = parser2.parse(txt, options2);
          result.error = null;
        } catch (e) {
          result.ast = null;
          if (e instanceof parser2.SyntaxError) {
            var definedOrElse = function(value, fallback) {
              return typeof value !== "undefined" ? value : fallback;
            };
            result.error = {
              line: definedOrElse(e.location.start.line, 0),
              column: definedOrElse(e.location.start.column, 0),
              message: e.message,
              found: definedOrElse(e.found, ""),
              expected: definedOrElse(e.expected, ""),
              location: excerpt(txt, definedOrElse(e.location.start.offset, 0))
            };
          } else {
            result.error = {
              line: 0,
              column: 0,
              message: e.message,
              found: "",
              expected: "",
              location: excerpt("", 0)
            };
          }
        }
        return result;
      };
      PEGUtil.errorMessage = function(e, noFinalNewline) {
        var l = e.location;
        var prefix1 = "line " + e.line + " (column " + e.column + "): ";
        var prefix2 = "";
        for (var i2 = 0; i2 < prefix1.length + l.prolog.length; i2++)
          prefix2 += "-";
        var msg = prefix1 + l.prolog + l.token + l.epilog + "\n" + prefix2 + "^\n" + e.message + (noFinalNewline ? "" : "\n");
        return msg;
      };
      return PEGUtil;
    });
  }
});

// node_modules/JSCPP/lib/preprocessor.js
var require_preprocessor = __commonJS({
  "node_modules/JSCPP/lib/preprocessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = void 0;
    var prepast = require_prepast();
    var PEGUtil = require_PEGUtil();
    var interpreter_1 = require_interpreter();
    var Preprocessor = class extends interpreter_1.BaseInterpreter {
      constructor(rt2) {
        super(rt2);
        const pushInc = function(b2) {
          this.doinclude.push(this.doinclude[this.doinclude.length - 1] && b2);
        };
        this.rt = rt2;
        this.ret = "";
        this.macros = {};
        this.macroStack = [];
        this.doinclude = [true];
        this.visitors = {
          TranslationUnit(interp, s2, code) {
            let i2 = 0;
            while (i2 < s2.lines.length) {
              const dec = s2.lines[i2];
              interp.visit(dec, code);
              interp.ret += dec.space;
              i2++;
            }
            return interp.ret;
          },
          Code(interp, s2, code) {
            if (interp.doinclude[interp.doinclude.length - 1]) {
              let i2 = 0;
              while (i2 < s2.val.length) {
                const x = interp.work(s2.val[i2]);
                interp.ret += x;
                i2++;
              }
            }
          },
          PrepSimpleMacro(interp, s2, code) {
            interp.newMacro(s2.Identifier, s2.Replacement);
          },
          PrepFunctionMacro(interp, s2, code) {
            interp.newMacroFunction(s2.Identifier, s2.Args, s2.Replacement);
          },
          PrepIncludeLib(interp, s2, code) {
            interp.rt.include(s2.name);
          },
          PrepIncludeLocal(interp, s2, code) {
            const { includes } = interp.rt.config;
            if (s2.name in includes) {
              includes[s2.name].load(interp.rt);
            } else {
              interp.rt.raiseException("cannot find file: " + s2.name);
            }
          },
          PrepUndef(interp, s2, code) {
            if (interp.isMacroDefined(s2.Identifier)) {
              delete interp.macros[s2.Identifier.val];
            }
          },
          PrepIfdef(interp, s2, code) {
            pushInc(interp.isMacroDefined(s2.Identifier));
          },
          PrepIfndef(interp, s2, code) {
            pushInc(!interp.isMacroDefined(s2.Identifier));
          },
          PrepElse(interp, s2, code) {
            if (interp.doinclude.length > 1) {
              const x = interp.doinclude.pop();
              pushInc(!x);
            } else {
              interp.rt.raiseException("#else must be used after a #if");
            }
          },
          PrepEndif(interp, s2, code) {
            if (interp.doinclude.length > 1) {
              interp.doinclude.pop();
            } else {
              interp.rt.raiseException("#endif must be used after a #if");
            }
          },
          unknown(interp, s2, code) {
            interp.rt.raiseException("unhandled syntax " + s2.type);
          }
        };
      }
      visit(s2, code) {
        if ("type" in s2) {
          const _node = this.currentNode;
          this.currentNode = s2;
          if (s2.type in this.visitors) {
            return this.visitors[s2.type](this, s2, code);
          } else {
            return this.visitors["unknown"](this, s2, code);
          }
          this.currentNode = _node;
        } else {
          this.currentNode = s2;
          this.rt.raiseException("untyped syntax structure: " + JSON.stringify(s2));
        }
      }
      isMacroDefined(node) {
        if (node.type === "Identifier") {
          return node.val in this.macros;
        } else {
          return node.Identifier.val in this.macros;
        }
      }
      isMacro(node) {
        return this.isMacroDefined(node) && "val" in node && this.macros[node.val].type === "simple";
      }
      isMacroFunction(node) {
        return this.isMacroDefined(node) && "Identifier" in node && this.macros[node.Identifier.val].type === "function";
      }
      newMacro(id, replacement) {
        if (this.isMacroDefined(id)) {
          this.rt.raiseException("macro " + id.val + " is already defined");
        }
        this.macros[id.val] = {
          type: "simple",
          replacement
        };
      }
      newMacroFunction(id, args, replacement) {
        if (this.isMacroDefined(id)) {
          this.rt.raiseException("macro " + id.val + " is already defined");
        }
        this.macros[id.val] = {
          type: "function",
          args,
          replacement
        };
      }
      work(node) {
        if (node.type === "Seperator") {
          return node.val + node.space;
        } else {
          if (node in this.macroStack) {
            this.rt.raiseException("recursive macro detected");
          }
          this.macroStack.push(node);
          if (node.type === "Identifier") {
            return this.replaceMacro(node) + node.space;
          } else if (node.type === "PrepFunctionMacroCall") {
            return this.replaceMacroFunction(node);
          }
          this.macroStack.pop();
        }
      }
      replaceMacro(id) {
        if (this.isMacro(id)) {
          let ret2 = "";
          const rep = this.macros[id.val].replacement;
          let i2 = 0;
          while (i2 < rep.length) {
            const v = this.work(rep[i2]);
            ret2 += v;
            i2++;
          }
          return ret2;
        } else {
          return id.val;
        }
      }
      replaceMacroFunction(node) {
        if (this.isMacroFunction(node)) {
          const name = node.Identifier.val;
          const argsText = node.Args;
          const rep = this.macros[name].replacement;
          const { args } = this.macros[name];
          if (args.length === argsText.length) {
            let ret2 = "";
            let i2 = 0;
            while (i2 < rep.length) {
              if (rep[i2].type === "Seperator") {
                const v = this.work(rep[i2]);
                ret2 += v;
              } else {
                let argi = -1;
                let j = 0;
                while (j < args.length) {
                  if (rep[i2].type === "Identifier" && args[j].val === rep[i2].val) {
                    argi = j;
                    break;
                  }
                  j++;
                }
                if (argi >= 0) {
                  let v = "";
                  j = 0;
                  while (j < argsText[argi].length) {
                    v += this.work(argsText[argi][j]);
                    j++;
                  }
                  ret2 += v + rep[i2].space;
                } else {
                  const v = this.work(rep[i2]);
                  ret2 += v;
                }
              }
              i2++;
            }
            return ret2;
          } else {
            this.rt.raiseException("macro " + name + " requires " + args.length + " arguments (" + argsText.length + " given)");
          }
        } else {
          const argsText = node.Args;
          const v = [];
          let i2 = 0;
          while (i2 < argsText.length) {
            let x = "";
            let j = 0;
            while (j < argsText[i2].length) {
              x += this.work(argsText[i2][j]);
              j++;
            }
            v.push(x);
            i2++;
          }
          return node.Identifier.val + "(" + v.join(",") + ")" + node.space;
        }
      }
      parse(code) {
        const result = PEGUtil.parse(prepast, code);
        if (result.error != null) {
          throw new Error("ERROR: Preprocessing Failure:\n" + PEGUtil.errorMessage(result.error, true));
        }
        this.rt.interp = this;
        return this.visit(result.ast, code);
      }
    };
    function parse(rt2, code) {
      return new Preprocessor(rt2).parse(code);
    }
    exports2.parse = parse;
  }
});

// node_modules/JSCPP/lib/debugger.js
var require_debugger = __commonJS({
  "node_modules/JSCPP/lib/debugger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Debugger = class {
      constructor(src, oldSrc) {
        this.src = src || "";
        this.srcByLines = (oldSrc || src || "").split("\n");
        this.prevNode = null;
        this.done = false;
        this.conditions = {
          isStatement(prevNode, newStmt) {
            return newStmt != null ? newStmt.type.indexOf("Statement") >= 0 : void 0;
          },
          positionChanged(prevNode, newStmt) {
            return (prevNode != null ? prevNode.eOffset : void 0) !== newStmt.eOffset || (prevNode != null ? prevNode.sOffset : void 0) !== newStmt.sOffset;
          },
          lineChanged(prevNode, newStmt) {
            return (prevNode != null ? prevNode.sLine : void 0) !== newStmt.sLine;
          }
        };
        this.stopConditions = {
          isStatement: false,
          positionChanged: false,
          lineChanged: true
        };
      }
      setStopConditions(stopConditions) {
        this.stopConditions = stopConditions;
      }
      setCondition(name, callback) {
        this.conditions[name] = callback;
      }
      disableCondition(name) {
        this.stopConditions[name] = false;
      }
      enableCondition(name) {
        this.stopConditions[name] = true;
      }
      getSource() {
        return this.src;
      }
      start(rt2, gen) {
        this.rt = rt2;
        return this.gen = gen;
      }
      continue() {
        while (true) {
          const done = this.next();
          if (done !== false) {
            return done;
          }
          const curStmt = this.nextNode();
          for (const name of Object.keys(this.stopConditions)) {
            const active = this.stopConditions[name];
            if (active) {
              if (this.conditions[name](this.prevNode, curStmt)) {
                return false;
              }
            }
          }
        }
      }
      next() {
        this.prevNode = this.nextNode();
        const ngen = this.gen.next();
        if (ngen.done) {
          this.done = true;
          return ngen.value;
        } else {
          return false;
        }
      }
      nextLine() {
        const s2 = this.nextNode();
        return s2 ? this.srcByLines[s2.sLine - 1] : this.srcByLines[0];
      }
      nextNodeText() {
        const s2 = this.nextNode();
        return s2 ? this.src.slice(s2.sOffset, s2.eOffset).trim() : "";
      }
      nextNode() {
        if (this.done) {
          return {
            type: null,
            sOffset: -1,
            sLine: -1,
            sColumn: -1,
            eOffset: -1,
            eLine: -1,
            eColumn: -1
          };
        } else {
          return this.rt.interp.currentNode;
        }
      }
      variable(name) {
        if (name) {
          const v = this.rt.readVar(name);
          return {
            type: this.rt.makeTypeString(v.t),
            value: v.v
          };
        } else {
          const usedName = new Set();
          const ret2 = [];
          for (let scopeIndex = this.rt.scope.length - 1; scopeIndex >= 0; scopeIndex--) {
            for (name of Object.keys(this.rt.scope[scopeIndex].variables)) {
              const val = this.rt.scope[scopeIndex].variables[name];
              if (typeof val === "object" && "t" in val && "v" in val) {
                if (!usedName.has(name)) {
                  usedName.add(name);
                  ret2.push({
                    name,
                    type: this.rt.makeTypeString(val.t),
                    value: this.rt.makeValueString(val)
                  });
                }
              }
            }
          }
          return ret2;
        }
      }
    };
    exports2.default = Debugger;
  }
});

// node_modules/JSCPP/lib/includes/iostream.js
var require_iostream = __commonJS({
  "node_modules/JSCPP/lib/includes/iostream.js"(exports2, module2) {
    "use strict";
    var _skipSpace = function(s2) {
      const r = /^\s*/.exec(s2);
      if (r && r.length > 0) {
        return s2.substring(r[0].length);
      } else {
        return s2;
      }
    };
    var _read = function(rt2, reg, buf, type) {
      const r = reg.exec(buf);
      if (r == null || r.length === 0) {
        rt2.raiseException("input format mismatch " + rt2.makeTypeString(type) + " with buffer=" + buf);
      } else {
        return r;
      }
    };
    module2.exports = {
      load(rt2) {
        const { stdio } = rt2.config;
        const cinType = rt2.newClass("istream", []);
        const cin = {
          t: cinType,
          v: {
            buf: stdio.drain(),
            istream: stdio,
            members: {}
          },
          left: false
        };
        rt2.scope[0].variables["cin"] = cin;
        const pchar2 = rt2.normalPointerType(rt2.charTypeLiteral);
        rt2.types[rt2.getTypeSignature(cinType)] = {
          father: "object",
          handlers: {
            "o(>>)": {
              default(rt3, _cin, t) {
                if (!t.left) {
                  rt3.raiseException("only left value can be used as storage");
                }
                if (!rt3.isPrimitiveType(t.t)) {
                  rt3.raiseException(">> operator in istream cannot accept " + rt3.makeTypeString(t.t));
                }
                let b2 = _cin.v.buf;
                _cin.v.eofbit = b2.length === 0;
                let r;
                let v;
                switch (t.t.name) {
                  case "char":
                  case "signed char":
                  case "unsigned char":
                    b2 = _skipSpace(b2);
                    r = _read(rt3, /^./, b2, t.t);
                    v = r[0].charCodeAt(0);
                    break;
                  case "short":
                  case "short int":
                  case "signed short":
                  case "signed short int":
                  case "unsigned short":
                  case "unsigned short int":
                  case "int":
                  case "signed int":
                  case "unsigned":
                  case "unsigned int":
                  case "long":
                  case "long int":
                  case "signed long":
                  case "signed long int":
                  case "unsigned long":
                  case "unsigned long int":
                  case "long long":
                  case "long long int":
                  case "signed long long":
                  case "signed long long int":
                  case "unsigned long long":
                  case "unsigned long long int":
                    b2 = _skipSpace(b2);
                    r = _read(rt3, /^[-+]?(?:([0-9]*)([eE]\+?[0-9]+)?)|0/, b2, t.t);
                    v = parseInt(r[0], 10);
                    break;
                  case "float":
                  case "double":
                    b2 = _skipSpace(b2);
                    r = _read(rt3, /^[-+]?(?:[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?)|(?:([1-9][0-9]*)([eE]\+?[0-9]+)?)/, b2, t.t);
                    v = parseFloat(r[0]);
                    break;
                  case "bool":
                    b2 = _skipSpace(b2);
                    r = _read(rt3, /^(true|false)/, b2, t.t);
                    v = r[0] === "true";
                    break;
                  default:
                    rt3.raiseException(">> operator in istream cannot accept " + rt3.makeTypeString(t.t));
                }
                const len = r[0].length;
                _cin.v.failbit = len === 0;
                if (!_cin.v.failbit) {
                  t.v = rt3.val(t.t, v).v;
                  _cin.v.buf = b2.substring(len);
                }
                return _cin;
              }
            }
          }
        };
        const _cinString = function(rt3, _cin, t) {
          if (!rt3.isStringType(t.t)) {
            rt3.raiseException("only a pointer to string can be used as storage");
          }
          let b2 = _cin.v.buf;
          _cin.v.eofbit = b2.length === 0;
          b2 = _skipSpace(b2);
          const r = _read(rt3, /^\S*/, b2, t.t)[0];
          _cin.v.failbit = r.length === 0;
          _cin.v.buf = b2.substring(r.length);
          const initialPos = t.v.position;
          const tar = t.v.target;
          if (tar.length - initialPos <= r.length) {
            rt3.raiseException(`target string buffer is ${r.length - (tar.length - initialPos)} too short`);
          }
          for (let i2 = 0, end = r.length, asc = 0 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
            tar[i2 + initialPos] = rt3.val(rt3.charTypeLiteral, r.charCodeAt(i2));
          }
          tar[r.length + initialPos] = rt3.val(rt3.charTypeLiteral, 0);
          return _cin;
        };
        rt2.regOperator(_cinString, cin.t, ">>", [pchar2], cin.t);
        const _getline = function(rt3, _cin, t, limitV, delimV) {
          let removeDelim;
          if (!rt3.isStringType(t.t)) {
            rt3.raiseException("only a pointer to string can be used as storage");
          }
          const limit = limitV.v;
          const delim = delimV != null ? String.fromCharCode(delimV.v) : "\n";
          const b2 = _cin.v.buf;
          _cin.v.eofbit = b2.length === 0;
          let r = _read(rt3, new RegExp(`^[^${delim}]*`), b2, t.t)[0];
          if (r.length + 1 > limit) {
            r = r.substring(0, limit - 1);
          }
          if (b2.charAt(r.length) === delim.charAt(0)) {
            removeDelim = true;
            _cin.v.failbit = false;
          } else {
            _cin.v.failbit = r.length === 0;
          }
          _cin.v.buf = b2.substring(r.length + (removeDelim ? 1 : 0));
          const initialPos = t.v.position;
          const tar = t.v.target;
          if (tar.length - initialPos <= r.length) {
            rt3.raiseException(`target string buffer is ${r.length - (tar.length - initialPos)} too short`);
          }
          for (let i2 = 0, end = r.length, asc = 0 <= end; asc ? i2 < end : i2 > end; asc ? i2++ : i2--) {
            tar[i2 + initialPos] = rt3.val(rt3.charTypeLiteral, r.charCodeAt(i2));
          }
          tar[r.length + initialPos] = rt3.val(rt3.charTypeLiteral, 0);
          return _cin;
        };
        rt2.regFunc(_getline, cin.t, "getline", [pchar2, rt2.intTypeLiteral, rt2.charTypeLiteral], cin.t);
        rt2.regFunc(_getline, cin.t, "getline", [pchar2, rt2.intTypeLiteral], cin.t);
        const _get = function(rt3, _cin) {
          const b2 = _cin.v.buf;
          _cin.v.eofbit = b2.length === 0;
          if (_cin.v.eofbit) {
            return rt3.val(rt3.intTypeLiteral, -1);
          } else {
            const r = _read(rt3, /^.|[\r\n]/, b2, rt3.charTypeLiteral);
            _cin.v.buf = b2.substring(r.length);
            const v = r[0].charCodeAt(0);
            return rt3.val(rt3.intTypeLiteral, v);
          }
        };
        rt2.regFunc(_get, cin.t, "get", [], rt2.intTypeLiteral);
        const _bool = (rt3, _cin) => rt3.val(rt3.boolTypeLiteral, !_cin.v.failbit);
        rt2.regOperator(_bool, cin.t, "bool", [], rt2.boolTypeLiteral);
        const coutType = rt2.newClass("ostream", []);
        const cout = {
          t: coutType,
          v: {
            ostream: stdio,
            members: {}
          },
          left: false
        };
        rt2.scope[0].variables["cout"] = cout;
        rt2.types[rt2.getTypeSignature(cout.t)] = {
          father: "object",
          handlers: {
            "o(<<)": {
              default(rt3, _cout, t) {
                let r;
                if (_cout.manipulators != null) {
                  t = _cout.manipulators.use(t);
                }
                if (rt3.isPrimitiveType(t.t)) {
                  if (t.t.name.indexOf("char") >= 0) {
                    r = String.fromCharCode(t.v);
                  } else if (t.t.name === "bool") {
                    r = t.v ? "1" : "0";
                  } else {
                    r = t.v.toString();
                  }
                } else if (rt3.isStringType(t)) {
                  r = rt3.getStringFromCharArray(t);
                } else {
                  rt3.raiseException("<< operator in ostream cannot accept " + rt3.makeTypeString(t.t));
                }
                _cout.v.ostream.write(r);
                return _cout;
              }
            }
          }
        };
        const endl = rt2.val(rt2.charTypeLiteral, "\n".charCodeAt(0));
        rt2.scope[0].variables["endl"] = endl;
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/cctype.js
var require_cctype = __commonJS({
  "node_modules/JSCPP/lib/includes/cctype.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      load(rt2) {
        rt2.regFunc(function(rt3, _this2, x) {
          const c2 = rt3.getFunc("global", "isdigit", [rt3.intTypeLiteral])(rt3, _this2, x);
          if (!c2.v) {
            return rt3.getFunc("global", "isalpha", [rt3.intTypeLiteral])(rt3, _this2, x);
          }
          return c2;
        }, "global", "isalnum", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = x.v >= "0".charCodeAt(0) && x.v <= "9".charCodeAt(0) ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "isdigit", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const c2 = rt3.getFunc("global", "isupper", [rt3.intTypeLiteral])(rt3, _this2, x);
          if (!c2.v) {
            return rt3.getFunc("global", "islower", [rt3.intTypeLiteral])(rt3, _this2, x);
          }
          return c2;
        }, "global", "isalpha", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = [
            32,
            9,
            10,
            11,
            12,
            13
          ].includes(x.v) ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "isspace", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = x.v >= 0 && x.v <= 31 || x.v === 127 ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "iscntrl", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = x.v > 31 && x.v !== 127 ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "isprint", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          let c2 = rt3.getFunc("global", "isspace", [rt3.intTypeLiteral])(rt3, _this2, x);
          if (!c2.v) {
            c2 = rt3.getFunc("global", "isgraph", [rt3.intTypeLiteral])(rt3, _this2, x);
            if (!c2.v) {
              return rt3.val(rt3.intTypeLiteral, 1);
            }
          }
          return rt3.val(rt3.intTypeLiteral, 0);
        }, "global", "isgraph", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = x.v >= "a".charCodeAt(0) && x.v <= "z".charCodeAt(0) ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "islower", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = x.v >= "A".charCodeAt(0) && x.v <= "Z".charCodeAt(0) ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "isupper", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          let c2 = rt3.getFunc("global", "isgraph", [rt3.intTypeLiteral])(rt3, _this2, x);
          if (c2.v) {
            c2 = rt3.getFunc("global", "isalnum", [rt3.intTypeLiteral])(rt3, _this2, x);
            if (!c2.v) {
              return rt3.val(rt3.intTypeLiteral, 1);
            }
          }
          return rt3.val(rt3.intTypeLiteral, 0);
        }, "global", "ispunct", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const v = x.v >= "A".charCodeAt(0) && x.v <= "F".charCodeAt(0) || x.v >= "a".charCodeAt(0) && x.v <= "f".charCodeAt(0) || x.v >= "0".charCodeAt(0) && x.v <= "9".charCodeAt(0) ? 1 : 0;
          return rt3.val(rt3.intTypeLiteral, v);
        }, "global", "isxdigit", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const c2 = rt3.getFunc("global", "isupper", [rt3.intTypeLiteral])(rt3, _this2, x);
          if (c2.v) {
            return rt3.val(rt3.intTypeLiteral, x.v + 32);
          }
          return x;
        }, "global", "tolower", [rt2.intTypeLiteral], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, x) {
          const c2 = rt3.getFunc("global", "islower", [rt3.intTypeLiteral])(rt3, _this2, x);
          if (c2.v) {
            return rt3.val(rt3.intTypeLiteral, x.v - 32);
          }
          return x;
        }, "global", "toupper", [rt2.intTypeLiteral], rt2.intTypeLiteral);
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/shared/cstring_strcpy.js
var require_cstring_strcpy = __commonJS({
  "node_modules/JSCPP/lib/includes/shared/cstring_strcpy.js"(exports2, module2) {
    "use strict";
    module2.exports = function(rt2, _this2, dest, src) {
      if (rt2.isArrayType(dest) && rt2.isArrayType(src)) {
        const srcarr = src.v.target;
        let i2 = src.v.position;
        const destarr = dest.v.target;
        let j = dest.v.position;
        while (i2 < srcarr.length && j < destarr.length && srcarr[i2].v !== 0) {
          destarr[j] = rt2.clone(srcarr[i2]);
          i2++;
          j++;
        }
        if (i2 === srcarr.length) {
          rt2.raiseException('source string does not have a pending "\\0"');
        } else if (j === destarr.length - 1) {
          rt2.raiseException("destination array is not big enough");
        } else {
          destarr[j] = rt2.val(rt2.charTypeLiteral, 0);
        }
      } else {
        rt2.raiseException("destination or source is not an array");
      }
      return dest;
    };
  }
});

// node_modules/JSCPP/lib/includes/cstring.js
var require_cstring = __commonJS({
  "node_modules/JSCPP/lib/includes/cstring.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      load(rt2) {
        const pchar2 = rt2.normalPointerType(rt2.charTypeLiteral);
        const sizet = rt2.primitiveType("unsigned int");
        const _strcpy = require_cstring_strcpy();
        rt2.regFunc(_strcpy, "global", "strcpy", [pchar2, pchar2], pchar2);
        rt2.regFunc(function(rt3, _this2, dest, src, num) {
          if (rt3.isArrayType(dest.t) && rt3.isArrayType(src.t)) {
            const srcarr = src.v.target;
            let i2 = src.v.position;
            const destarr = dest.v.target;
            let j = dest.v.position;
            let n = num.v;
            while (n > 0 && i2 < srcarr.length && j < destarr.length - 1 && srcarr[i2].v !== 0) {
              destarr[j] = rt3.clone(srcarr[i2]);
              n--;
              i2++;
              j++;
            }
            if (srcarr[i2].v === 0) {
              while (n > 0 && j < destarr.length) {
                destarr[j++] = rt3.val(rt3.charTypeLiteral, 0);
              }
            }
            if (i2 === srcarr.length) {
              rt3.raiseException('source string does not have a pending "\\0"');
            } else if (j === destarr.length - 1) {
              rt3.raiseException("destination array is not big enough");
            }
          } else {
            rt3.raiseException("destination or source is not an array");
          }
          return dest;
        }, "global", "strncpy", [
          pchar2,
          pchar2,
          sizet
        ], pchar2);
        rt2.regFunc(function(rt3, _this2, dest, src) {
          if (rt3.isArrayType(dest.t) && rt3.isArrayType(src.t)) {
            let lendest;
            const srcarr = src.v.target;
            const destarr = dest.v.target;
            if (srcarr === destarr) {
              let lensrc;
              const i2 = src.v.position;
              const j = dest.v.position;
              if (i2 < j) {
                lensrc = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, src).v;
                if (i2 + lensrc + 1 >= j) {
                  rt3.raiseException("overlap is not allowed");
                }
              } else {
                lensrc = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, src).v;
                lendest = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, dest).v;
                if (j + lensrc + lendest + 1 >= i2) {
                  rt3.raiseException("overlap is not allowed");
                }
              }
            }
            lendest = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, dest).v;
            const pCharArr = rt3.arrayPointerType(rt3.charTypeLiteral, dest.t.size);
            const newDest = rt3.val(pCharArr, rt3.makeArrayPointerValue(dest.v.target, dest.v.position + lendest));
            return rt3.getFunc("global", "strcpy", [
              pchar2,
              pchar2
            ])(rt3, null, newDest, src);
          } else {
            rt3.raiseException("destination or source is not an array");
          }
          return dest;
        }, "global", "strcat", [
          pchar2,
          pchar2
        ], pchar2);
        rt2.regFunc(function(rt3, _this2, dest, src, num) {
          if (rt3.isArrayType(dest.t) && rt3.isArrayType(src.t)) {
            let lendest;
            const srcarr = src.v.target;
            const destarr = dest.v.target;
            if (srcarr === destarr) {
              let lensrc;
              const i2 = src.v.position;
              const j = dest.v.position;
              const n = num.v;
              if (i2 < j) {
                lensrc = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, src).v;
                if (lensrc > n) {
                  lensrc = n;
                }
                if (i2 + lensrc + 1 >= j) {
                  rt3.raiseException("overlap is not allowed");
                }
              } else {
                lensrc = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, src).v;
                if (lensrc > n) {
                  lensrc = n;
                }
                lendest = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, dest).v;
                if (j + lensrc + lendest + 1 >= i2) {
                  rt3.raiseException("overlap is not allowed");
                }
              }
            }
            lendest = rt3.getFunc("global", "strlen", [pchar2])(rt3, null, dest).v;
            const newDest = rt3.val(pchar2, rt3.makeArrayPointerValue(dest.v.target, dest.v.position + lendest));
            return rt3.getFunc("global", "strncpy", [
              pchar2,
              pchar2,
              sizet
            ])(rt3, null, newDest, src, num);
          } else {
            rt3.raiseException("destination or source is not an array");
          }
          return dest;
        }, "global", "strncat", [
          pchar2,
          pchar2,
          sizet
        ], pchar2);
        rt2.regFunc(function(rt3, _this2, str) {
          if (rt3.isArrayType(str)) {
            const arr = str.v.target;
            let i2 = str.v.position;
            while (i2 < arr.length && arr[i2].v !== 0) {
              i2++;
            }
            if (i2 === arr.length) {
              return rt3.raiseException('target string does not have a pending "\\0"');
            } else {
              return rt3.val(rt3.intTypeLiteral, i2 - str.v.position);
            }
          } else {
            return rt3.raiseException("target is not an array");
          }
        }, "global", "strlen", [pchar2], sizet);
        rt2.regFunc(function(rt3, _this2, dest, src) {
          if (rt3.isArrayType(dest) && rt3.isArrayType(src)) {
            const srcarr = src.v.target;
            let i2 = src.v.position;
            const destarr = dest.v.target;
            let j = dest.v.position;
            while (i2 < srcarr.length && j < destarr.length && srcarr[i2].v === destarr[i2].v) {
              i2++;
              j++;
            }
            return rt3.val(rt3.intTypeLiteral, destarr[i2].v - srcarr[i2].v);
          } else {
            return rt3.raiseException("str1 or str2 is not an array");
          }
        }, "global", "strcmp", [
          pchar2,
          pchar2
        ], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, dest, src, num) {
          if (rt3.isArrayType(dest) && rt3.isArrayType(src)) {
            const srcarr = src.v.target;
            let i2 = src.v.position;
            const destarr = dest.v.target;
            let j = dest.v.position;
            let n = num.v;
            while (n > 0 && i2 < srcarr.length && j < destarr.length && srcarr[i2].v === destarr[i2].v) {
              i2++;
              j++;
              n--;
            }
            return rt3.val(rt3.intTypeLiteral, destarr[i2].v - srcarr[i2].v);
          } else {
            return rt3.raiseException("str1 or str2 is not an array");
          }
        }, "global", "strncmp", [
          pchar2,
          pchar2,
          sizet
        ], rt2.intTypeLiteral);
        rt2.regFunc(function(rt3, _this2, str, ch) {
          if (rt3.isArrayType(str)) {
            const arr = str.v.target;
            let i2 = str.v.position;
            while (i2 < arr.length && arr[i2].v !== 0 && arr[i2].v !== ch.v) {
              i2++;
            }
            if (arr[i2].v === 0) {
              return rt3.val(pchar2, rt3.nullPointerValue);
            } else if (arr[i2].v === ch.v) {
              return rt3.val(pchar2, rt3.makeArrayPointerValue(arr, i2));
            } else {
              return rt3.raiseException('target string does not have a pending "\\0"');
            }
          } else {
            return rt3.raiseException("str1 or str2 is not an array");
          }
        }, "global", "strchr", [
          pchar2,
          rt2.charTypeLiteral
        ], pchar2);
        rt2.regFunc(function(rt3, _this2, str, ch) {
          if (rt3.isArrayType(str)) {
            const arr = str.v.target;
            let i2 = str.v.position;
            let lastpos = -1;
            while (i2 < arr.length && arr[i2].v !== 0) {
              if (arr[i2].v === ch.v) {
                lastpos = i2;
              }
              i2++;
            }
            if (arr[i2].v === 0) {
              if (lastpos >= 0) {
                return rt3.val(pchar2, rt3.makeArrayPointerValue(arr, lastpos));
              } else {
                return rt3.val(pchar2, rt3.nullPointerValue);
              }
            } else {
              return rt3.raiseException('target string does not have a pending "\\0"');
            }
          } else {
            return rt3.raiseException("str1 or str2 is not an array");
          }
        }, "global", "strrchr", [
          pchar2,
          rt2.charTypeLiteral
        ], pchar2);
        return rt2.regFunc(function(rt3, _this2, str1, str2) {
          if (rt3.isArrayType(str1) && rt3.isArrayType(str2)) {
            const arr = str1.v.target;
            let i2 = str1.v.position;
            const tar = str2.v.target;
            while (i2 < arr.length && arr[i2].v !== 0) {
              let j = str2.v.position;
              let _i = i2;
              while (j < tar.length && str1.v.target[_i].v === str2.v.target[j].v) {
                _i++;
                j++;
              }
              if (j === tar.length) {
                break;
              }
              i2++;
            }
            if (arr[i2].v === 0) {
              return rt3.val(pchar2, rt3.nullPointerValue);
            } else if (i2 === arr.length) {
              return rt3.raiseException('target string does not have a pending "\\0"');
            } else {
              return rt3.val(pchar2, rt3.makeArrayPointerValue(arr, i2));
            }
          } else {
            return rt3.raiseException("str1 or str2 is not an array");
          }
        }, "global", "strstr", [
          pchar2,
          rt2.charTypeLiteral
        ], pchar2);
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/cmath.js
var require_cmath = __commonJS({
  "node_modules/JSCPP/lib/includes/cmath.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      load(rt2) {
        const tDouble = rt2.doubleTypeLiteral;
        const g = "global";
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.cos(x.v)), g, "cos", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.sin(x.v)), g, "sin", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.tan(x.v)), g, "tan", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.acos(x.v)), g, "acos", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.asin(x.v)), g, "asin", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.atan(x.v)), g, "atan", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, y, x) => rt3.val(tDouble, Math.atan(y.v / x.v)), g, "atan2", [tDouble, tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.cosh(x.v)), g, "cosh", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.sinh(x.v)), g, "sinh", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.tanh(x.v)), g, "tanh", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.acosh(x.v)), g, "acosh", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.asinh(x.v)), g, "asinh", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.atanh(x.v)), g, "atanh", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.exp(x.v)), g, "exp", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.log(x.v)), g, "log", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.log10(x.v)), g, "log10", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x, y) => rt3.val(tDouble, Math.pow(x.v, y.v)), g, "pow", [tDouble, tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.sqrt(x.v)), g, "sqrt", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.ceil(x.v)), g, "ceil", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.floor(x.v)), g, "floor", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.abs(x.v)), g, "fabs", [tDouble], tDouble);
        rt2.regFunc((rt3, _this2, x) => rt3.val(tDouble, Math.abs(x.v)), g, "abs", [tDouble], tDouble);
      }
    };
  }
});

// node_modules/printf/lib/printf.js
var require_printf = __commonJS({
  "node_modules/printf/lib/printf.js"(exports2, module2) {
    var util = require("util");
    var tokenize = function(str, re, parseDelim, instance) {
      var tokens = [];
      var match, content, lastIndex = 0;
      while (match = re.exec(str)) {
        content = str.slice(lastIndex, re.lastIndex - match[0].length);
        if (content.length) {
          tokens.push(content);
        }
        if (parseDelim) {
          var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
          if (typeof parsed != "undefined") {
            if (parsed.specifier === "%") {
              tokens.push("%");
            } else {
              tokens.push(parsed);
            }
          }
        }
        lastIndex = re.lastIndex;
      }
      content = str.slice(lastIndex);
      if (content.length) {
        tokens.push(content);
      }
      return tokens;
    };
    var Formatter = function(format) {
      this._mapped = false;
      this._format = format;
      this._tokens = tokenize(format, this._re, this._parseDelim, this);
    };
    Formatter.prototype._re = /\%(?:\(([\w_.]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(?:(\.)(\*|\d+)?)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
    Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier) {
      if (mapping) {
        this._mapped = true;
      }
      return {
        mapping,
        intmapping,
        flags,
        _minWidth: minWidth,
        period,
        _precision: precision,
        specifier
      };
    };
    Formatter.prototype._specifiers = {
      b: {
        base: 2,
        isInt: true
      },
      o: {
        base: 8,
        isInt: true
      },
      x: {
        base: 16,
        isInt: true
      },
      X: {
        extend: ["x"],
        toUpper: true
      },
      d: {
        base: 10,
        isInt: true
      },
      i: {
        extend: ["d"]
      },
      u: {
        extend: ["d"],
        isUnsigned: true
      },
      c: {
        setArg: function(token) {
          if (!isNaN(token.arg)) {
            var num = parseInt(token.arg);
            if (num < 0 || num > 127) {
              throw new Error("invalid character code passed to %c in printf");
            }
            token.arg = isNaN(num) ? "" + num : String.fromCharCode(num);
          }
        }
      },
      s: {
        setMaxWidth: function(token) {
          token.maxWidth = token.period == "." ? token.precision : -1;
        }
      },
      e: {
        isDouble: true,
        doubleNotation: "e"
      },
      E: {
        extend: ["e"],
        toUpper: true
      },
      f: {
        isDouble: true,
        doubleNotation: "f"
      },
      F: {
        extend: ["f"]
      },
      g: {
        isDouble: true,
        doubleNotation: "g"
      },
      G: {
        extend: ["g"],
        toUpper: true
      },
      O: {
        isObject: true
      }
    };
    Formatter.prototype.format = function(filler) {
      if (this._mapped && typeof filler != "object") {
        throw new Error("format requires a mapping");
      }
      var str = "";
      var position = 0;
      for (var i2 = 0, token; i2 < this._tokens.length; i2++) {
        token = this._tokens[i2];
        if (typeof token == "string") {
          str += token;
        } else {
          if (this._mapped) {
            var tokens = token.mapping.split(".");
            var value = filler;
            for (var j = 0, c2 = tokens.length; j < c2; j++) {
              value = value[tokens[j]];
              if (typeof value === "undefined") {
                break;
              }
            }
            if (typeof value == "undefined") {
              throw new Error("missing key '" + token.mapping + "'");
            }
            token.arg = value;
          } else {
            if (token.intmapping) {
              position = parseInt(token.intmapping) - 1;
            }
            if (position >= arguments.length) {
              throw new Error("got " + arguments.length + " printf arguments, insufficient for '" + this._format + "'");
            }
            token.arg = arguments[position++];
          }
          if (!token.compiled) {
            token.compiled = true;
            token.sign = "";
            token.zeroPad = false;
            token.rightJustify = false;
            token.alternative = false;
            var flags = {};
            for (var fi = token.flags.length; fi--; ) {
              var flag = token.flags.charAt(fi);
              flags[flag] = true;
              switch (flag) {
                case " ":
                  token.sign = " ";
                  break;
                case "+":
                  token.sign = "+";
                  break;
                case "0":
                  token.zeroPad = flags["-"] ? false : true;
                  break;
                case "-":
                  token.rightJustify = true;
                  token.zeroPad = false;
                  break;
                case "#":
                  token.alternative = true;
                  break;
                default:
                  throw Error("bad formatting flag '" + token.flags.charAt(fi) + "'");
              }
            }
            token.minWidth = token._minWidth ? parseInt(token._minWidth) : 0;
            token.maxWidth = -1;
            token.toUpper = false;
            token.isUnsigned = false;
            token.isInt = false;
            token.isDouble = false;
            token.isObject = false;
            token.precision = 1;
            if (token.period == ".") {
              if (token._precision) {
                token.precision = parseInt(token._precision);
              } else {
                token.precision = 0;
              }
            }
            var mixins = this._specifiers[token.specifier];
            if (typeof mixins == "undefined") {
              throw new Error("unexpected specifier '" + token.specifier + "'");
            }
            if (mixins.extend) {
              var s2 = this._specifiers[mixins.extend];
              for (var k in s2) {
                mixins[k] = s2[k];
              }
              delete mixins.extend;
            }
            for (var l in mixins) {
              token[l] = mixins[l];
            }
          }
          if (typeof token.setArg == "function") {
            token.setArg(token);
          }
          if (typeof token.setMaxWidth == "function") {
            token.setMaxWidth(token);
          }
          if (token._minWidth == "*") {
            if (this._mapped) {
              throw new Error("* width not supported in mapped formats");
            }
            token.minWidth = parseInt(arguments[position++]);
            if (isNaN(token.minWidth)) {
              throw new Error("the argument for * width at position " + position + " is not a number in " + this._format);
            }
            if (token.minWidth < 0) {
              token.rightJustify = true;
              token.minWidth = -token.minWidth;
            }
          }
          if (token._precision == "*" && token.period == ".") {
            if (this._mapped) {
              throw new Error("* precision not supported in mapped formats");
            }
            token.precision = parseInt(arguments[position++]);
            if (isNaN(token.precision)) {
              throw Error("the argument for * precision at position " + position + " is not a number in " + this._format);
            }
            if (token.precision < 0) {
              token.precision = 1;
              token.period = "";
            }
          }
          if (token.isInt) {
            if (token.period == ".") {
              token.zeroPad = false;
            }
            this.formatInt(token);
          } else if (token.isDouble) {
            if (token.period != ".") {
              token.precision = 6;
            }
            this.formatDouble(token);
          } else if (token.isObject) {
            this.formatObject(token);
          }
          this.fitField(token);
          str += "" + token.arg;
        }
      }
      return str;
    };
    Formatter.prototype._zeros10 = "0000000000";
    Formatter.prototype._spaces10 = "          ";
    Formatter.prototype.formatInt = function(token) {
      var i2 = parseInt(token.arg);
      if (!isFinite(i2)) {
        if (typeof token.arg != "number") {
          throw new Error("format argument '" + token.arg + "' not an integer; parseInt returned " + i2);
        }
        i2 = 0;
      }
      if (i2 < 0 && (token.isUnsigned || token.base != 10)) {
        i2 = 4294967295 + i2 + 1;
      }
      if (i2 < 0) {
        token.arg = (-i2).toString(token.base);
        this.zeroPad(token);
        token.arg = "-" + token.arg;
      } else {
        token.arg = i2.toString(token.base);
        if (!i2 && !token.precision) {
          token.arg = "";
        } else {
          this.zeroPad(token);
        }
        if (token.sign) {
          token.arg = token.sign + token.arg;
        }
      }
      if (token.base == 16) {
        if (token.alternative) {
          token.arg = "0x" + token.arg;
        }
        token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
      }
      if (token.base == 8) {
        if (token.alternative && token.arg.charAt(0) != "0") {
          token.arg = "0" + token.arg;
        }
      }
    };
    Formatter.prototype.formatDouble = function(token) {
      var f = parseFloat(token.arg);
      if (!isFinite(f)) {
        if (typeof token.arg != "number") {
          throw new Error("format argument '" + token.arg + "' not a float; parseFloat returned " + f);
        }
        f = 0;
      }
      switch (token.doubleNotation) {
        case "e": {
          token.arg = f.toExponential(token.precision);
          break;
        }
        case "f": {
          token.arg = f.toFixed(token.precision);
          break;
        }
        case "g": {
          if (Math.abs(f) < 1e-4) {
            token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
          } else {
            token.arg = f.toPrecision(token.precision);
          }
          if (!token.alternative) {
            token.arg = token.arg.replace(/(\..*[^0])0*e/, "$1e");
            token.arg = token.arg.replace(/\.0*e/, "e").replace(/\.0$/, "");
          }
          break;
        }
        default:
          throw new Error("unexpected double notation '" + token.doubleNotation + "'");
      }
      token.arg = token.arg.replace(/e\+(\d)$/, "e+0$1").replace(/e\-(\d)$/, "e-0$1");
      if (token.alternative) {
        token.arg = token.arg.replace(/^(\d+)$/, "$1.");
        token.arg = token.arg.replace(/^(\d+)e/, "$1.e");
      }
      if (f >= 0 && token.sign) {
        token.arg = token.sign + token.arg;
      }
      token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
    };
    Formatter.prototype.formatObject = function(token) {
      var precision = token.period === "." ? token.precision : null;
      token.arg = util.inspect(token.arg, {
        showHidden: !token.alternative,
        depth: precision,
        colors: token.sign,
        compact: true
      });
    };
    Formatter.prototype.zeroPad = function(token, length) {
      length = arguments.length == 2 ? length : token.precision;
      var negative = false;
      if (typeof token.arg != "string") {
        token.arg = "" + token.arg;
      }
      if (token.arg.substr(0, 1) === "-") {
        negative = true;
        token.arg = token.arg.substr(1);
      }
      var tenless = length - 10;
      while (token.arg.length < tenless) {
        token.arg = token.rightJustify ? token.arg + this._zeros10 : this._zeros10 + token.arg;
      }
      var pad = length - token.arg.length;
      token.arg = token.rightJustify ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
      if (negative)
        token.arg = "-" + token.arg;
    };
    Formatter.prototype.fitField = function(token) {
      if (token.maxWidth >= 0 && token.arg.length > token.maxWidth) {
        token.arg = token.arg.substring(0, token.maxWidth);
      }
      if (token.zeroPad) {
        this.zeroPad(token, token.minWidth);
        return;
      }
      this.spacePad(token);
    };
    Formatter.prototype.spacePad = function(token, length) {
      length = arguments.length == 2 ? length : token.minWidth;
      if (typeof token.arg != "string") {
        token.arg = "" + token.arg;
      }
      var tenless = length - 10;
      while (token.arg.length < tenless) {
        token.arg = token.rightJustify ? token.arg + this._spaces10 : this._spaces10 + token.arg;
      }
      var pad = length - token.arg.length;
      token.arg = token.rightJustify ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
    };
    module2.exports = function() {
      var args = Array.prototype.slice.call(arguments), stream, format;
      if (args[0] instanceof require("stream").Stream) {
        stream = args.shift();
      }
      format = args.shift();
      var formatter = new Formatter(format);
      var string = formatter.format.apply(formatter, args);
      if (stream) {
        stream.write(string);
      } else {
        return string;
      }
    };
    module2.exports.Formatter = Formatter;
  }
});

// node_modules/JSCPP/lib/includes/cstdio.js
var require_cstdio = __commonJS({
  "node_modules/JSCPP/lib/includes/cstdio.js"(exports2, module2) {
    "use strict";
    var printf = require_printf();
    var EOF = 0;
    var format_type_map = function(rt2, ctrl) {
      switch (ctrl) {
        case "d":
        case "i":
          return rt2.intTypeLiteral;
        case "u":
        case "o":
        case "x":
        case "X":
          return rt2.unsignedintTypeLiteral;
        case "f":
        case "F":
          return rt2.floatTypeLiteral;
        case "e":
        case "E":
        case "g":
        case "G":
        case "a":
        case "A":
          return rt2.doubleTypeLiteral;
        case "c":
          return rt2.charTypeLiteral;
        case "s":
          return rt2.normalPointerType(rt2.charTypeLiteral);
        case "p":
          return rt2.normalPointerType(rt2.voidTypeLiteral);
        case "n":
          rt2.raiseException("%n is not supported");
      }
    };
    var validate_format = function(rt2, format, ...params) {
      let i2 = 0;
      const re = /%(?:[-+ #0])?(?:[0-9]+|\*)?(?:\.(?:[0-9]+|\*))?([diuoxXfFeEgGaAcspn])/g;
      return (() => {
        let ctrl;
        const result = [];
        while ((ctrl = re.exec(format)) != null) {
          const type = format_type_map(rt2, ctrl[1]);
          if (params.length <= i2) {
            rt2.raiseException(`insufficient arguments (at least ${i2 + 1} is required)`);
          }
          const target = params[i2++];
          const casted = rt2.cast(type, target);
          if (rt2.isStringType(casted)) {
            result.push(rt2.getStringFromCharArray(casted));
          } else {
            if (casted.v == null || typeof casted.v === "number" && isNaN(casted.v)) {
              rt2.raiseException("uninitialized value when using printf");
            }
            result.push(casted.v);
          }
        }
        return result;
      })();
    };
    function __range__(left, right, inclusive) {
      const range = [];
      const ascending = left < right;
      const end = !inclusive ? right : ascending ? right + 1 : right - 1;
      for (let i2 = left; ascending ? i2 < end : i2 > end; ascending ? i2++ : i2--) {
        range.push(i2);
      }
      return range;
    }
    module2.exports = {
      load(rt2) {
        const char_pointer = rt2.normalPointerType(rt2.charTypeLiteral);
        const { stdio } = rt2.config;
        let input_stream = stdio.drain();
        const _consume_next_char = function() {
          let char_return = "";
          if (input_stream.length > 0) {
            char_return = input_stream[0];
            input_stream = input_stream.substr(1);
            return char_return;
          } else {
            throw new Error("EOF");
          }
        };
        const _consume_next_line = function() {
          let retval;
          const next_line_break = input_stream.indexOf("\n");
          if (next_line_break > -1) {
            retval = input_stream.substr(0, next_line_break);
            input_stream = input_stream.replace(`${retval}
`, "");
          } else {
            retval = input_stream;
            input_stream = "";
          }
          return retval;
        };
        const _strcpy = require_cstring_strcpy();
        const __printf = function(format, ...params) {
          if (rt2.isStringType(format.t)) {
            const formatStr = rt2.getStringFromCharArray(format);
            const parsed_params = validate_format(rt2, formatStr, ...params);
            const retval = printf(formatStr, ...parsed_params);
            return rt2.makeCharArrayFromString(retval);
          } else {
            rt2.raiseException("format must be a string");
          }
        };
        const _sprintf = function(rt3, _this2, target, format, ...params) {
          const retval = __printf(format, ...params);
          _strcpy(rt3, null, [target, retval]);
          return rt3.val(rt3.intTypeLiteral, retval.v.target.length);
        };
        rt2.regFunc(_sprintf, "global", "sprintf", [char_pointer, char_pointer, "?"], rt2.intTypeLiteral);
        const _printf = function(rt3, _this2, format, ...params) {
          const retval = __printf(format, ...params);
          const retvalStr = rt3.getStringFromCharArray(retval);
          stdio.write(retvalStr);
          return rt3.val(rt3.intTypeLiteral, retval.v.target.length);
        };
        rt2.regFunc(_printf, "global", "printf", [char_pointer, "?"], rt2.intTypeLiteral);
        const _getchar = function(rt3, _this2) {
          try {
            const char = _consume_next_char();
            return rt3.val(rt3.intTypeLiteral, char.charCodeAt(0));
          } catch (error2) {
            return rt3.val(rt3.intTypeLiteral, EOF);
          }
        };
        rt2.regFunc(_getchar, "global", "getchar", [], rt2.intTypeLiteral);
        const _gets = function(rt3, _this2, charPtr) {
          const return_value = _consume_next_line();
          const destArray = charPtr.v.target;
          for (let i2 = 0, end = return_value.length, asc = 0 <= end; asc ? i2 <= end : i2 >= end; asc ? i2++ : i2--) {
            try {
              destArray[i2] = rt3.val(rt3.charTypeLiteral, return_value.charCodeAt(i2));
            } catch (error2) {
              destArray[i2] = rt3.val(rt3.charTypeLiteral, 0);
            }
          }
          destArray[return_value.length] = rt3.val(rt3.charTypeLiteral, 0);
          return rt3.val(char_pointer, charPtr.v);
        };
        rt2.regFunc(_gets, "global", "gets", [char_pointer], char_pointer);
        const _putchar = function(rt3, _this2, char) {
          const print_mask = rt3.makeCharArrayFromString("%c");
          _printf(rt3, null, print_mask, char);
          return char;
        };
        rt2.regFunc(_putchar, "global", "putchar", [rt2.charTypeLiteral], rt2.intTypeLiteral);
        const _puts = function(rt3, _this2, charPtr) {
          const print_mask = rt3.makeCharArrayFromString("%s");
          _printf(rt3, null, print_mask, charPtr);
          return rt3.val(rt3.intTypeLiteral, 1);
        };
        rt2.regFunc(_puts, "global", "puts", [char_pointer], rt2.intTypeLiteral);
        const _ASCII = {
          a: "a".charCodeAt(0),
          f: "f".charCodeAt(0),
          A: "A".charCodeAt(0),
          F: "F".charCodeAt(0),
          0: "0".charCodeAt(0),
          8: "8".charCodeAt(0),
          9: "9".charCodeAt(0)
        };
        const _hex2int = function(str) {
          let ret2 = 0;
          let digit = 0;
          str = str.replace(/^[0O][Xx]/, "");
          for (let i2 = str.length - 1; i2 >= 0; i2--) {
            const num = _int_at_hex(str[i2], digit++);
            if (num !== null) {
              ret2 += num;
            } else {
              throw new Error("invalid hex " + str);
            }
          }
          function _int_at_hex(c2, digit2) {
            let ret3;
            const ascii = c2.charCodeAt(0);
            if (_ASCII.a <= ascii && ascii <= _ASCII.f) {
              ret3 = ascii - _ASCII.a + 10;
            } else if (_ASCII.A <= ascii && ascii <= _ASCII.F) {
              ret3 = ascii - _ASCII.a + 10;
            } else if (_ASCII[0] < ascii && ascii <= _ASCII[9]) {
              ret3 = ascii - _ASCII[0];
            } else {
              throw new Error(`Invalid ascii [${c2}]`);
            }
            ret3 *= Math.pow(16, digit2);
            return ret3;
          }
          ;
          return ret2;
        };
        const _octal2int = function(str) {
          str = str.replace(/^0/, "");
          let ret2 = 0;
          let digit = 0;
          for (let i2 = str.length - 1; i2 >= 0; i2--) {
            const num = _int_at_octal(str[i2], digit++);
            if (num !== null) {
              ret2 += num;
            } else {
              throw new Error(`invalid octal ${str}`);
            }
          }
          function _int_at_octal(c2, digit2) {
            let num = null;
            const ascii = c2.charCodeAt(0);
            if (ascii >= _ASCII[0] && ascii <= _ASCII[8]) {
              num = ascii - _ASCII[0];
            } else {
              throw new Error(`invalid char at [${c2}]`);
            }
            num *= Math.pow(8, digit2);
            return num;
          }
          ;
          return ret2;
        };
        const _regslashs = (pre) => pre.replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\|/g, "\\|");
        const _strip_slashes = (str) => str.replace(/\\([\sA-Za-z\\]|[0-7]{1,3})/g, function(str2, c2) {
          switch (c2) {
            case "\\":
              return "\\";
            case "0":
              return "\0";
            default:
              if (/^\w$/.test(c2)) {
                return _get_special_char(c2);
              } else if (/^\s$/.test(c2)) {
                return c2;
              } else if (/([0-7]{1,3})/.test(c2)) {
                return _get_ASCII_char(c2);
              }
              return str2;
          }
        });
        function _get_ASCII_char(str) {
          const num = _octal2int(str);
          return String.fromCharCode(num);
        }
        ;
        function _get_special_char(letter) {
          switch (letter.toLowerCase()) {
            case "b":
              return "\b";
            case "f":
              return "\f";
            case "n":
              return "\n";
            case "r":
              return "\r";
            case "t":
              return "	";
            case "v":
              return "\v";
            default:
              return letter;
          }
        }
        ;
        const _get_input = function(pre, next, match, type) {
          let tmp = input_stream;
          let replace = `(${match})`;
          if (type === "STR" && next.trim().length > 0) {
            const before_match = _regslashs(pre);
            const after_match = _regslashs(next) + "[\\w\\W]*";
            if (before_match.length) {
              tmp = tmp.replace(new RegExp(before_match), "");
            }
            tmp = tmp.replace(new RegExp(after_match), "");
          } else {
            replace = _regslashs(pre) + replace;
          }
          const m = tmp.match(new RegExp(replace));
          if (!m) {
            return null;
          }
          const result = m[1];
          input_stream = input_stream.substr(input_stream.indexOf(result)).replace(result, "").replace(next, "");
          return result;
        };
        const _get_integer = function(pre, next) {
          const text2 = _get_input(pre, next, "[-]?[A-Za-z0-9]+");
          if (!text2) {
            return null;
          } else if (text2[0] === "0") {
            if (text2[1] === "x" || text2[1] === "X") {
              return _hex2int(text2);
            } else {
              return _octal2int(text2);
            }
          } else {
            return parseInt(text2, 10);
          }
        };
        const _get_float = function(pre, next) {
          const text2 = _get_input(pre, next, "[-]?[0-9]+[.]?[0-9]*");
          return parseFloat(text2);
        };
        const _get_hex = function(pre, next) {
          const text2 = _get_input(pre, next, "[A-Za-z0-9]+");
          return _hex2int(text2);
        };
        const _get_octal = function(pre, next) {
          const text2 = _get_input(pre, next, "[A-Za-z0-9]+");
          return _octal2int(text2);
        };
        const _get_string = function(pre, next) {
          let text2 = _get_input(pre, next, "([\\w\\]=-]|\\S[^\\][^\\ ])+(\\\\[\\w\\ ][\\w\\:]*)*", "STR");
          if (/\\/.test(text2)) {
            text2 = _strip_slashes(text2);
          }
          return text2;
        };
        const _get_char = function(pre, next) {
          let text2 = _get_input(pre, next, ".", "STR");
          if (/\\/.test(text2)) {
            text2 = _strip_slashes(text2);
          }
          return text2;
        };
        const _get_line = function(pre, next) {
          let text2 = _get_input(pre, next, "[^\n\r]*");
          if (/\\/.test(text2)) {
            text2 = _strip_slashes(text2);
          }
          return text2;
        };
        const _deal_type = function(format) {
          const res = format.match(/%[A-Za-z]+/);
          const res2 = format.match(/[^%]*/);
          if (!res) {
            return null;
          }
          const type = res[0];
          let pre;
          if (!!res2) {
            pre = res2[0];
          } else {
            pre = null;
          }
          const next = format.substr(format.indexOf(type) + type.length);
          let ret2;
          switch (type) {
            case "%d":
            case "%ld":
            case "%llu":
            case "%lu":
            case "%u":
              ret2 = _get_integer(pre, next);
              break;
            case "%c":
              ret2 = _get_char(pre, next);
              break;
            case "%s":
              ret2 = _get_string(pre, next);
              break;
            case "%S":
              ret2 = _get_line(pre, next);
              break;
            case "%x":
            case "%X":
              ret2 = _get_hex(pre, next);
              break;
            case "%o":
            case "%O":
              ret2 = _get_octal(pre, next);
              break;
            case "%f":
              ret2 = _get_float(pre, next);
              break;
            default:
              throw new Error('Unknown type "' + type + '"');
          }
          return ret2;
        };
        const _set_pointer_value = function(pointer, value) {
          try {
            let new_value;
            if (rt2.isNormalPointerType(pointer)) {
              if (rt2.isNumericType(pointer.t.targetType)) {
                new_value = rt2.val(pointer.t.targetType, value, true);
                return pointer.v.target.v = new_value.v;
              } else {
                new_value = rt2.val(pointer.t.targetType, value.charCodeAt(0), true);
                return pointer.v.target.v = new_value.v;
              }
            } else if (rt2.isArrayType(pointer)) {
              const src_array = rt2.makeCharArrayFromString(value);
              if (src_array.v.target.length > pointer.v.target.length) {
                return rt2.raiseException("Not enough memory on pointer");
              } else {
                return __range__(0, src_array.v.target.length, true).map((i2) => (() => {
                  try {
                    return pointer.v.target[i2] = src_array.v.target[i2];
                  } catch (error2) {
                    return rt2.raiseException("Not enough memory on pointer");
                  }
                })());
              }
            } else {
              return rt2.raiseException("Invalid Pointer Type");
            }
          } catch (error1) {
            return rt2.raiseException("Memory overflow");
          }
        };
        const __scanf = function(format) {
          const re = new RegExp("[^%]*%[A-Za-z][^%]*", "g");
          const selectors = format.match(re);
          return Array.from(selectors).map((val) => _deal_type(val));
        };
        const _scanf = function(rt3, _this2, pchar2, ...args) {
          let val;
          const format = rt3.getStringFromCharArray(pchar2);
          const matched_values = __scanf(format);
          for (let i2 = 0; i2 < matched_values.length; i2++) {
            val = matched_values[i2];
            _set_pointer_value(args[i2], val);
          }
          return rt3.val(rt3.intTypeLiteral, matched_values.length);
        };
        rt2.regFunc(_scanf, "global", "scanf", [char_pointer, "?"], rt2.intTypeLiteral);
        const _sscanf = function(rt3, _this2, original_string_pointer, format_pointer, ...args) {
          let val;
          const format = rt3.getStringFromCharArray(format_pointer);
          const original_string = rt3.getStringFromCharArray(original_string_pointer);
          const original_input_stream = input_stream;
          input_stream = original_string;
          const matched_values = __scanf(format);
          for (let i2 = 0; i2 < matched_values.length; i2++) {
            val = matched_values[i2];
            _set_pointer_value(args[i2], val);
          }
          input_stream = original_input_stream;
          return rt3.val(rt3.intTypeLiteral, matched_values.length);
        };
        return rt2.regFunc(_sscanf, "global", "sscanf", [char_pointer, char_pointer, "?"], rt2.intTypeLiteral);
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/cstdlib.js
var require_cstdlib = __commonJS({
  "node_modules/JSCPP/lib/includes/cstdlib.js"(exports, module) {
    "use strict";
    module.exports = {
      load(rt) {
        let m_w = 123456789;
        let m_z = 987654321;
        const mask = 4294967295;
        const seed = (i2) => m_w = i2;
        const random = function() {
          m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
          m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
          const result = (m_z << 16) + m_w & mask;
          return result / 4294967296 + 0.5;
        };
        const pchar = rt.normalPointerType(rt.charTypeLiteral);
        const _atof = function(rt2, _this2, str) {
          if (rt2.isStringType(str.t)) {
            const s2 = rt2.getStringFromCharArray(str);
            const val = Number.parseFloat(s2);
            return rt2.val(rt2.floatTypeLiteral, val);
          } else {
            return rt2.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atof, "global", "atof", [pchar], rt.floatTypeLiteral);
        const _atoi = function(rt2, _this2, str) {
          if (rt2.isStringType(str.t)) {
            const s2 = rt2.getStringFromCharArray(str);
            const val = Number.parseInt(s2, 10);
            return rt2.val(rt2.intTypeLiteral, val);
          } else {
            return rt2.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atoi, "global", "atoi", [pchar], rt.intTypeLiteral);
        const _atol = function(rt2, _this2, str) {
          if (rt2.isStringType(str.t)) {
            const s2 = rt2.getStringFromCharArray(str);
            const val = Number.parseInt(s2, 10);
            return rt2.val(rt2.longTypeLiteral, val);
          } else {
            return rt2.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atol, "global", "atol", [pchar], rt.longTypeLiteral);
        if (rt.scope[0].variables["RAND_MAX"] == null) {
          rt.scope[0].variables["RAND_MAX"] = rt.val(rt.intTypeLiteral, 2147483647);
        }
        const _rand = function(rt2, _this2) {
          const val = Math.floor(random() * (rt2.scope[0].variables["RAND_MAX"].v + 1));
          return rt2.val(rt2.intTypeLiteral, val);
        };
        rt.regFunc(_rand, "global", "rand", [], rt.intTypeLiteral);
        const _srand = (rt2, _this2, i2) => seed(i2.v);
        rt.regFunc(_srand, "global", "srand", [rt.unsignedintTypeLiteral], rt.voidTypeLiteral);
        const _system = function(rt, _this, command) {
          if (command === rt.nullPointer) {
            return rt.val(rt.intTypeLiteral, 1);
          } else if (rt.isStringType(command)) {
            const s = rt.getStringFromCharArray(command);
            try {
              const ret = eval(s);
              if (ret != null) {
                console.log(ret);
              }
              return rt.val(rt.intTypeLiteral, 1);
            } catch (e) {
              return rt.val(rt.intTypeLiteral, 0);
            }
          } else {
            return rt.raiseException("command is not a string");
          }
        };
        rt.regFunc(_system, "global", "system", [pchar], rt.intTypeLiteral);
        rt.scope[0].variables["NULL"] = rt.nullPointer;
        function binary_search(val, L, cmp) {
          if (L.length === 0) {
            return false;
          }
          const mid = Math.floor(L.length / 2);
          const cmpResult = cmp(val, L[mid], mid);
          if (cmpResult === 0) {
            return mid;
          } else if (cmpResult > 0) {
            return binary_search(val, L.slice(mid + 1, +L.length + 1 || void 0), cmp);
          } else {
            return binary_search(val, L.slice(0, +(mid - 1) + 1 || void 0), cmp);
          }
        }
        ;
        const _bsearch = function(rt2, _this2, key, base, num, size, cmp) {
          if (rt2.isArrayType(base)) {
            const L = base.v.target;
            const val = key;
            const wrapper = function(a2, b2, indexB) {
              const pbType = base.t;
              const pbVal = rt2.makeArrayPointerValue(L, indexB);
              const pointerB = rt2.val(pbType, pbVal);
              return cmp.v.target.v.target(rt2, null, a2, pointerB).v;
            };
            const bsRet = binary_search(val, L, wrapper);
            if (bsRet === false) {
              return rt2.nullPointer;
            } else {
              return rt2.val(base.t, rt2.makeArrayPointerValue(L, bsRet));
            }
          } else {
            return rt2.raiseException("base must be an array");
          }
        };
        const cmpType = rt.functionPointerType(rt.intTypeLiteral, [rt.voidPointerType, rt.voidPointerType]);
        rt.regFunc(_bsearch, "global", "bsearch", [rt.voidPointerType, rt.voidPointerType, rt.intTypeLiteral, rt.intTypeLiteral, cmpType], rt.voidPointerType);
        const _qsort = function(rt2, _this2, base, num, size, cmp) {
          if (rt2.isArrayType(base)) {
            const L = base.v.target;
            for (let i2 = 0; i2 < L.length; i2++) {
              const ele = L[i2];
              ele.arrayIndex = i2;
            }
            const wrapper = function(a2, b2) {
              const pType = base.t;
              const pbVal = rt2.makeArrayPointerValue(L, b2.arrayIndex);
              const paVal = rt2.makeArrayPointerValue(L, a2.arrayIndex);
              const pointerB = rt2.val(pType, pbVal);
              const pointerA = rt2.val(pType, pbVal);
              return cmp.v.target.v.target(rt2, null, pointerA, pointerB).v;
            };
            L.sort(wrapper);
            return;
          } else {
            return rt2.raiseException("base must be an array");
          }
        };
        rt.regFunc(_qsort, "global", "qsort", [rt.voidPointerType, rt.intTypeLiteral, rt.intTypeLiteral, cmpType], rt.voidTypeLiteral);
        const _abs = (rt2, _this2, n) => rt2.val(rt2.intTypeLiteral, Math.abs(n.v));
        rt.regFunc(_abs, "global", "abs", [rt.intTypeLiteral], rt.intTypeLiteral);
        const _div = function(rt2, _this2, numer, denom) {
          if (denom.v === 0) {
            rt2.raiseException("divided by zero");
          }
          const quot = rt2.val(rt2.intTypeLiteral, Math.floor(numer.v / denom.v));
          const rem = rt2.val(rt2.intTypeLiteral, numer.v % denom.v);
          return {
            t: div_t_t,
            v: {
              members: {
                quot,
                rem
              }
            }
          };
        };
        const div_t_t = rt.newClass("div_t", [
          {
            type: rt.intTypeLiteral,
            name: "quot"
          },
          {
            type: rt.intTypeLiteral,
            name: "rem"
          }
        ]);
        rt.regFunc(_div, "global", "div", [rt.intTypeLiteral, rt.intTypeLiteral], div_t_t);
        const _labs = (rt2, _this2, n) => rt2.val(rt2.longTypeLiteral, Math.abs(n.v));
        rt.regFunc(_labs, "global", "labs", [rt.longTypeLiteral], rt.longTypeLiteral);
        const _ldiv = function(rt2, _this2, numer, denom) {
          if (denom.v === 0) {
            rt2.raiseException("divided by zero");
          }
          const quot = rt2.val(rt2.longTypeLiteral, Math.floor(numer.v / denom.v));
          const rem = rt2.val(rt2.longTypeLiteral, numer.v % denom.v);
          return {
            t: ldiv_t_t,
            v: {
              members: {
                quot,
                rem
              }
            }
          };
        };
        const ldiv_t_t = rt.newClass("ldiv_t", [
          {
            type: rt.longTypeLiteral,
            name: "quot"
          },
          {
            type: rt.longTypeLiteral,
            name: "rem"
          }
        ]);
        return rt.regFunc(_ldiv, "global", "ldiv", [rt.longTypeLiteral, rt.longTypeLiteral], ldiv_t_t);
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/ctime.js
var require_ctime = __commonJS({
  "node_modules/JSCPP/lib/includes/ctime.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      load(rt2) {
        const _time = function(rt3, _this2, i2) {
          const val = Math.floor(Date.now() / 1e3);
          return rt3.val(rt3.intTypeLiteral, val);
        };
        return rt2.regFunc(_time, "global", "time", [rt2.longTypeLiteral], rt2.longTypeLiteral);
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/iomanip.js
var require_iomanip = __commonJS({
  "node_modules/JSCPP/lib/includes/iomanip.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      load(rt2) {
        const type = rt2.newClass("iomanipulator", []);
        const oType = rt2.simpleType("ostream");
        const _setprecesion = (rt3, _this2, x) => ({
          t: type,
          v: {
            name: "setprecision",
            f(config) {
              config.setprecision = x.v;
            }
          },
          left: false
        });
        rt2.regFunc(_setprecesion, "global", "setprecision", [rt2.intTypeLiteral], type);
        const _fixed = {
          t: type,
          v: {
            name: "fixed",
            f(config) {
              config.fixed = true;
            }
          }
        };
        rt2.scope[0].variables["fixed"] = _fixed;
        const _setw = (rt3, _this2, x) => ({
          t: type,
          v: {
            name: "setw",
            f(config) {
              config.setw = x.v;
            }
          }
        });
        rt2.regFunc(_setw, "global", "setw", [rt2.intTypeLiteral], type);
        const _setfill = (rt3, _this2, x) => ({
          t: type,
          v: {
            name: "setfill",
            f(config) {
              config.setfill = String.fromCharCode(x.v);
            }
          }
        });
        rt2.regFunc(_setfill, "global", "setfill", [rt2.charTypeLiteral], type);
        const _addManipulator = function(rt3, _cout, m) {
          if (!_cout.manipulators) {
            _cout.manipulators = {
              config: {},
              active: {},
              use(o) {
                let tarStr;
                if (rt3.isNumericType(o) && rt3.isFloatType(o)) {
                  if (this.active.fixed) {
                    const prec = this.active.setprecision != null ? this.config.setprecision : 6;
                    tarStr = o.v.toFixed(prec);
                  } else if (this.active.setprecision != null) {
                    tarStr = o.v.toPrecision(this.config.setprecision).replace(/0+$/, "");
                  }
                }
                if (this.active.setw != null) {
                  let fill;
                  if (this.active.setfill != null) {
                    fill = this.config.setfill;
                  } else {
                    fill = " ";
                  }
                  if (!(rt3.isTypeEqualTo(o.t, rt3.charTypeLiteral) && (o.v === 10 || o.v === 13))) {
                    if (!tarStr) {
                      tarStr = rt3.isPrimitiveType(o) ? o.t.name.indexOf("char") >= 0 ? String.fromCharCode(o.v) : o.t.name === "bool" ? o.v ? "1" : "0" : o.v.toString() : rt3.isStringType(o) ? rt3.getStringFromCharArray(o) : rt3.raiseException("<< operator in ostream cannot accept " + rt3.makeTypeString(o.t));
                    }
                    for (let i2 = 0, end = this.config.setw - tarStr.length; i2 < end; i2++) {
                      tarStr = fill + tarStr;
                    }
                    delete this.active.setw;
                  }
                }
                if (tarStr != null) {
                  return rt3.makeCharArrayFromString(tarStr);
                } else {
                  return o;
                }
              }
            };
          }
          m.v.f(_cout.manipulators.config);
          _cout.manipulators.active[m.v.name] = m.v.f;
          return _cout;
        };
        rt2.regOperator(_addManipulator, oType, "<<", [type], oType);
      }
    };
  }
});

// node_modules/JSCPP/lib/includes/dummy_class_foo.js
var require_dummy_class_foo = __commonJS({
  "node_modules/JSCPP/lib/includes/dummy_class_foo.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      load(rt2) {
        const type = rt2.newClass("Foo", [
          {
            name: "x",
            type: rt2.intTypeLiteral,
            initialize(rt3, _this2) {
              return rt3.val(rt3.intTypeLiteral, 2, true);
            }
          },
          {
            name: "y",
            type: rt2.intTypeLiteral,
            initialize(rt3, _this2) {
              return rt3.val(rt3.intTypeLiteral, -2, true);
            }
          }
        ]);
        const typeSig = rt2.getTypeSignature(type);
        rt2.types[typeSig].father = "object";
        const _plusX = function(rt3, _this2, a2) {
          const newValue = _this2.v.members["x"].v + a2.v;
          return rt3.val(rt3.intTypeLiteral, newValue, false);
        };
        return rt2.regFunc(_plusX, type, "plusX", [rt2.intTypeLiteral], rt2.intTypeLiteral);
      }
    };
  }
});

// node_modules/JSCPP/lib/launcher.js
var require_launcher = __commonJS({
  "node_modules/JSCPP/lib/launcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var rt_1 = require_rt();
    var interpreter_1 = require_interpreter();
    var ast = require_ast();
    var preprocessor = require_preprocessor();
    var debugger_1 = require_debugger();
    var PEGUtil = require_PEGUtil();
    var includes = {
      iostream: require_iostream(),
      cctype: require_cctype(),
      cstring: require_cstring(),
      cmath: require_cmath(),
      cstdio: require_cstdio(),
      cstdlib: require_cstdlib(),
      ctime: require_ctime(),
      iomanip: require_iomanip(),
      foo: require_dummy_class_foo()
    };
    var headerAlias = {
      "ctype.h": "cctype",
      "string.h": "cstring",
      "math.h": "cmath",
      "stdio.h": "cstdio",
      "stdlib.h": "cstdlib",
      "time.h": "ctime"
    };
    for (const alias of Object.keys(headerAlias)) {
      const realName = headerAlias[alias];
      includes[alias] = includes[realName];
    }
    function run2(code, input2, config) {
      let step;
      let inputbuffer = input2.toString();
      const _config = {
        stdio: {
          drain() {
            const x = inputbuffer;
            inputbuffer = null;
            return x;
          },
          write(s2) {
            process.stdout.write(s2);
          }
        },
        includes: this.includes,
        unsigned_overflow: "error"
      };
      rt_1.mergeConfig(_config, config);
      const rt2 = new rt_1.CRuntime(_config);
      code = code.toString();
      const oldCode = code;
      code = preprocessor.parse(rt2, code);
      const mydebugger = new debugger_1.default(code, oldCode);
      const result = PEGUtil.parse(ast, code);
      if (result.error != null) {
        throw new Error("ERROR: Parsing Failure:\n" + PEGUtil.errorMessage(result.error, true));
      }
      const interpreter = new interpreter_1.Interpreter(rt2);
      const defGen = interpreter.run(result.ast, code);
      while (true) {
        step = defGen.next();
        if (step.done) {
          break;
        }
      }
      const mainGen = rt2.getFunc("global", "main", [])(rt2, null);
      if (_config.debug) {
        mydebugger.start(rt2, mainGen);
        return mydebugger;
      } else {
        const startTime = Date.now();
        while (true) {
          step = mainGen.next();
          if (step.done) {
            break;
          }
          if (_config.maxTimeout && Date.now() - startTime > _config.maxTimeout) {
            throw new Error("Time limit exceeded.");
          }
        }
        return step.value.v;
      }
    }
    exports2.default = {
      includes,
      run: run2
    };
  }
});

// node_modules/JSCPP/lib/commonjs.js
var require_commonjs = __commonJS({
  "node_modules/JSCPP/lib/commonjs.js"(exports2, module2) {
    module2.exports = require_launcher().default;
  }
});

// node_modules/readline-sync/lib/readline-sync.js
var require_readline_sync = __commonJS({
  "node_modules/readline-sync/lib/readline-sync.js"(exports2) {
    "use strict";
    var IS_WIN = process.platform === "win32";
    var ALGORITHM_CIPHER = "aes-256-cbc";
    var ALGORITHM_HASH = "sha256";
    var DEFAULT_ERR_MSG = "The current environment doesn't support interactive reading from TTY.";
    var fs2 = require("fs");
    var TTY = process.binding("tty_wrap").TTY;
    var childProc = require("child_process");
    var pathUtil = require("path");
    var defaultOptions = {
      prompt: "> ",
      hideEchoBack: false,
      mask: "*",
      limit: [],
      limitMessage: "Input another, please.$<( [)limit(])>",
      defaultInput: "",
      trueValue: [],
      falseValue: [],
      caseSensitive: false,
      keepWhitespace: false,
      encoding: "utf8",
      bufferSize: 1024,
      print: void 0,
      history: true,
      cd: false,
      phContent: void 0,
      preCheck: void 0
    };
    var fdR = "none";
    var fdW;
    var ttyR;
    var isRawMode = false;
    var extHostPath;
    var extHostArgs;
    var tempdir;
    var salt = 0;
    var lastInput = "";
    var inputHistory = [];
    var rawInput;
    var _DBG_useExt = false;
    var _DBG_checkOptions = false;
    var _DBG_checkMethod = false;
    function getHostArgs(options2) {
      function encodeArg(arg) {
        return arg.replace(/[^\w\u0080-\uFFFF]/g, function(chr) {
          return "#" + chr.charCodeAt(0) + ";";
        });
      }
      return extHostArgs.concat(function(conf) {
        var args = [];
        Object.keys(conf).forEach(function(optionName) {
          if (conf[optionName] === "boolean") {
            if (options2[optionName]) {
              args.push("--" + optionName);
            }
          } else if (conf[optionName] === "string") {
            if (options2[optionName]) {
              args.push("--" + optionName, encodeArg(options2[optionName]));
            }
          }
        });
        return args;
      }({
        display: "string",
        displayOnly: "boolean",
        keyIn: "boolean",
        hideEchoBack: "boolean",
        mask: "string",
        limit: "string",
        caseSensitive: "boolean"
      }));
    }
    function _execFileSync(options2, execOptions) {
      function getTempfile(name) {
        var filepath, suffix = "", fd;
        tempdir = tempdir || require("os").tmpdir();
        while (true) {
          filepath = pathUtil.join(tempdir, name + suffix);
          try {
            fd = fs2.openSync(filepath, "wx");
          } catch (e) {
            if (e.code === "EEXIST") {
              suffix++;
              continue;
            } else {
              throw e;
            }
          }
          fs2.closeSync(fd);
          break;
        }
        return filepath;
      }
      var hostArgs, shellPath, shellArgs, res = {}, exitCode, extMessage, pathStdout = getTempfile("readline-sync.stdout"), pathStderr = getTempfile("readline-sync.stderr"), pathExit = getTempfile("readline-sync.exit"), pathDone = getTempfile("readline-sync.done"), crypto = require("crypto"), shasum, decipher, password;
      shasum = crypto.createHash(ALGORITHM_HASH);
      shasum.update("" + process.pid + salt++ + Math.random());
      password = shasum.digest("hex");
      decipher = crypto.createDecipher(ALGORITHM_CIPHER, password);
      hostArgs = getHostArgs(options2);
      if (IS_WIN) {
        shellPath = process.env.ComSpec || "cmd.exe";
        process.env.Q = '"';
        shellArgs = [
          "/V:ON",
          "/S",
          "/C",
          "(%Q%" + shellPath + "%Q% /V:ON /S /C %Q%%Q%" + extHostPath + "%Q%" + hostArgs.map(function(arg) {
            return " %Q%" + arg + "%Q%";
          }).join("") + " & (echo !ERRORLEVEL!)>%Q%" + pathExit + "%Q%%Q%) 2>%Q%" + pathStderr + "%Q% |%Q%" + process.execPath + "%Q% %Q%" + __dirname + "\\encrypt.js%Q% %Q%" + ALGORITHM_CIPHER + "%Q% %Q%" + password + "%Q% >%Q%" + pathStdout + "%Q% & (echo 1)>%Q%" + pathDone + "%Q%"
        ];
      } else {
        shellPath = "/bin/sh";
        shellArgs = [
          "-c",
          '("' + extHostPath + '"' + hostArgs.map(function(arg) {
            return " '" + arg.replace(/'/g, "'\\''") + "'";
          }).join("") + '; echo $?>"' + pathExit + '") 2>"' + pathStderr + '" |"' + process.execPath + '" "' + __dirname + '/encrypt.js" "' + ALGORITHM_CIPHER + '" "' + password + '" >"' + pathStdout + '"; echo 1 >"' + pathDone + '"'
        ];
      }
      if (_DBG_checkMethod) {
        _DBG_checkMethod("_execFileSync", hostArgs);
      }
      try {
        childProc.spawn(shellPath, shellArgs, execOptions);
      } catch (e) {
        res.error = new Error(e.message);
        res.error.method = "_execFileSync - spawn";
        res.error.program = shellPath;
        res.error.args = shellArgs;
      }
      while (fs2.readFileSync(pathDone, { encoding: options2.encoding }).trim() !== "1") {
      }
      if ((exitCode = fs2.readFileSync(pathExit, { encoding: options2.encoding }).trim()) === "0") {
        res.input = decipher.update(fs2.readFileSync(pathStdout, { encoding: "binary" }), "hex", options2.encoding) + decipher.final(options2.encoding);
      } else {
        extMessage = fs2.readFileSync(pathStderr, { encoding: options2.encoding }).trim();
        res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? "\n" + extMessage : ""));
        res.error.method = "_execFileSync";
        res.error.program = shellPath;
        res.error.args = shellArgs;
        res.error.extMessage = extMessage;
        res.error.exitCode = +exitCode;
      }
      fs2.unlinkSync(pathStdout);
      fs2.unlinkSync(pathStderr);
      fs2.unlinkSync(pathExit);
      fs2.unlinkSync(pathDone);
      return res;
    }
    function readlineExt(options2) {
      var hostArgs, res = {}, extMessage, execOptions = { env: process.env, encoding: options2.encoding };
      if (!extHostPath) {
        if (IS_WIN) {
          if (process.env.PSModulePath) {
            extHostPath = "powershell.exe";
            extHostArgs = ["-ExecutionPolicy", "Bypass", "-File", __dirname + "\\read.ps1"];
          } else {
            extHostPath = "cscript.exe";
            extHostArgs = ["//nologo", __dirname + "\\read.cs.js"];
          }
        } else {
          extHostPath = "/bin/sh";
          extHostArgs = [__dirname + "/read.sh"];
        }
      }
      if (IS_WIN && !process.env.PSModulePath) {
        execOptions.stdio = [process.stdin];
      }
      if (childProc.execFileSync) {
        hostArgs = getHostArgs(options2);
        if (_DBG_checkMethod) {
          _DBG_checkMethod("execFileSync", hostArgs);
        }
        try {
          res.input = childProc.execFileSync(extHostPath, hostArgs, execOptions);
        } catch (e) {
          extMessage = e.stderr ? (e.stderr + "").trim() : "";
          res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? "\n" + extMessage : ""));
          res.error.method = "execFileSync";
          res.error.program = extHostPath;
          res.error.args = hostArgs;
          res.error.extMessage = extMessage;
          res.error.exitCode = e.status;
          res.error.code = e.code;
          res.error.signal = e.signal;
        }
      } else {
        res = _execFileSync(options2, execOptions);
      }
      if (!res.error) {
        res.input = res.input.replace(/^\s*'|'\s*$/g, "");
        options2.display = "";
      }
      return res;
    }
    function _readlineSync(options2) {
      var input2 = "", displaySave = options2.display, silent = !options2.display && options2.keyIn && options2.hideEchoBack && !options2.mask;
      function tryExt() {
        var res = readlineExt(options2);
        if (res.error) {
          throw res.error;
        }
        return res.input;
      }
      if (_DBG_checkOptions) {
        _DBG_checkOptions(options2);
      }
      (function() {
        var fsB, constants, verNum;
        function getFsB() {
          if (!fsB) {
            fsB = process.binding("fs");
            constants = process.binding("constants");
          }
          return fsB;
        }
        if (typeof fdR !== "string") {
          return;
        }
        fdR = null;
        if (IS_WIN) {
          verNum = function(ver) {
            var nums = ver.replace(/^\D+/, "").split(".");
            var verNum2 = 0;
            if (nums[0] = +nums[0]) {
              verNum2 += nums[0] * 1e4;
            }
            if (nums[1] = +nums[1]) {
              verNum2 += nums[1] * 100;
            }
            if (nums[2] = +nums[2]) {
              verNum2 += nums[2];
            }
            return verNum2;
          }(process.version);
          if (!(verNum >= 20302 && verNum < 40204 || verNum >= 5e4 && verNum < 50100 || verNum >= 50600 && verNum < 60200) && process.stdin.isTTY) {
            process.stdin.pause();
            fdR = process.stdin.fd;
            ttyR = process.stdin._handle;
          } else {
            try {
              fdR = getFsB().open("CONIN$", constants.O_RDWR, parseInt("0666", 8));
              ttyR = new TTY(fdR, true);
            } catch (e) {
            }
          }
          if (process.stdout.isTTY) {
            fdW = process.stdout.fd;
          } else {
            try {
              fdW = fs2.openSync("\\\\.\\CON", "w");
            } catch (e) {
            }
            if (typeof fdW !== "number") {
              try {
                fdW = getFsB().open("CONOUT$", constants.O_RDWR, parseInt("0666", 8));
              } catch (e) {
              }
            }
          }
        } else {
          if (process.stdin.isTTY) {
            process.stdin.pause();
            try {
              fdR = fs2.openSync("/dev/tty", "r");
              ttyR = process.stdin._handle;
            } catch (e) {
            }
          } else {
            try {
              fdR = fs2.openSync("/dev/tty", "r");
              ttyR = new TTY(fdR, false);
            } catch (e) {
            }
          }
          if (process.stdout.isTTY) {
            fdW = process.stdout.fd;
          } else {
            try {
              fdW = fs2.openSync("/dev/tty", "w");
            } catch (e) {
            }
          }
        }
      })();
      (function() {
        var atEol, limit, isCooked = !options2.hideEchoBack && !options2.keyIn, buffer, reqSize, readSize, chunk, line;
        rawInput = "";
        function setRawMode(mode) {
          if (mode === isRawMode) {
            return true;
          }
          if (ttyR.setRawMode(mode) !== 0) {
            return false;
          }
          isRawMode = mode;
          return true;
        }
        if (_DBG_useExt || !ttyR || typeof fdW !== "number" && (options2.display || !isCooked)) {
          input2 = tryExt();
          return;
        }
        if (options2.display) {
          fs2.writeSync(fdW, options2.display);
          options2.display = "";
        }
        if (options2.displayOnly) {
          return;
        }
        if (!setRawMode(!isCooked)) {
          input2 = tryExt();
          return;
        }
        reqSize = options2.keyIn ? 1 : options2.bufferSize;
        buffer = Buffer.allocUnsafe && Buffer.alloc ? Buffer.alloc(reqSize) : new Buffer(reqSize);
        if (options2.keyIn && options2.limit) {
          limit = new RegExp("[^" + options2.limit + "]", "g" + (options2.caseSensitive ? "" : "i"));
        }
        while (true) {
          readSize = 0;
          try {
            readSize = fs2.readSync(fdR, buffer, 0, reqSize);
          } catch (e) {
            if (e.code !== "EOF") {
              setRawMode(false);
              input2 += tryExt();
              return;
            }
          }
          if (readSize > 0) {
            chunk = buffer.toString(options2.encoding, 0, readSize);
            rawInput += chunk;
          } else {
            chunk = "\n";
            rawInput += String.fromCharCode(0);
          }
          if (chunk && typeof (line = (chunk.match(/^(.*?)[\r\n]/) || [])[1]) === "string") {
            chunk = line;
            atEol = true;
          }
          if (chunk) {
            chunk = chunk.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]/g, "");
          }
          if (chunk && limit) {
            chunk = chunk.replace(limit, "");
          }
          if (chunk) {
            if (!isCooked) {
              if (!options2.hideEchoBack) {
                fs2.writeSync(fdW, chunk);
              } else if (options2.mask) {
                fs2.writeSync(fdW, new Array(chunk.length + 1).join(options2.mask));
              }
            }
            input2 += chunk;
          }
          if (!options2.keyIn && atEol || options2.keyIn && input2.length >= reqSize) {
            break;
          }
        }
        if (!isCooked && !silent) {
          fs2.writeSync(fdW, "\n");
        }
        setRawMode(false);
      })();
      if (options2.print && !silent) {
        options2.print(displaySave + (options2.displayOnly ? "" : (options2.hideEchoBack ? new Array(input2.length + 1).join(options2.mask) : input2) + "\n"), options2.encoding);
      }
      return options2.displayOnly ? "" : lastInput = options2.keepWhitespace || options2.keyIn ? input2 : input2.trim();
    }
    function flattenArray(array, validator) {
      var flatArray = [];
      function _flattenArray(array2) {
        if (array2 == null) {
          return;
        } else if (Array.isArray(array2)) {
          array2.forEach(_flattenArray);
        } else if (!validator || validator(array2)) {
          flatArray.push(array2);
        }
      }
      _flattenArray(array);
      return flatArray;
    }
    function escapePattern(pattern) {
      return pattern.replace(/[\x00-\x7f]/g, function(s2) {
        return "\\x" + ("00" + s2.charCodeAt().toString(16)).substr(-2);
      });
    }
    function margeOptions() {
      var optionsList = Array.prototype.slice.call(arguments), optionNames, fromDefault;
      if (optionsList.length && typeof optionsList[0] === "boolean") {
        fromDefault = optionsList.shift();
        if (fromDefault) {
          optionNames = Object.keys(defaultOptions);
          optionsList.unshift(defaultOptions);
        }
      }
      return optionsList.reduce(function(options2, optionsPart) {
        if (optionsPart == null) {
          return options2;
        }
        if (optionsPart.hasOwnProperty("noEchoBack") && !optionsPart.hasOwnProperty("hideEchoBack")) {
          optionsPart.hideEchoBack = optionsPart.noEchoBack;
          delete optionsPart.noEchoBack;
        }
        if (optionsPart.hasOwnProperty("noTrim") && !optionsPart.hasOwnProperty("keepWhitespace")) {
          optionsPart.keepWhitespace = optionsPart.noTrim;
          delete optionsPart.noTrim;
        }
        if (!fromDefault) {
          optionNames = Object.keys(optionsPart);
        }
        optionNames.forEach(function(optionName) {
          var value;
          if (!optionsPart.hasOwnProperty(optionName)) {
            return;
          }
          value = optionsPart[optionName];
          switch (optionName) {
            case "mask":
            case "limitMessage":
            case "defaultInput":
            case "encoding":
              value = value != null ? value + "" : "";
              if (value && optionName !== "limitMessage") {
                value = value.replace(/[\r\n]/g, "");
              }
              options2[optionName] = value;
              break;
            case "bufferSize":
              if (!isNaN(value = parseInt(value, 10)) && typeof value === "number") {
                options2[optionName] = value;
              }
              break;
            case "displayOnly":
            case "keyIn":
            case "hideEchoBack":
            case "caseSensitive":
            case "keepWhitespace":
            case "history":
            case "cd":
              options2[optionName] = !!value;
              break;
            case "limit":
            case "trueValue":
            case "falseValue":
              options2[optionName] = flattenArray(value, function(value2) {
                var type = typeof value2;
                return type === "string" || type === "number" || type === "function" || value2 instanceof RegExp;
              }).map(function(value2) {
                return typeof value2 === "string" ? value2.replace(/[\r\n]/g, "") : value2;
              });
              break;
            case "print":
            case "phContent":
            case "preCheck":
              options2[optionName] = typeof value === "function" ? value : void 0;
              break;
            case "prompt":
            case "display":
              options2[optionName] = value != null ? value : "";
              break;
          }
        });
        return options2;
      }, {});
    }
    function isMatched(res, comps, caseSensitive) {
      return comps.some(function(comp) {
        var type = typeof comp;
        return type === "string" ? caseSensitive ? res === comp : res.toLowerCase() === comp.toLowerCase() : type === "number" ? parseFloat(res) === comp : type === "function" ? comp(res) : comp instanceof RegExp ? comp.test(res) : false;
      });
    }
    function replaceHomePath(path, expand) {
      var homePath = pathUtil.normalize(IS_WIN ? (process.env.HOMEDRIVE || "") + (process.env.HOMEPATH || "") : process.env.HOME || "").replace(/[\/\\]+$/, "");
      path = pathUtil.normalize(path);
      return expand ? path.replace(/^~(?=\/|\\|$)/, homePath) : path.replace(new RegExp("^" + escapePattern(homePath) + "(?=\\/|\\\\|$)", IS_WIN ? "i" : ""), "~");
    }
    function replacePlaceholder(text2, generator) {
      var PTN_INNER = "(?:\\(([\\s\\S]*?)\\))?(\\w+|.-.)(?:\\(([\\s\\S]*?)\\))?", rePlaceholder = new RegExp("(\\$)?(\\$<" + PTN_INNER + ">)", "g"), rePlaceholderCompat = new RegExp("(\\$)?(\\$\\{" + PTN_INNER + "\\})", "g");
      function getPlaceholderText(s2, escape, placeholder, pre, param, post) {
        var text3;
        return escape || typeof (text3 = generator(param)) !== "string" ? placeholder : text3 ? (pre || "") + text3 + (post || "") : "";
      }
      return text2.replace(rePlaceholder, getPlaceholderText).replace(rePlaceholderCompat, getPlaceholderText);
    }
    function array2charlist(array, caseSensitive, collectSymbols) {
      var values, group = [], groupClass = -1, charCode = 0, symbols = "", suppressed;
      function addGroup(groups, group2) {
        if (group2.length > 3) {
          groups.push(group2[0] + "..." + group2[group2.length - 1]);
          suppressed = true;
        } else if (group2.length) {
          groups = groups.concat(group2);
        }
        return groups;
      }
      values = array.reduce(function(chars, value) {
        return chars.concat((value + "").split(""));
      }, []).reduce(function(groups, curChar) {
        var curGroupClass, curCharCode;
        if (!caseSensitive) {
          curChar = curChar.toLowerCase();
        }
        curGroupClass = /^\d$/.test(curChar) ? 1 : /^[A-Z]$/.test(curChar) ? 2 : /^[a-z]$/.test(curChar) ? 3 : 0;
        if (collectSymbols && curGroupClass === 0) {
          symbols += curChar;
        } else {
          curCharCode = curChar.charCodeAt(0);
          if (curGroupClass && curGroupClass === groupClass && curCharCode === charCode + 1) {
            group.push(curChar);
          } else {
            groups = addGroup(groups, group);
            group = [curChar];
            groupClass = curGroupClass;
          }
          charCode = curCharCode;
        }
        return groups;
      }, []);
      values = addGroup(values, group);
      if (symbols) {
        values.push(symbols);
        suppressed = true;
      }
      return { values, suppressed };
    }
    function joinChunks(chunks, suppressed) {
      return chunks.join(chunks.length > 2 ? ", " : suppressed ? " / " : "/");
    }
    function getPhContent(param, options2) {
      var text2, values, resCharlist = {}, arg;
      if (options2.phContent) {
        text2 = options2.phContent(param, options2);
      }
      if (typeof text2 !== "string") {
        switch (param) {
          case "hideEchoBack":
          case "mask":
          case "defaultInput":
          case "caseSensitive":
          case "keepWhitespace":
          case "encoding":
          case "bufferSize":
          case "history":
          case "cd":
            text2 = !options2.hasOwnProperty(param) ? "" : typeof options2[param] === "boolean" ? options2[param] ? "on" : "off" : options2[param] + "";
            break;
          case "limit":
          case "trueValue":
          case "falseValue":
            values = options2[options2.hasOwnProperty(param + "Src") ? param + "Src" : param];
            if (options2.keyIn) {
              resCharlist = array2charlist(values, options2.caseSensitive);
              values = resCharlist.values;
            } else {
              values = values.filter(function(value) {
                var type = typeof value;
                return type === "string" || type === "number";
              });
            }
            text2 = joinChunks(values, resCharlist.suppressed);
            break;
          case "limitCount":
          case "limitCountNotZero":
            text2 = options2[options2.hasOwnProperty("limitSrc") ? "limitSrc" : "limit"].length;
            text2 = text2 || param !== "limitCountNotZero" ? text2 + "" : "";
            break;
          case "lastInput":
            text2 = lastInput;
            break;
          case "cwd":
          case "CWD":
          case "cwdHome":
            text2 = process.cwd();
            if (param === "CWD") {
              text2 = pathUtil.basename(text2);
            } else if (param === "cwdHome") {
              text2 = replaceHomePath(text2);
            }
            break;
          case "date":
          case "time":
          case "localeDate":
          case "localeTime":
            text2 = new Date()["to" + param.replace(/^./, function(str) {
              return str.toUpperCase();
            }) + "String"]();
            break;
          default:
            if (typeof (arg = (param.match(/^history_m(\d+)$/) || [])[1]) === "string") {
              text2 = inputHistory[inputHistory.length - arg] || "";
            }
        }
      }
      return text2;
    }
    function getPhCharlist(param) {
      var matches = /^(.)-(.)$/.exec(param), text2 = "", from, to, code, step;
      if (!matches) {
        return null;
      }
      from = matches[1].charCodeAt(0);
      to = matches[2].charCodeAt(0);
      step = from < to ? 1 : -1;
      for (code = from; code !== to + step; code += step) {
        text2 += String.fromCharCode(code);
      }
      return text2;
    }
    function parseCl(cl) {
      var reToken = new RegExp(/(\s*)(?:("|')(.*?)(?:\2|$)|(\S+))/g), matches, taken = "", args = [], part;
      cl = cl.trim();
      while (matches = reToken.exec(cl)) {
        part = matches[3] || matches[4] || "";
        if (matches[1]) {
          args.push(taken);
          taken = "";
        }
        taken += part;
      }
      if (taken) {
        args.push(taken);
      }
      return args;
    }
    function toBool(res, options2) {
      return options2.trueValue.length && isMatched(res, options2.trueValue, options2.caseSensitive) ? true : options2.falseValue.length && isMatched(res, options2.falseValue, options2.caseSensitive) ? false : res;
    }
    function getValidLine(options2) {
      var res, forceNext, limitMessage, matches, histInput, args, resCheck;
      function _getPhContent(param) {
        return getPhContent(param, options2);
      }
      function addDisplay(text2) {
        options2.display += (/[^\r\n]$/.test(options2.display) ? "\n" : "") + text2;
      }
      options2.limitSrc = options2.limit;
      options2.displaySrc = options2.display;
      options2.limit = "";
      options2.display = replacePlaceholder(options2.display + "", _getPhContent);
      while (true) {
        res = _readlineSync(options2);
        forceNext = false;
        limitMessage = "";
        if (options2.defaultInput && !res) {
          res = options2.defaultInput;
        }
        if (options2.history) {
          if (matches = /^\s*\!(?:\!|-1)(:p)?\s*$/.exec(res)) {
            histInput = inputHistory[0] || "";
            if (matches[1]) {
              forceNext = true;
            } else {
              res = histInput;
            }
            addDisplay(histInput + "\n");
            if (!forceNext) {
              options2.displayOnly = true;
              _readlineSync(options2);
              options2.displayOnly = false;
            }
          } else if (res && res !== inputHistory[inputHistory.length - 1]) {
            inputHistory = [res];
          }
        }
        if (!forceNext && options2.cd && res) {
          args = parseCl(res);
          switch (args[0].toLowerCase()) {
            case "cd":
              if (args[1]) {
                try {
                  process.chdir(replaceHomePath(args[1], true));
                } catch (e) {
                  addDisplay(e + "");
                }
              }
              forceNext = true;
              break;
            case "pwd":
              addDisplay(process.cwd());
              forceNext = true;
              break;
          }
        }
        if (!forceNext && options2.preCheck) {
          resCheck = options2.preCheck(res, options2);
          res = resCheck.res;
          if (resCheck.forceNext) {
            forceNext = true;
          }
        }
        if (!forceNext) {
          if (!options2.limitSrc.length || isMatched(res, options2.limitSrc, options2.caseSensitive)) {
            break;
          }
          if (options2.limitMessage) {
            limitMessage = replacePlaceholder(options2.limitMessage, _getPhContent);
          }
        }
        addDisplay((limitMessage ? limitMessage + "\n" : "") + replacePlaceholder(options2.displaySrc + "", _getPhContent));
      }
      return toBool(res, options2);
    }
    exports2._DBG_set_useExt = function(val) {
      _DBG_useExt = val;
    };
    exports2._DBG_set_checkOptions = function(val) {
      _DBG_checkOptions = val;
    };
    exports2._DBG_set_checkMethod = function(val) {
      _DBG_checkMethod = val;
    };
    exports2._DBG_clearHistory = function() {
      lastInput = "";
      inputHistory = [];
    };
    exports2.setDefaultOptions = function(options2) {
      defaultOptions = margeOptions(true, options2);
      return margeOptions(true);
    };
    exports2.question = function(query, options2) {
      return getValidLine(margeOptions(margeOptions(true, options2), {
        display: query
      }));
    };
    exports2.prompt = function(options2) {
      var readOptions = margeOptions(true, options2);
      readOptions.display = readOptions.prompt;
      return getValidLine(readOptions);
    };
    exports2.keyIn = function(query, options2) {
      var readOptions = margeOptions(margeOptions(true, options2), {
        display: query,
        keyIn: true,
        keepWhitespace: true
      });
      readOptions.limitSrc = readOptions.limit.filter(function(value) {
        var type = typeof value;
        return type === "string" || type === "number";
      }).map(function(text2) {
        return replacePlaceholder(text2 + "", getPhCharlist);
      });
      readOptions.limit = escapePattern(readOptions.limitSrc.join(""));
      ["trueValue", "falseValue"].forEach(function(optionName) {
        readOptions[optionName] = readOptions[optionName].reduce(function(comps, comp) {
          var type = typeof comp;
          if (type === "string" || type === "number") {
            comps = comps.concat((comp + "").split(""));
          } else {
            comps.push(comp);
          }
          return comps;
        }, []);
      });
      readOptions.display = replacePlaceholder(readOptions.display + "", function(param) {
        return getPhContent(param, readOptions);
      });
      return toBool(_readlineSync(readOptions), readOptions);
    };
    exports2.questionEMail = function(query, options2) {
      if (query == null) {
        query = "Input e-mail address: ";
      }
      return exports2.question(query, margeOptions({
        hideEchoBack: false,
        limit: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
        limitMessage: "Input valid e-mail address, please.",
        trueValue: null,
        falseValue: null
      }, options2, {
        keepWhitespace: false,
        cd: false
      }));
    };
    exports2.questionNewPassword = function(query, options2) {
      var resCharlist, min, max, readOptions = margeOptions({
        hideEchoBack: true,
        mask: "*",
        limitMessage: "It can include: $<charlist>\nAnd the length must be: $<length>",
        trueValue: null,
        falseValue: null,
        caseSensitive: true
      }, options2, {
        history: false,
        cd: false,
        phContent: function(param) {
          return param === "charlist" ? resCharlist.text : param === "length" ? min + "..." + max : null;
        }
      }), charlist, confirmMessage, unmatchMessage, limit, limitMessage, res1, res2;
      options2 = options2 || {};
      charlist = replacePlaceholder(options2.charlist ? options2.charlist + "" : "$<!-~>", getPhCharlist);
      if (isNaN(min = parseInt(options2.min, 10)) || typeof min !== "number") {
        min = 12;
      }
      if (isNaN(max = parseInt(options2.max, 10)) || typeof max !== "number") {
        max = 24;
      }
      limit = new RegExp("^[" + escapePattern(charlist) + "]{" + min + "," + max + "}$");
      resCharlist = array2charlist([charlist], readOptions.caseSensitive, true);
      resCharlist.text = joinChunks(resCharlist.values, resCharlist.suppressed);
      confirmMessage = options2.confirmMessage != null ? options2.confirmMessage : "Reinput a same one to confirm it: ";
      unmatchMessage = options2.unmatchMessage != null ? options2.unmatchMessage : "It differs from first one. Hit only the Enter key if you want to retry from first one.";
      if (query == null) {
        query = "Input new password: ";
      }
      limitMessage = readOptions.limitMessage;
      while (!res2) {
        readOptions.limit = limit;
        readOptions.limitMessage = limitMessage;
        res1 = exports2.question(query, readOptions);
        readOptions.limit = [res1, ""];
        readOptions.limitMessage = unmatchMessage;
        res2 = exports2.question(confirmMessage, readOptions);
      }
      return res1;
    };
    function _questionNum(query, options2, parser2) {
      var validValue;
      function getValidValue(value) {
        validValue = parser2(value);
        return !isNaN(validValue) && typeof validValue === "number";
      }
      exports2.question(query, margeOptions({
        limitMessage: "Input valid number, please."
      }, options2, {
        limit: getValidValue,
        cd: false
      }));
      return validValue;
    }
    exports2.questionInt = function(query, options2) {
      return _questionNum(query, options2, function(value) {
        return parseInt(value, 10);
      });
    };
    exports2.questionFloat = function(query, options2) {
      return _questionNum(query, options2, parseFloat);
    };
    exports2.questionPath = function(query, options2) {
      var validPath, error2 = "", readOptions = margeOptions({
        hideEchoBack: false,
        limitMessage: "$<error(\n)>Input valid path, please.$<( Min:)min>$<( Max:)max>",
        history: true,
        cd: true
      }, options2, {
        keepWhitespace: false,
        limit: function(value) {
          var exists, stat, res;
          value = replaceHomePath(value, true);
          error2 = "";
          function mkdirParents(dirPath) {
            dirPath.split(/\/|\\/).reduce(function(parents, dir) {
              var path = pathUtil.resolve(parents += dir + pathUtil.sep);
              if (!fs2.existsSync(path)) {
                fs2.mkdirSync(path);
              } else if (!fs2.statSync(path).isDirectory()) {
                throw new Error("Non directory already exists: " + path);
              }
              return parents;
            }, "");
          }
          try {
            exists = fs2.existsSync(value);
            validPath = exists ? fs2.realpathSync(value) : pathUtil.resolve(value);
            if (!options2.hasOwnProperty("exists") && !exists || typeof options2.exists === "boolean" && options2.exists !== exists) {
              error2 = (exists ? "Already exists" : "No such file or directory") + ": " + validPath;
              return false;
            }
            if (!exists && options2.create) {
              if (options2.isDirectory) {
                mkdirParents(validPath);
              } else {
                mkdirParents(pathUtil.dirname(validPath));
                fs2.closeSync(fs2.openSync(validPath, "w"));
              }
              validPath = fs2.realpathSync(validPath);
            }
            if (exists && (options2.min || options2.max || options2.isFile || options2.isDirectory)) {
              stat = fs2.statSync(validPath);
              if (options2.isFile && !stat.isFile()) {
                error2 = "Not file: " + validPath;
                return false;
              } else if (options2.isDirectory && !stat.isDirectory()) {
                error2 = "Not directory: " + validPath;
                return false;
              } else if (options2.min && stat.size < +options2.min || options2.max && stat.size > +options2.max) {
                error2 = "Size " + stat.size + " is out of range: " + validPath;
                return false;
              }
            }
            if (typeof options2.validate === "function" && (res = options2.validate(validPath)) !== true) {
              if (typeof res === "string") {
                error2 = res;
              }
              return false;
            }
          } catch (e) {
            error2 = e + "";
            return false;
          }
          return true;
        },
        phContent: function(param) {
          return param === "error" ? error2 : param !== "min" && param !== "max" ? null : options2.hasOwnProperty(param) ? options2[param] + "" : "";
        }
      });
      options2 = options2 || {};
      if (query == null) {
        query = 'Input path (you can "cd" and "pwd"): ';
      }
      exports2.question(query, readOptions);
      return validPath;
    };
    function getClHandler(commandHandler, options2) {
      var clHandler = {}, hIndex = {};
      if (typeof commandHandler === "object") {
        Object.keys(commandHandler).forEach(function(cmd) {
          if (typeof commandHandler[cmd] === "function") {
            hIndex[options2.caseSensitive ? cmd : cmd.toLowerCase()] = commandHandler[cmd];
          }
        });
        clHandler.preCheck = function(res) {
          var cmdKey;
          clHandler.args = parseCl(res);
          cmdKey = clHandler.args[0] || "";
          if (!options2.caseSensitive) {
            cmdKey = cmdKey.toLowerCase();
          }
          clHandler.hRes = cmdKey !== "_" && hIndex.hasOwnProperty(cmdKey) ? hIndex[cmdKey].apply(res, clHandler.args.slice(1)) : hIndex.hasOwnProperty("_") ? hIndex._.apply(res, clHandler.args) : null;
          return { res, forceNext: false };
        };
        if (!hIndex.hasOwnProperty("_")) {
          clHandler.limit = function() {
            var cmdKey = clHandler.args[0] || "";
            if (!options2.caseSensitive) {
              cmdKey = cmdKey.toLowerCase();
            }
            return hIndex.hasOwnProperty(cmdKey);
          };
        }
      } else {
        clHandler.preCheck = function(res) {
          clHandler.args = parseCl(res);
          clHandler.hRes = typeof commandHandler === "function" ? commandHandler.apply(res, clHandler.args) : true;
          return { res, forceNext: false };
        };
      }
      return clHandler;
    }
    exports2.promptCL = function(commandHandler, options2) {
      var readOptions = margeOptions({
        hideEchoBack: false,
        limitMessage: "Requested command is not available.",
        caseSensitive: false,
        history: true
      }, options2), clHandler = getClHandler(commandHandler, readOptions);
      readOptions.limit = clHandler.limit;
      readOptions.preCheck = clHandler.preCheck;
      exports2.prompt(readOptions);
      return clHandler.args;
    };
    exports2.promptLoop = function(inputHandler, options2) {
      var readOptions = margeOptions({
        hideEchoBack: false,
        trueValue: null,
        falseValue: null,
        caseSensitive: false,
        history: true
      }, options2);
      while (true) {
        if (inputHandler(exports2.prompt(readOptions))) {
          break;
        }
      }
      return;
    };
    exports2.promptCLLoop = function(commandHandler, options2) {
      var readOptions = margeOptions({
        hideEchoBack: false,
        limitMessage: "Requested command is not available.",
        caseSensitive: false,
        history: true
      }, options2), clHandler = getClHandler(commandHandler, readOptions);
      readOptions.limit = clHandler.limit;
      readOptions.preCheck = clHandler.preCheck;
      while (true) {
        exports2.prompt(readOptions);
        if (clHandler.hRes) {
          break;
        }
      }
      return;
    };
    exports2.promptSimShell = function(options2) {
      return exports2.prompt(margeOptions({
        hideEchoBack: false,
        history: true
      }, options2, {
        prompt: function() {
          return IS_WIN ? "$<cwd>>" : (process.env.USER || "") + (process.env.HOSTNAME ? "@" + process.env.HOSTNAME.replace(/\..*$/, "") : "") + ":$<cwdHome>$ ";
        }()
      }));
    };
    function _keyInYN(query, options2, limit) {
      var res;
      if (query == null) {
        query = "Are you sure? ";
      }
      if ((!options2 || options2.guide !== false) && (query += "")) {
        query = query.replace(/\s*:?\s*$/, "") + " [y/n]: ";
      }
      res = exports2.keyIn(query, margeOptions(options2, {
        hideEchoBack: false,
        limit,
        trueValue: "y",
        falseValue: "n",
        caseSensitive: false
      }));
      return typeof res === "boolean" ? res : "";
    }
    exports2.keyInYN = function(query, options2) {
      return _keyInYN(query, options2);
    };
    exports2.keyInYNStrict = function(query, options2) {
      return _keyInYN(query, options2, "yn");
    };
    exports2.keyInPause = function(query, options2) {
      if (query == null) {
        query = "Continue...";
      }
      if ((!options2 || options2.guide !== false) && (query += "")) {
        query = query.replace(/\s+$/, "") + " (Hit any key)";
      }
      exports2.keyIn(query, margeOptions({
        limit: null
      }, options2, {
        hideEchoBack: true,
        mask: ""
      }));
      return;
    };
    exports2.keyInSelect = function(items, query, options2) {
      var readOptions = margeOptions({
        hideEchoBack: false
      }, options2, {
        trueValue: null,
        falseValue: null,
        caseSensitive: false,
        phContent: function(param) {
          return param === "itemsCount" ? items.length + "" : param === "firstItem" ? (items[0] + "").trim() : param === "lastItem" ? (items[items.length - 1] + "").trim() : null;
        }
      }), keylist = "", key2i = {}, charCode = 49, display = "\n";
      if (!Array.isArray(items) || !items.length || items.length > 35) {
        throw "`items` must be Array (max length: 35).";
      }
      items.forEach(function(item, i2) {
        var key = String.fromCharCode(charCode);
        keylist += key;
        key2i[key] = i2;
        display += "[" + key + "] " + (item + "").trim() + "\n";
        charCode = charCode === 57 ? 97 : charCode + 1;
      });
      if (!options2 || options2.cancel !== false) {
        keylist += "0";
        key2i["0"] = -1;
        display += "[0] " + (options2 && options2.cancel != null && typeof options2.cancel !== "boolean" ? (options2.cancel + "").trim() : "CANCEL") + "\n";
      }
      readOptions.limit = keylist;
      display += "\n";
      if (query == null) {
        query = "Choose one from list: ";
      }
      if (query += "") {
        if (!options2 || options2.guide !== false) {
          query = query.replace(/\s*:?\s*$/, "") + " [$<limit>]: ";
        }
        display += query;
      }
      return key2i[exports2.keyIn(display, readOptions).toLowerCase()];
    };
    exports2.getRawInput = function() {
      return rawInput;
    };
    function _setOption(optionName, args) {
      var options2;
      if (args.length) {
        options2 = {};
        options2[optionName] = args[0];
      }
      return exports2.setDefaultOptions(options2)[optionName];
    }
    exports2.setPrint = function() {
      return _setOption("print", arguments);
    };
    exports2.setPrompt = function() {
      return _setOption("prompt", arguments);
    };
    exports2.setEncoding = function() {
      return _setOption("encoding", arguments);
    };
    exports2.setMask = function() {
      return _setOption("mask", arguments);
    };
    exports2.setBufferSize = function() {
      return _setOption("bufferSize", arguments);
    };
  }
});

// node_modules/tau-prolog/modules/core.js
var require_core = __commonJS({
  "node_modules/tau-prolog/modules/core.js"(exports2, module2) {
    (function() {
      var version = { major: 0, minor: 3, patch: 2, status: "beta" };
      function TauFile(name, type, parent, text2) {
        text2 = text2 === void 0 ? "" : text2;
        this.name = name;
        this.type = type;
        this.parent = parent;
        this.text = text2;
        this.created = Date.now() / 1e3;
        this.modified = this.created;
      }
      TauFile.prototype.get = function(length, position) {
        if (position === this.text.length) {
          return "end_of_stream";
        } else if (position > this.text.length) {
          return "end_of_stream";
        } else {
          return this.text.substring(position, position + length);
        }
      };
      TauFile.prototype.eof = function(position) {
        return position === this.text.length;
      };
      TauFile.prototype.put = function(text2, position) {
        if (position === "end_of_stream") {
          this.text += text2;
          return true;
        } else if (position === "past_end_of_stream") {
          return null;
        } else {
          this.text = this.text.substring(0, position) + text2 + this.text.substring(position + text2.length);
          return true;
        }
      };
      TauFile.prototype.get_byte = function(position) {
        if (position === "end_of_stream")
          return -1;
        var index = Math.floor(position / 2);
        if (this.text.length <= index)
          return -1;
        var code = codePointAt(this.text[Math.floor(position / 2)], 0);
        if (position % 2 === 0)
          return code & 255;
        else
          return code / 256 >>> 0;
      };
      TauFile.prototype.put_byte = function(byte, position) {
        var index = position === "end_of_stream" ? this.text.length : Math.floor(position / 2);
        if (this.text.length < index)
          return null;
        var code = this.text.length === index ? -1 : codePointAt(this.text[Math.floor(position / 2)], 0);
        if (position % 2 === 0) {
          code = code / 256 >>> 0;
          code = (code & 255) << 8 | byte & 255;
        } else {
          code = code & 255;
          code = (byte & 255) << 8 | code & 255;
        }
        if (this.text.length === index)
          this.text += fromCodePoint(code);
        else
          this.text = this.text.substring(0, index) + fromCodePoint(code) + this.text.substring(index + 1);
        return true;
      };
      TauFile.prototype.flush = function() {
        return true;
      };
      TauFile.prototype.close = function() {
        this.modified = Date.now() / 1e3;
        return true;
      };
      TauFile.prototype.size = function() {
        return this.text.length;
      };
      function TauDirectory(name, parent) {
        this.name = name;
        this.parent = parent;
        this.files = {};
        this.length = 0;
        this.created = Date.now() / 1e3;
        this.modified = this.created;
      }
      TauDirectory.prototype.lookup = function(file) {
        if (this.files.hasOwnProperty(file))
          return this.files[file];
        return null;
      };
      TauDirectory.prototype.push = function(name, file) {
        if (!this.files.hasOwnProperty(name))
          this.length++;
        this.files[name] = file;
        this.modified = Date.now() / 1e3;
      };
      TauDirectory.prototype.remove = function(name) {
        if (this.files.hasOwnProperty(name)) {
          this.length--;
          delete this.files[name];
          this.modified = Date.now() / 1e3;
        }
      };
      TauDirectory.prototype.empty = function() {
        return this.length === 0;
      };
      TauDirectory.prototype.size = function() {
        return 4096;
      };
      tau_file_system = {
        files: new TauDirectory("/", "/", null),
        open: function(path, type, mode) {
          var dirs = path.replace(/\/$/, "").split("/");
          var dir = tau_file_system.files;
          var name = dirs[dirs.length - 1];
          for (var i2 = 1; i2 < dirs.length - 1; i2++) {
            dir = dir.lookup(dirs[i2]);
            if (!pl.type.is_directory(dir))
              return null;
          }
          var file = dir.lookup(name);
          if (file === null) {
            if (mode === "read")
              return null;
            file = new TauFile(name, type, dir);
            dir.push(name, file);
          } else if (!pl.type.is_file(file)) {
            return null;
          }
          if (mode === "write")
            file.text = "";
          return file;
        },
        get: function(path) {
          var dirs = path.replace(/\/$/, "").split("/");
          var file = tau_file_system.files;
          for (var i2 = 1; i2 < dirs.length; i2++)
            if (pl.type.is_directory(file))
              file = file.lookup(dirs[i2]);
            else
              return null;
          return file;
        }
      };
      tau_user_input = {
        buffer: "",
        get: function(length, _) {
          var text2;
          while (tau_user_input.buffer.length < length) {
            text2 = window.prompt();
            if (text2.length === 0)
              return "end_of_stream";
            if (text2) {
              tau_user_input.buffer += text2;
            }
          }
          text2 = tau_user_input.buffer.substr(0, length);
          tau_user_input.buffer = tau_user_input.buffer.substr(length);
          return text2;
        },
        eof: function(_) {
          return false;
        }
      };
      tau_user_output = {
        put: function(text2, _) {
          console.log(text2);
          return true;
        },
        flush: function() {
          return true;
        }
      };
      tau_user_error = {
        put: function(text2, _) {
          (console.error || console.log)(text2);
          return true;
        },
        flush: function() {
          return true;
        }
      };
      nodejs_file_system = {
        open: function(path, type, mode) {
          var fd, fs2 = require("fs");
          if (mode === "read" && !fs2.existsSync(path))
            return null;
          try {
            fd = fs2.openSync(path, mode[0]);
          } catch (ex) {
            return false;
          }
          return {
            get: function(length, position) {
              var buffer = new Buffer(length);
              fs2.readSync(fd, buffer, 0, length, position);
              var end_of_file = true;
              var text2 = buffer.toString();
              for (var i2 = 0; i2 < length && end_of_file; i2++)
                end_of_file = text2[i2] === "\0";
              return end_of_file ? "end_of_stream" : buffer.toString();
            },
            eof: function(position) {
              var stats = fs2.statSync(path);
              return position === stats["size"];
            },
            put: function(text2, position) {
              var buffer = Buffer.from(text2);
              if (position === "end_of_stream")
                fs2.writeSync(fd, buffer);
              else if (position === "past_end_of_stream")
                return null;
              else
                fs2.writeSync(fd, buffer, 0, buffer.length, position);
              return true;
            },
            get_byte: function(position) {
              try {
                var buffer = Buffer.alloc(1);
                var bytesRead = fs2.readSync(fd, buffer, 0, 1, position);
                var end_of_file = bytesRead < 1;
                return end_of_file ? "end_of_stream" : buffer.readUInt8(0);
              } catch (ex) {
                return "end_of_stream";
              }
            },
            put_byte: function(byte, position) {
              var buffer = Buffer.from([byte]);
              if (position === "end_of_stream")
                fs2.writeSync(fd, buffer);
              else if (position === "past_end_of_stream")
                return null;
              else
                fs2.writeSync(fd, buffer, 0, buffer.length, position);
              return true;
            },
            flush: function() {
              return true;
            },
            close: function() {
              fs2.closeSync(fd);
              return true;
            }
          };
        }
      };
      nodejs_user_input = {
        buffer: "",
        get: function(length, _) {
          var text2;
          var readlineSync = require_readline_sync();
          while (nodejs_user_input.buffer.length < length)
            nodejs_user_input.buffer += readlineSync.question("", { keepWhitespace: true }) + "\n";
          text2 = nodejs_user_input.buffer.substr(0, length);
          nodejs_user_input.buffer = nodejs_user_input.buffer.substr(length);
          return text2;
        },
        eof: function(length) {
          return false;
        }
      };
      nodejs_user_output = {
        put: function(text2, _) {
          process.stdout.write(text2);
          return true;
        },
        flush: function() {
          return true;
        }
      };
      nodejs_user_error = {
        put: function(text2, _) {
          process.stderr.write(text2);
          return true;
        },
        flush: function() {
          return true;
        }
      };
      var indexOf;
      if (!Array.prototype.indexOf) {
        indexOf = function(array, elem) {
          var len = array.length;
          for (var i2 = 0; i2 < len; i2++) {
            if (elem === array[i2])
              return i2;
          }
          return -1;
        };
      } else {
        indexOf = function(array, elem) {
          return array.indexOf(elem);
        };
      }
      var reduce = function(array, fn) {
        if (array.length === 0)
          return void 0;
        var elem = array[0];
        var len = array.length;
        for (var i2 = 1; i2 < len; i2++) {
          elem = fn(elem, array[i2]);
        }
        return elem;
      };
      var map;
      if (!Array.prototype.map) {
        map = function(array, fn) {
          var a2 = [];
          var len = array.length;
          for (var i2 = 0; i2 < len; i2++) {
            a2.push(fn(array[i2]));
          }
          return a2;
        };
      } else {
        map = function(array, fn) {
          return array.map(fn);
        };
      }
      var filter;
      if (!Array.prototype.filter) {
        filter = function(array, fn) {
          var a2 = [];
          var len = array.length;
          for (var i2 = 0; i2 < len; i2++) {
            if (fn(array[i2]))
              a2.push(array[i2]);
          }
          return a2;
        };
      } else {
        filter = function(array, fn) {
          return array.filter(fn);
        };
      }
      var codePointAt;
      if (!String.prototype.codePointAt) {
        codePointAt = function(str, i2) {
          return str.charCodeAt(i2);
        };
      } else {
        codePointAt = function(str, i2) {
          return str.codePointAt(i2);
        };
      }
      var fromCodePoint;
      if (!String.fromCodePoint) {
        fromCodePoint = function() {
          return String.fromCharCode.apply(null, arguments);
        };
      } else {
        fromCodePoint = function() {
          return String.fromCodePoint.apply(null, arguments);
        };
      }
      var stringLength;
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      if (Array.from)
        stringLength = function(str) {
          return Array.from(str).length;
        };
      else
        stringLength = function(str) {
          return str.replace(regexAstralSymbols, "_").length;
        };
      var ERROR = 0;
      var SUCCESS = 1;
      var regex_escape = /(\\a)|(\\b)|(\\d)|(\\e)|(\\f)|(\\n)|(\\r)|(\\s)|(\\t)|(\\v)|\\x([0-9a-fA-F]+)\\|\\([0-7]+)\\|(\\\\)|(\\')|('')|(\\")|(\\`)|(\\.)|(.)/g;
      var escape_map = { "\\a": 7, "\\b": 8, "\\d": 127, "\\e": 27, "\\f": 12, "\\n": 10, "\\r": 13, "\\s": 32, "\\t": 9, "\\v": 11 };
      function escape(str) {
        var stack = [];
        var _error = false;
        str.replace(regex_escape, function(match, a2, b2, d2, e, f, n, r, s2, t, v, hex, octal, back, single, dsingle, double, backquote, error2, char) {
          switch (true) {
            case hex !== void 0:
              stack.push(parseInt(hex, 16));
              return "";
            case octal !== void 0:
              stack.push(parseInt(octal, 8));
              return "";
            case back !== void 0:
            case single !== void 0:
            case dsingle !== void 0:
            case double !== void 0:
            case backquote !== void 0:
              stack.push(codePointAt(match.substr(1), 0));
              return "";
            case char !== void 0:
              stack.push(codePointAt(char, 0));
              return "";
            case error2 !== void 0:
              _error = true;
            default:
              stack.push(escape_map[match]);
              return "";
          }
        });
        if (_error)
          return null;
        return stack;
      }
      function escapeAtom(str, quote) {
        var atom = "";
        if (str === "\\")
          return null;
        if (str.length < 2)
          return str;
        try {
          str = str.replace(/((?:\\\\)+)|\\([0-7]+)\\/g, function(match, g1, g2) {
            return g1 || fromCodePoint(parseInt(g2, 8));
          });
          str = str.replace(/((?:\\\\)+)|\\x([0-9a-fA-F]+)\\/g, function(match, g1, g2) {
            return g1 || fromCodePoint(parseInt(g2, 16));
          });
          str = str.replace(/((?:\\\\)+)|\\u([0-9a-fA-F]{4})/g, function(match, g1, g2) {
            return g1 || fromCodePoint(parseInt(g2, 16));
          });
        } catch (error2) {
          return null;
        }
        for (var i2 = 0; i2 < str.length; i2++) {
          var a2 = str.charAt(i2);
          var b2 = str.charAt(i2 + 1);
          if (a2 === quote && b2 === quote) {
            i2++;
            atom += quote;
          } else if (a2 === "\\") {
            if (["a", "b", "f", "n", "r", "t", "v", "'", '"', "\\", "a", "\b", "\f", "\n", "\r", "	", "\v"].indexOf(b2) !== -1) {
              i2 += 1;
              switch (b2) {
                case "a":
                  atom += "a";
                  break;
                case "b":
                  atom += "\b";
                  break;
                case "f":
                  atom += "\f";
                  break;
                case "n":
                  atom += "\n";
                  break;
                case "r":
                  atom += "\r";
                  break;
                case "t":
                  atom += "	";
                  break;
                case "v":
                  atom += "\v";
                  break;
                case "'":
                  atom += "'";
                  break;
                case '"':
                  atom += '"';
                  break;
                case "\\":
                  atom += "\\";
                  break;
              }
            } else {
              return null;
            }
          } else {
            atom += a2;
          }
        }
        return atom;
      }
      function redoEscape(str) {
        var atom = "";
        for (var i2 = 0; i2 < str.length; i2++) {
          switch (str.charAt(i2)) {
            case "'":
              atom += "\\'";
              break;
            case "\\":
              atom += "\\\\";
              break;
            case "\b":
              atom += "\\b";
              break;
            case "\f":
              atom += "\\f";
              break;
            case "\n":
              atom += "\\n";
              break;
            case "\r":
              atom += "\\r";
              break;
            case "	":
              atom += "\\t";
              break;
            case "\v":
              atom += "\\v";
              break;
            default:
              atom += str.charAt(i2);
              break;
          }
        }
        return atom;
      }
      function convertNum(num) {
        var n = num.substr(2);
        switch (num.substr(0, 2).toLowerCase()) {
          case "0x":
            return parseInt(n, 16);
          case "0b":
            return parseInt(n, 2);
          case "0o":
            return parseInt(n, 8);
          case "0'":
            return escape(n)[0];
          default:
            return parseFloat(num);
        }
      }
      function is_graphic_token(string) {
        return /^[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+/.test(string);
      }
      var rules = {
        whitespace: /^\s*(?:(?:%.*)|(?:\/\*(?:\n|\r|.)*?(?:\*\/|$))|(?:\s+))\s*/,
        variable: /^(?:[A-Z_][a-zA-Z0-9_]*)/,
        atom: /^(\!|,|;|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+|'(?:(?:'')|(?:\\\\)|(?:\\')|[^'])*')/,
        number: /^(?:0o[0-7]+|0x[0-9a-fA-F]+|0b[01]+|0'(?:''|\\[abdefnrstv\\'"`]|\\x?\d+\\|[^\\])|\d+(?:\.\d+(?:[eE][+-]?\d+)?)?)/,
        string: /^(?:"([^"]|""|\\")*"|`([^`]|``|\\`)*`)/,
        l_brace: /^(?:\[)/,
        r_brace: /^(?:\])/,
        l_bracket: /^(?:\{)/,
        r_bracket: /^(?:\})/,
        bar: /^(?:\|)/,
        l_paren: /^(?:\()/,
        r_paren: /^(?:\))/
      };
      function replace(thread, text2) {
        if (thread.get_flag("char_conversion").id === "on") {
          return text2.replace(/./g, function(char) {
            return thread.get_char_conversion(char);
          });
        }
        return text2;
      }
      function Tokenizer(thread) {
        this.thread = thread;
        this.text = "";
        this.tokens = [];
      }
      Tokenizer.prototype.set_last_tokens = function(tokens) {
        return this.tokens = tokens;
      };
      Tokenizer.prototype.new_text = function(text2) {
        this.text = text2;
        this.tokens = [];
      };
      Tokenizer.prototype.get_tokens = function(init) {
        var text2;
        var len = 0;
        var line = 0;
        var start = 0;
        var tokens = [];
        var last_is_blank;
        if (init) {
          var token = this.tokens[init - 1];
          len = token.len;
          text2 = replace(this.thread, this.text.substr(token.len));
          line = token.line;
          start = token.start;
        } else
          text2 = this.text;
        if (/^\s*$/.test(text2))
          return null;
        while (text2 !== "") {
          var matches = [];
          last_is_blank = false;
          if (/^\n/.exec(text2) !== null) {
            line++;
            start = 0;
            len++;
            text2 = text2.replace(/\n/, "");
            last_is_blank = true;
            continue;
          }
          for (var rule in rules) {
            if (rules.hasOwnProperty(rule)) {
              var matchs = rules[rule].exec(text2);
              if (matchs) {
                matches.push({
                  value: matchs[0],
                  name: rule,
                  matches: matchs
                });
              }
            }
          }
          if (!matches.length)
            return this.set_last_tokens([{ value: text2, matches: [], name: "lexical", line, start }]);
          var token = reduce(matches, function(a2, b2) {
            return a2.value.length >= b2.value.length ? a2 : b2;
          });
          token.start = start;
          token.line = line;
          text2 = text2.replace(token.value, "");
          start += token.value.length;
          len += token.value.length;
          var nl = (token.value.match(/\n/g) || []).length;
          line += nl;
          if (nl > 0)
            start = token.value.length - token.value.lastIndexOf("\n") - 1;
          token.line_count = line;
          token.line_position = start;
          switch (token.name) {
            case "atom":
              token.raw = token.value;
              if (token.value.charAt(0) === "'") {
                token.value = escapeAtom(token.value.substring(1, token.value.length - 1), "'");
                if (token.value === null) {
                  token.name = "lexical";
                  token.value = token.raw;
                  token.error = "unknown_escape_sequence";
                }
              }
              break;
            case "number":
              var substr = token.value.substring(0, 2);
              token.raw = token.value;
              token.float = substr !== "0x" && substr !== "0'" && token.value.match(/[.eE]/) !== null;
              token.value = convertNum(token.value);
              token.blank = last_is_blank;
              if (!token.float && pl.flag.bounded.value.indicator === "true/0" && token.value > pl.flag.max_integer.value.value) {
                token.name = "lexical";
                token.value = token.raw;
                token.error = "int_overflow";
              }
              break;
            case "string":
              var del = token.value.charAt(0);
              token.raw = token.value;
              token.value = escapeAtom(token.value.substring(1, token.value.length - 1), del);
              if (token.value === null) {
                token.name = "lexical";
                token.value = token.raw;
                token.error = "unknown_escape_sequence";
              }
              break;
            case "whitespace":
              var last = tokens[tokens.length - 1];
              if (last)
                last.space = true;
              last_is_blank = true;
              continue;
            case "r_bracket":
              if (tokens.length > 0 && tokens[tokens.length - 1].name === "l_bracket") {
                token = tokens.pop();
                token.name = "atom";
                token.value = "{}";
                token.raw = "{}";
                token.space = false;
              }
              break;
            case "r_brace":
              if (tokens.length > 0 && tokens[tokens.length - 1].name === "l_brace") {
                token = tokens.pop();
                token.name = "atom";
                token.value = "[]";
                token.raw = "[]";
                token.space = false;
              }
              break;
          }
          token.len = len;
          tokens.push(token);
          last_is_blank = false;
        }
        var t = this.set_last_tokens(tokens);
        return t.length === 0 ? null : t;
      };
      function parseExpr(thread, tokens, start, priority, toplevel) {
        if (!tokens[start])
          return { type: ERROR, value: pl.error.syntax(tokens[start - 1], "expression expected", true) };
        var error2;
        if (priority === "0") {
          var token = tokens[start];
          switch (token.name) {
            case "number":
              return { type: SUCCESS, len: start + 1, value: new pl.type.Num(token.value, token.float) };
            case "variable":
              return { type: SUCCESS, len: start + 1, value: new pl.type.Var(token.value) };
            case "string":
              var str;
              switch (thread.get_flag("double_quotes").id) {
                case "atom":
                  ;
                  str = new Term(token.value, []);
                  break;
                case "codes":
                  str = new Term("[]", []);
                  for (var i2 = token.value.length - 1; i2 >= 0; i2--)
                    str = new Term(".", [new pl.type.Num(codePointAt(token.value, i2), false), str]);
                  break;
                case "chars":
                  str = new Term("[]", []);
                  for (var i2 = token.value.length - 1; i2 >= 0; i2--)
                    str = new Term(".", [new pl.type.Term(token.value.charAt(i2), []), str]);
                  break;
              }
              return { type: SUCCESS, len: start + 1, value: str };
            case "l_paren":
              var expr = parseExpr(thread, tokens, start + 1, thread.__get_max_priority(), true);
              if (expr.type !== SUCCESS)
                return expr;
              if (tokens[expr.len] && tokens[expr.len].name === "r_paren") {
                expr.len++;
                return expr;
              }
              return { type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len - 1], ") or operator expected", !tokens[expr.len]) };
            case "l_bracket":
              var expr = parseExpr(thread, tokens, start + 1, thread.__get_max_priority(), true);
              if (expr.type !== SUCCESS)
                return expr;
              if (tokens[expr.len] && tokens[expr.len].name === "r_bracket") {
                expr.len++;
                expr.value = new Term("{}", [expr.value]);
                return expr;
              }
              return { type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len - 1], "} or operator expected", !tokens[expr.len]) };
          }
          var result = parseTerm(thread, tokens, start, toplevel);
          if (result.type === SUCCESS || result.derived)
            return result;
          result = parseList(thread, tokens, start);
          if (result.type === SUCCESS || result.derived)
            return result;
          return { type: ERROR, derived: false, value: pl.error.syntax(tokens[start], token.error || "unexpected token") };
        }
        var max_priority = thread.__get_max_priority();
        var next_priority = thread.__get_next_priority(priority);
        var aux_start = start;
        if (tokens[start].name === "atom" && tokens[start + 1] && (tokens[start].space || tokens[start + 1].name !== "l_paren")) {
          var token = tokens[start++];
          var classes = thread.__lookup_operator_classes(priority, token.value);
          if (classes && classes.indexOf("fy") > -1) {
            var expr = parseExpr(thread, tokens, start, priority, toplevel);
            if (expr.type !== ERROR) {
              if (token.value === "-" && !token.space && pl.type.is_number(expr.value)) {
                return {
                  value: new pl.type.Num(-expr.value.value, expr.value.is_float),
                  len: expr.len,
                  type: SUCCESS
                };
              } else {
                return {
                  value: new pl.type.Term(token.value, [expr.value]),
                  len: expr.len,
                  type: SUCCESS
                };
              }
            } else {
              error2 = expr;
            }
          } else if (classes && classes.indexOf("fx") > -1) {
            var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
            if (expr.type !== ERROR) {
              return {
                value: new pl.type.Term(token.value, [expr.value]),
                len: expr.len,
                type: SUCCESS
              };
            } else {
              error2 = expr;
            }
          }
        }
        start = aux_start;
        var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
        if (expr.type === SUCCESS) {
          start = expr.len;
          var token = tokens[start];
          if (tokens[start] && (tokens[start].name === "atom" && thread.__lookup_operator_classes(priority, token.value) || tokens[start].name === "bar" && thread.__lookup_operator_classes(priority, "|"))) {
            var next_priority_lt = next_priority;
            var next_priority_eq = priority;
            var classes = thread.__lookup_operator_classes(priority, token.value);
            if (classes.indexOf("xf") > -1) {
              return {
                value: new pl.type.Term(token.value, [expr.value]),
                len: ++expr.len,
                type: SUCCESS
              };
            } else if (classes.indexOf("xfx") > -1) {
              var expr2 = parseExpr(thread, tokens, start + 1, next_priority_lt, toplevel);
              if (expr2.type === SUCCESS) {
                return {
                  value: new pl.type.Term(token.value, [expr.value, expr2.value]),
                  len: expr2.len,
                  type: SUCCESS
                };
              } else {
                expr2.derived = true;
                return expr2;
              }
            } else if (classes.indexOf("xfy") > -1) {
              var expr2 = parseExpr(thread, tokens, start + 1, next_priority_eq, toplevel);
              if (expr2.type === SUCCESS) {
                return {
                  value: new pl.type.Term(token.value, [expr.value, expr2.value]),
                  len: expr2.len,
                  type: SUCCESS
                };
              } else {
                expr2.derived = true;
                return expr2;
              }
            } else if (expr.type !== ERROR) {
              while (true) {
                start = expr.len;
                var token = tokens[start];
                if (token && token.name === "atom" && thread.__lookup_operator_classes(priority, token.value)) {
                  var classes = thread.__lookup_operator_classes(priority, token.value);
                  if (classes.indexOf("yf") > -1) {
                    expr = {
                      value: new pl.type.Term(token.value, [expr.value]),
                      len: ++start,
                      type: SUCCESS
                    };
                  } else if (classes.indexOf("yfx") > -1) {
                    var expr2 = parseExpr(thread, tokens, ++start, next_priority_lt, toplevel);
                    if (expr2.type === ERROR) {
                      expr2.derived = true;
                      return expr2;
                    }
                    start = expr2.len;
                    expr = {
                      value: new pl.type.Term(token.value, [expr.value, expr2.value]),
                      len: start,
                      type: SUCCESS
                    };
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
            }
          } else {
            error2 = { type: ERROR, value: pl.error.syntax(tokens[expr.len - 1], "operator expected") };
          }
          return expr;
        }
        return expr;
      }
      function parseTerm(thread, tokens, start, toplevel) {
        if (!tokens[start] || tokens[start].name === "atom" && tokens[start].raw === "." && !toplevel && (tokens[start].space || !tokens[start + 1] || tokens[start + 1].name !== "l_paren"))
          return { type: ERROR, derived: false, value: pl.error.syntax(tokens[start - 1], "unfounded token") };
        var atom = tokens[start];
        var exprs = [];
        if (tokens[start].name === "atom" && tokens[start].raw !== ",") {
          start++;
          if (tokens[start - 1].space)
            return { type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs) };
          if (tokens[start] && tokens[start].name === "l_paren") {
            if (tokens[start + 1] && tokens[start + 1].name === "r_paren")
              return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start + 1], "argument expected") };
            var expr = parseExpr(thread, tokens, ++start, "999", true);
            if (expr.type === ERROR) {
              if (expr.derived)
                return expr;
              else
                return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start - 1], "argument expected", !tokens[start]) };
            }
            exprs.push(expr.value);
            start = expr.len;
            while (tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
              expr = parseExpr(thread, tokens, start + 1, "999", true);
              if (expr.type === ERROR) {
                if (expr.derived)
                  return expr;
                else
                  return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start + 1] ? tokens[start + 1] : tokens[start], "argument expected", !tokens[start + 1]) };
              }
              exprs.push(expr.value);
              start = expr.len;
            }
            if (tokens[start] && tokens[start].name === "r_paren")
              start++;
            else
              return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start - 1], ", or ) expected", !tokens[start]) };
          }
          return { type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs) };
        }
        return { type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "term expected") };
      }
      function parseList(thread, tokens, start) {
        if (!tokens[start])
          return { type: ERROR, derived: false, value: pl.error.syntax(tokens[start - 1], "[ expected") };
        if (tokens[start] && tokens[start].name === "l_brace") {
          var expr = parseExpr(thread, tokens, ++start, "999", true);
          var exprs = [expr.value];
          var cons = void 0;
          if (expr.type === ERROR) {
            if (tokens[start] && tokens[start].name === "r_brace") {
              return { type: SUCCESS, len: start + 1, value: new pl.type.Term("[]", []) };
            }
            return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start], "] expected") };
          }
          start = expr.len;
          while (tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
            expr = parseExpr(thread, tokens, start + 1, "999", true);
            if (expr.type === ERROR) {
              if (expr.derived)
                return expr;
              else
                return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start + 1] ? tokens[start + 1] : tokens[start], "argument expected", !tokens[start + 1]) };
            }
            exprs.push(expr.value);
            start = expr.len;
          }
          var bar = false;
          if (tokens[start] && tokens[start].name === "bar") {
            bar = true;
            expr = parseExpr(thread, tokens, start + 1, "999", true);
            if (expr.type === ERROR) {
              if (expr.derived)
                return expr;
              else
                return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start + 1] ? tokens[start + 1] : tokens[start], "argument expected", !tokens[start + 1]) };
            }
            cons = expr.value;
            start = expr.len;
          }
          if (tokens[start] && tokens[start].name === "r_brace")
            return { type: SUCCESS, len: start + 1, value: arrayToList(exprs, cons) };
          else
            return { type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start - 1], bar ? "] expected" : ", or | or ] expected", !tokens[start]) };
        }
        return { type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "list expected") };
      }
      function parseRule(thread, tokens, start) {
        var line = tokens[start].line;
        var expr = parseExpr(thread, tokens, start, thread.__get_max_priority(), false);
        var rule = null;
        var obj;
        if (expr.type !== ERROR) {
          start = expr.len;
          if (tokens[start] && tokens[start].name === "atom" && tokens[start].raw === ".") {
            start++;
            if (pl.type.is_term(expr.value)) {
              if (expr.value.indicator === ":-/2") {
                rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
                obj = {
                  value: rule,
                  len: start,
                  type: SUCCESS
                };
              } else if (expr.value.indicator === "-->/2") {
                rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
                rule = rule_to_dcg(rule, thread);
                rule.body = body_conversion(rule.body);
                if (!pl.type.is_rule(rule))
                  return {
                    value: rule,
                    len: start,
                    type: ERROR
                  };
                obj = {
                  value: rule,
                  len: start,
                  type: pl.type.is_rule(rule) ? SUCCESS : ERROR
                };
              } else {
                rule = new pl.type.Rule(expr.value, null);
                obj = {
                  value: rule,
                  len: start,
                  type: SUCCESS
                };
              }
              if (rule) {
                var singleton = rule.singleton_variables();
                if (singleton.length > 0)
                  thread.throw_warning(pl.warning.singleton(singleton, rule.head.indicator, line));
              }
              return obj;
            } else {
              return { type: ERROR, value: pl.error.syntax(tokens[start], "callable expected") };
            }
          } else {
            return { type: ERROR, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start - 1], ". or operator expected") };
          }
        }
        return expr;
      }
      function parseProgram(thread, string, options2) {
        var opts = {};
        options2 = options2 ? options2 : {};
        opts.success = options2.success ? options2.success : function() {
        };
        opts.error = options2.error ? options2.error : function() {
        };
        opts.from = options2.from ? options2.from : "$tau-js";
        opts.reconsult = options2.reconsult !== void 0 ? options2.reconsult : true;
        opts.reconsulted = options2.reconsulted === void 0 ? {} : options2.reconsulted;
        opts.context_module = options2.context_module === void 0 ? "user" : options2.context_module;
        opts.initialization = options2.initialization === void 0 ? [] : options2.initialization;
        opts.current_token = options2.current_token === void 0 ? 0 : options2.current_token;
        opts.tokenizer = options2.tokenizer === void 0 ? null : options2.tokenizer;
        opts.tokens = options2.tokens === void 0 ? null : options2.tokens;
        opts.string = string;
        opts.term_expansion = false;
        var reconsulted = opts.reconsulted;
        var tokenizer = opts.tokenizer;
        var tokens = opts.tokens;
        if (tokenizer === null) {
          tokenizer = new Tokenizer(thread);
          tokenizer.new_text(string);
          opts.tokenizer = tokenizer;
          tokens = tokenizer.get_tokens(0);
          opts.tokens = tokens;
        }
        var n = opts.current_token;
        while (tokens !== null && tokens[n]) {
          var expr = parseRule(thread, tokens, n);
          opts.current_token = expr.len;
          if (expr.type === ERROR) {
            if (opts.error !== void 0)
              opts.error(new Term("throw", [expr.value]));
            return;
          } else {
            var term_expansion = thread.session.modules.user.rules["term_expansion/2"];
            if (term_expansion && term_expansion.length > 0) {
              opts.term_expansion = true;
              var n_thread = new Thread(thread.session);
              var term = expr.value.body ? new Term(":-", [expr.value.head, expr.value.body]) : expr.value.head;
              thread.session.renamed_variables = {};
              term = term.rename(thread.session);
              n_thread.query("term_expansion(" + term.toString({
                quoted: true
              }) + ", X).");
              n_thread.answer(function(answer) {
                if (answer && !pl.type.is_error(answer) && pl.type.is_term(answer.links["X"])) {
                  var term2 = answer.links["X"];
                  var rule = term2.indicator === ":-/2" ? new Rule(term2.args[0], term2.args[1]) : new Rule(term2, null);
                  parseProgramExpansion(thread, opts, reconsulted, { value: rule, len: expr.len, type: expr.type });
                } else {
                  parseProgramExpansion(thread, opts, reconsulted, expr);
                }
              });
              return;
            } else {
              opts.term_expansion = false;
              var async = parseProgramExpansion(thread, opts, reconsulted, expr);
              if (async)
                return;
              n = expr.len;
            }
          }
        }
        var callback = opts.success;
        var nthread = new Thread(thread.session);
        for (var i2 = opts.initialization.length - 1; i2 > 0; i2--) {
          var next_callback = function(init, callback2) {
            return function(answer) {
              if (answer === null) {
                nthread.answer();
              } else if (pl.type.is_error(answer)) {
                opts.error(answer);
              } else {
                nthread.add_goal(init);
                nthread.answer(callback2);
              }
            };
          }(opts.initialization[i2], callback);
          callback = next_callback;
        }
        if (opts.initialization.length > 0) {
          nthread.add_goal(opts.initialization[0]);
          nthread.answer(callback);
        } else {
          callback();
        }
      }
      function parseGoalExpansion(thread, options2, expr) {
        var n_thread = new Thread(thread.session);
        n_thread.__goal_expansion = true;
        var varterm = thread.next_free_variable();
        var varhead = thread.next_free_variable();
        var goal = varhead + " = " + expr.value.head + ", goal_expansion(" + expr.value.body.toString({
          quoted: true
        }) + ", " + varterm.toString({
          quoted: true
        }) + ").";
        n_thread.query(goal);
        n_thread.answer(function(answer) {
          if (answer && !pl.type.is_error(answer) && answer.links[varterm]) {
            expr.value.head = answer.links[varhead];
            expr.value.body = body_conversion(answer.links[varterm]);
            parseGoalExpansion(thread, options2, expr);
          } else {
            thread.add_rule(expr.value, options2);
            parseProgram(thread, options2.string, options2);
          }
        });
      }
      function parseQueryExpansion(thread, term, options2) {
        var n_thread = new Thread(thread.session);
        n_thread.__goal_expansion = true;
        var varterm = thread.next_free_variable();
        var goal = "goal_expansion(" + term.toString({
          quoted: true
        }) + ", " + varterm.toString({
          quoted: true
        }) + ").";
        n_thread.query(goal);
        var variables = n_thread.head_point().substitution.domain();
        n_thread.answer(function(answer) {
          if (answer && !pl.type.is_error(answer) && answer.links[varterm]) {
            for (var i2 = 0; i2 < variables.length; i2++) {
              if (variables[i2] !== varterm.id && answer.links[variables[i2]]) {
                var subs = new Substitution();
                subs.links[answer.links[variables[i2]]] = variables[i2];
                answer.links[varterm] = answer.links[varterm].apply(subs);
              }
            }
            parseQueryExpansion(thread, body_conversion(answer.links[varterm]), options2);
          } else {
            thread.add_goal(term);
            options2.success(term);
            parseQuery(thread, options2.string, options2);
          }
        });
      }
      function parseProgramExpansion(thread, options2, reconsulted, expr) {
        var async = options2.term_expansion === true;
        if (expr.value.body === null && expr.value.head.indicator === "?-/1") {
          async = true;
          var n_thread = new Thread(thread.session);
          n_thread.add_goal(expr.value.head.args[0]);
          n_thread.answer(function(answer) {
            if (pl.type.is_error(answer)) {
              thread.throw_warning(answer.args[0]);
            } else if (answer === false || answer === null) {
              thread.throw_warning(pl.warning.failed_goal(expr.value.head.args[0], expr.len));
            }
            parseProgram(thread, options2.string, options2);
          });
        } else if (expr.value.body === null && expr.value.head.indicator === ":-/1") {
          var result = thread.run_directive(expr.value.head.args[0], options2);
          async = async || result === true;
        } else {
          var context_module = options2.context_module;
          var indicator2 = expr.value.head.indicator;
          if (expr.value.head.indicator === ":/2") {
            context_module = expr.value.head.args[0].id;
            indicator2 = expr.value.head.args[1].indicator;
          }
          if (!reconsulted.hasOwnProperty(context_module))
            reconsulted[context_module] = {};
          if (options2.reconsult !== false && reconsulted[context_module][indicator2] !== true && !thread.is_multifile_predicate(indicator2)) {
            var get_module = thread.session.modules[context_module];
            if (context_module !== "system" && get_module && get_module.rules[indicator2])
              get_module.rules[indicator2] = filter(get_module.rules[indicator2], function(rule) {
                return rule.dynamic;
              });
            reconsulted[context_module][indicator2] = true;
          }
          var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
          if (expr.value.body !== null && goal_expansion && goal_expansion.length > 0) {
            async = true;
            thread.session.renamed_variables = {};
            var origin = {
              head: function() {
                return expr.value.head;
              },
              term: function() {
                return expr.value.body;
              },
              set: function(h, p) {
                expr.value.head = h;
                expr.value.body = p;
              }
            };
            parseGoalExpansion(thread, options2, expr, body_conversion(expr.value.body), origin.set, origin);
          } else {
            thread.add_rule(expr.value, options2);
          }
        }
        return async;
      }
      function parseQuery(thread, string, options2) {
        var opts = {};
        var callback = typeof options2 === "function" ? options2 : function() {
        };
        options2 = options2 === void 0 || typeof options2 === "function" ? {} : options2;
        opts.success = options2.success === void 0 ? callback : options2.success;
        opts.error = options2.error === void 0 ? callback : options2.error;
        opts.tokenizer = options2.tokenizer === void 0 ? null : options2.tokenizer;
        opts.current_token = options2.current_token === void 0 ? 0 : options2.current_token;
        opts.string = string;
        var tokenizer = opts.tokenizer;
        var n = opts.current_token;
        if (tokenizer === null) {
          tokenizer = new Tokenizer(thread);
          opts.tokenizer = tokenizer;
          tokenizer.new_text(string);
        }
        do {
          var tokens = tokenizer.get_tokens(n);
          if (tokens === null)
            break;
          var expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
          if (expr.type !== ERROR) {
            var expr_position = expr.len;
            n = expr.len + 1;
            opts.current_token = n;
            if (tokens[expr_position] && tokens[expr_position].name === "atom" && tokens[expr_position].raw === ".") {
              expr.value = body_conversion(expr.value);
              var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
              if (!thread.__goal_expansion && goal_expansion && goal_expansion.length > 0) {
                parseQueryExpansion(thread, expr.value, opts);
                return;
              } else {
                thread.add_goal(expr.value);
                opts.success(expr.value);
              }
            } else {
              var token = tokens[expr_position];
              opts.error(new Term("throw", [
                pl.error.syntax(token ? token : tokens[expr_position - 1], token && token.error ? token.error : ". or operator expected", !token)
              ]));
              return;
            }
          } else {
            opts.error(new Term("throw", [expr.value]));
            return;
          }
        } while (true);
      }
      function rule_to_dcg(rule, thread) {
        rule = rule.rename(thread);
        var begin = thread.next_free_variable();
        var dcg = body_to_dcg(rule.body, begin, thread);
        if (dcg.error)
          return dcg.value;
        rule.body = dcg.value;
        if (rule.head.indicator === ",/2") {
          var terminals = rule.head.args[1];
          rule.head = rule.head.args[0];
          var last = thread.next_free_variable();
          var pointer = terminals;
          if (!pl.type.is_list(pointer)) {
            return pl.error.type("list", pointer, "DCG/0");
          }
          if (pointer.indicator === "[]/0") {
            terminals = dcg.variable;
          } else {
            while (pointer.indicator === "./2" && pl.type.is_list(pointer) && pointer.args[1].indicator !== "[]/0") {
              pointer = pointer.args[1];
            }
            if (pl.type.is_variable(pointer))
              return pl.error.instantiation("DCG/0");
            else if (!pl.type.is_list(pointer))
              return pl.error.type("list", terminals, "DCG/0");
            pointer.args[1] = dcg.variable;
          }
          rule.body = new Term(",", [rule.body, new Term("=", [last, terminals])]);
          rule.head = new Term(rule.head.id, rule.head.args.concat([begin, last]));
        } else {
          var first_assign = rule.body;
          if (pl.type.is_term(first_assign) && first_assign.indicator === ",/2")
            first_assign = first_assign.args[0];
          if (pl.type.is_term(first_assign) && first_assign.indicator === "=/2" && pl.type.is_variable(first_assign.args[0]) && first_assign.args[0] === begin) {
            begin = first_assign.args[1];
            rule.body = rule.body.replace(null);
          }
          if (rule.head.indicator === ":/2")
            rule.head = new Term(":", [
              new Term(rule.head.args[0].id, []),
              new Term(rule.head.args[1].id, rule.head.args[1].args.concat([begin, dcg.variable]))
            ]);
          else
            rule.head = new Term(rule.head.id, rule.head.args.concat([begin, dcg.variable]));
        }
        return rule;
      }
      function body_to_dcg(expr, last, thread) {
        var free;
        if (pl.type.is_term(expr) && expr.indicator === "!/0") {
          free = thread.next_free_variable();
          return {
            value: new Term(",", [expr, new Term("=", [last, free])]),
            variable: free,
            error: false
          };
        } else if (pl.type.is_term(expr) && expr.indicator === ":/2") {
          var right = body_to_dcg(expr.args[1], last, thread);
          if (right.error)
            return right;
          return {
            value: new Term(":", [expr.args[0], right.value]),
            variable: right.variable,
            error: false
          };
        } else if (pl.type.is_term(expr) && expr.indicator === "\\+/1") {
          var left = body_to_dcg(expr.args[0], last, thread);
          if (left.error)
            return left;
          return {
            value: new Term(expr.id, [left.value]),
            variable: last,
            error: false
          };
        } else if (pl.type.is_term(expr) && (expr.indicator === ",/2" || expr.indicator === "->/2")) {
          var left = body_to_dcg(expr.args[0], last, thread);
          if (left.error)
            return left;
          var right = body_to_dcg(expr.args[1], left.variable, thread);
          if (right.error)
            return right;
          return {
            value: new Term(expr.id, [left.value, right.value]),
            variable: right.variable,
            error: false
          };
        } else if (pl.type.is_term(expr) && expr.indicator === ";/2") {
          var left = body_to_dcg(expr.args[0], last, thread);
          if (left.error)
            return left;
          var right = body_to_dcg(expr.args[1], last, thread);
          if (right.error)
            return right;
          return {
            value: new Term(",", [new Term(";", [left.value, right.value]), new Term("=", [left.variable, right.variable])]),
            variable: right.variable,
            error: false
          };
        } else if (pl.type.is_term(expr) && expr.indicator === "{}/1") {
          free = thread.next_free_variable();
          return {
            value: new Term(",", [expr.args[0], new Term("=", [last, free])]),
            variable: free,
            error: false
          };
        } else if (pl.type.is_empty_list(expr)) {
          return {
            value: new Term("true", []),
            variable: last,
            error: false
          };
        } else if (pl.type.is_list(expr)) {
          free = thread.next_free_variable();
          var pointer = expr;
          var prev;
          while (pointer.indicator === "./2") {
            prev = pointer;
            pointer = pointer.args[1];
          }
          if (pl.type.is_variable(pointer)) {
            return {
              value: pl.error.instantiation("DCG/0"),
              variable: last,
              error: true
            };
          } else if (!pl.type.is_empty_list(pointer)) {
            return {
              value: pl.error.type("list", expr, "DCG/0"),
              variable: last,
              error: true
            };
          } else {
            prev.args[1] = free;
            return {
              value: new Term("=", [last, expr]),
              variable: free,
              error: false
            };
          }
        } else if (pl.type.is_callable(expr)) {
          free = thread.next_free_variable();
          expr = new Term(expr.id, expr.args.concat([last, free]));
          return {
            value: expr,
            variable: free,
            error: false
          };
        } else {
          return {
            value: pl.error.type("callable", expr, "DCG/0"),
            variable: last,
            error: true
          };
        }
      }
      function body_conversion(expr) {
        if (pl.type.is_variable(expr))
          return new Term("call", [expr]);
        else if (pl.type.is_term(expr) && [",/2", ";/2", "->/2"].indexOf(expr.indicator) !== -1)
          return new Term(expr.id, [body_conversion(expr.args[0]), body_conversion(expr.args[1])]);
        else if (pl.type.is_term(expr) && expr.indicator === ":/2") {
          var body = body_conversion(expr.args[1]);
          return new Term(":", [expr.args[0], body]);
        }
        return expr;
      }
      function arrayToList(array, cons) {
        var list = cons ? cons : new Term("[]", []);
        for (var i2 = array.length - 1; i2 >= 0; i2--)
          list = new Term(".", [array[i2], list]);
        return list;
      }
      function remove(array, element) {
        for (var i2 = array.length - 1; i2 >= 0; i2--) {
          if (array[i2] === element) {
            array.splice(i2, 1);
          }
        }
      }
      function nub(array) {
        var seen = {};
        var unique = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          if (!(array[i2] in seen)) {
            unique.push(array[i2]);
            seen[array[i2]] = true;
          }
        }
        return unique;
      }
      function retract(thread, point, indicator2, rule, get_module) {
        if (get_module.rules[indicator2]) {
          for (var i2 = 0; i2 < get_module.rules[indicator2].length; i2++) {
            if (get_module.rules[indicator2][i2] === rule) {
              get_module.rules[indicator2].splice(i2, 1);
              thread.success(point);
              break;
            }
          }
        }
      }
      function callN(n) {
        return function(thread, point, atom) {
          var closure = atom.args[0], args = atom.args.slice(1, n);
          var module_atom;
          if (pl.type.is_term(closure) && closure.indicator === ":/2") {
            if (!pl.type.is_atom(closure.args[0])) {
              thread.throw_error(pl.error.type("module", closure.args[0], atom.indicator));
              return;
            }
            module_atom = closure.args[0];
            closure = closure.args[1];
          }
          if (pl.type.is_variable(closure)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(closure)) {
            thread.throw_error(pl.error.type("callable", closure, atom.indicator));
          } else {
            var goal = body_conversion(new Term(closure.id, closure.args.concat(args)));
            if (!pl.type.is_callable(goal)) {
              thread.throw_error(pl.error.type("callable", goal, atom.indicator));
              return;
            }
            if (module_atom)
              goal = new Term(":", [module_atom, goal]);
            thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
          }
        };
      }
      function str_indicator(str) {
        for (var i2 = str.length - 1; i2 >= 0; i2--)
          if (str.charAt(i2) === "/")
            return new Term("/", [new Term(str.substring(0, i2)), new Num(parseInt(str.substring(i2 + 1)), false)]);
      }
      function gcd(a2, b2) {
        if (b2 === 0)
          return a2;
        return Math.abs(gcd(b2, a2 % b2));
      }
      function Var(id) {
        this.id = id;
      }
      function Num(value, is_float) {
        this.is_float = is_float !== void 0 ? is_float : Math.trunc(value) !== value;
        this.value = this.is_float ? value : Math.trunc(value);
      }
      var term_ref = 0;
      function Term(id, args, ref) {
        term_ref++;
        this.ref = ref || term_ref;
        this.id = id;
        this.args = args || [];
        this.indicator = id + "/" + this.args.length;
      }
      var stream_ref = 0;
      function Stream(stream, mode, alias, type, reposition, eof_action) {
        this.id = stream_ref++;
        this.stream = stream;
        this.mode = mode;
        this.alias = alias;
        this.type = type !== void 0 ? type : "text";
        this.reposition = reposition !== void 0 ? reposition : true;
        this.eof_action = eof_action !== void 0 ? eof_action : "eof_code";
        this.position = this.mode === "append" ? "end_of_stream" : 0;
        this.output = this.mode === "write" || this.mode === "append";
        this.input = this.mode === "read";
        this.line_position = 0;
        this.line_count = 1;
        this.char_count = 0;
      }
      function Substitution(links, attrs) {
        links = links || {};
        attrs = attrs || {};
        this.links = links;
        this.attrs = attrs;
      }
      function State(goal, subs, parent) {
        subs = subs || new Substitution();
        parent = parent || null;
        this.goal = goal;
        this.substitution = subs;
        this.parent = parent;
      }
      function Rule(head, body, dynamic) {
        this.head = head;
        this.body = body;
        this.dynamic = dynamic ? dynamic : false;
      }
      function Session(limit) {
        limit = typeof limit === "number" && limit > 0 ? limit : null;
        this.rename = 0;
        this.modules = {};
        this.modules.user = new Module("user", {}, "all", {
          session: this,
          dependencies: ["system"]
        });
        this.modules.system = pl.modules.system;
        this.rules = this.modules.user.rules;
        this.total_threads = 0;
        this.renamed_variables = {};
        this.public_predicates = this.modules.user.public_predicates;
        this.multifile_predicates = this.modules.user.multifile_predicates;
        this.limit = limit;
        this.streams = {
          "user_input": new Stream(nodejs_flag ? nodejs_user_input : tau_user_input, "read", "user_input", "text", false, "reset"),
          "user_output": new Stream(nodejs_flag ? nodejs_user_output : tau_user_output, "append", "user_output", "text", false, "reset"),
          "user_error": new Stream(nodejs_flag ? nodejs_user_error : tau_user_error, "append", "user_error", "text", false, "reset")
        };
        this.file_system = nodejs_flag ? nodejs_file_system : tau_file_system;
        this.standard_input = this.streams["user_input"];
        this.standard_output = this.streams["user_output"];
        this.standard_error = this.streams["user_error"];
        this.current_input = this.streams["user_input"];
        this.current_output = this.streams["user_output"];
        this.working_directory = "/";
        this.format_success = function(state) {
          return state.substitution;
        };
        this.format_error = function(state) {
          return state.goal;
        };
        this.flag = {
          bounded: pl.flag.bounded.value,
          max_integer: pl.flag.max_integer.value,
          min_integer: pl.flag.min_integer.value,
          integer_rounding_function: pl.flag.integer_rounding_function.value,
          char_conversion: pl.flag.char_conversion.value,
          debug: pl.flag.debug.value,
          max_arity: pl.flag.max_arity.value,
          unknown: pl.flag.unknown.value,
          double_quotes: pl.flag.double_quotes.value,
          occurs_check: pl.flag.occurs_check.value,
          dialect: pl.flag.dialect.value,
          version_data: pl.flag.version_data.value,
          nodejs: pl.flag.nodejs.value,
          argv: pl.flag.argv.value
        };
        this.__loaded_modules = [];
        this.__char_conversion = {};
        this.__operators = {
          1200: { ":-": ["fx", "xfx"], "-->": ["xfx"], "?-": ["fx"] },
          1150: { "meta_predicate": ["fx"] },
          1100: { ";": ["xfy"] },
          1050: { "->": ["xfy"] },
          1e3: { ",": ["xfy"] },
          900: { "\\+": ["fy"] },
          700: {
            "=": ["xfx"],
            "\\=": ["xfx"],
            "==": ["xfx"],
            "\\==": ["xfx"],
            "@<": ["xfx"],
            "@=<": ["xfx"],
            "@>": ["xfx"],
            "@>=": ["xfx"],
            "=..": ["xfx"],
            "is": ["xfx"],
            "=:=": ["xfx"],
            "=\\=": ["xfx"],
            "<": ["xfx"],
            "=<": ["xfx"],
            ">": ["xfx"],
            ">=": ["xfx"]
          },
          600: { ":": ["xfy"] },
          500: { "+": ["yfx"], "-": ["yfx"], "/\\": ["yfx"], "\\/": ["yfx"] },
          400: {
            "*": ["yfx"],
            "/": ["yfx"],
            "//": ["yfx"],
            "rem": ["yfx"],
            "mod": ["yfx"],
            "<<": ["yfx"],
            ">>": ["yfx"],
            "div": ["yfx"]
          },
          200: { "**": ["xfx"], "^": ["xfy"], "-": ["fy"], "+": ["fy"], "\\": ["fy"] }
        };
        this.thread = new Thread(this);
      }
      function Thread(session) {
        this.epoch = Date.now();
        this.session = session;
        this.session.total_threads++;
        this.format_success = session.format_success;
        this.format_error = session.format_error;
        this.total_steps = 0;
        this.cpu_time = 0;
        this.cpu_time_last = 0;
        this.points = [];
        this.debugger = false;
        this.debugger_states = [];
        this.level = new Term("top_level");
        this.current_limit = this.session.limit;
        this.has_limit = this.session.limit !== null;
        this.warnings = [];
        this.__calls = [];
        this.__goal_expansion = false;
      }
      function Module(id, rules2, exports3, options2) {
        options2 = options2 === void 0 ? {} : options2;
        options2.public_predicates = options2.public_predicates === void 0 ? {} : options2.public_predicates;
        options2.multifile_predicates = options2.multifile_predicates === void 0 ? {} : options2.multifile_predicates;
        options2.meta_predicates = options2.meta_predicates === void 0 ? {} : options2.meta_predicates;
        options2.session = options2.session === void 0 ? null : options2.session;
        options2.dependencies = options2.dependencies === void 0 ? [] : options2.dependencies;
        this.id = id;
        this.rules = rules2;
        this.public_predicates = options2.public_predicates;
        this.multifile_predicates = options2.multifile_predicates;
        this.meta_predicates = options2.meta_predicates;
        this.src_predicates = {};
        this.dependencies = options2.dependencies;
        this.exports = exports3;
        this.is_library = options2.session === null;
        this.modules = {};
        if (options2.session) {
          options2.session.modules[id] = this;
          for (var i2 = 0; i2 < options2.dependencies.length; i2++) {
            var lib = options2.dependencies[i2];
            if (!options2.session.modules.hasOwnProperty(lib))
              options2.session.modules[lib] = pl.modules[lib];
          }
        } else {
          pl.modules[id] = this;
        }
        if (exports3 !== "all") {
          for (var i2 = 0; i2 < exports3.length; i2++) {
            this.public_predicates[exports3[i2]] = options2.public_predicates.hasOwnProperty(exports3[i2]) && options2.public_predicates[exports3[i2]] === true;
          }
        }
      }
      Module.prototype.exports_predicate = function(indicator2) {
        return this.exports === "all" || indexOf(this.exports, indicator2) !== -1;
      };
      Module.prototype.is_public_predicate = function(indicator2) {
        return !this.public_predicates.hasOwnProperty(indicator2) || this.public_predicates[indicator2] === true;
      };
      Module.prototype.is_multifile_predicate = function(indicator2) {
        return this.multifile_predicates.hasOwnProperty(indicator2) && this.multifile_predicates[indicator2] === true;
      };
      Module.prototype.is_meta_predicate = function(indicator2) {
        if (this.meta_predicates.hasOwnProperty(indicator2))
          return this.meta_predicates[indicator2];
        return null;
      };
      Var.prototype.unify = function(obj, occurs_check) {
        if (occurs_check && indexOf(obj.variables(), this.id) !== -1 && !pl.type.is_variable(obj)) {
          return null;
        }
        var links = {};
        links[this.id] = obj;
        return new Substitution(links);
      };
      Num.prototype.unify = function(obj, _) {
        if (pl.type.is_number(obj) && this.value === obj.value && this.is_float === obj.is_float) {
          return new Substitution();
        }
        return null;
      };
      Term.prototype.unify = function(obj, occurs_check) {
        if (pl.type.is_term(obj) && this.indicator === obj.indicator) {
          var subs = new Substitution();
          for (var i2 = 0; i2 < this.args.length; i2++) {
            var mgu = pl.unify(this.args[i2].apply(subs), obj.args[i2].apply(subs), occurs_check);
            if (mgu === null)
              return null;
            for (var x in mgu.links)
              subs.links[x] = mgu.links[x];
            subs = subs.apply(mgu);
          }
          return subs;
        }
        return null;
      };
      Stream.prototype.unify = function(obj, occurs_check) {
        if (pl.type.is_stream(obj) && this.id === obj.id) {
          return new Substitution();
        }
        return null;
      };
      Stream.prototype.compare = function(obj) {
        if (this.id < obj.id)
          return -1;
        else if (this.id === obj.id)
          return 0;
        else
          return 1;
      };
      Var.prototype.toString = function(options2) {
        options2 = options2 === void 0 ? {} : options2;
        if (options2.variable_names) {
          var pointer = options2.variable_names;
          while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
            var head = pointer.args[0];
            if (pl.type.is_term(head) && head.indicator === "=/2" && pl.type.is_variable(head.args[1]) && head.args[1].id === this.id && pl.type.is_atom(head.args[0]))
              return head.args[0].id;
            pointer = pointer.args[1];
          }
        }
        return this.id;
      };
      Num.prototype.toString = function(_) {
        var str = this.value.toString();
        var e = str.indexOf("e");
        if (e !== -1) {
          if (str.indexOf(".") !== -1)
            return str;
          else
            return str.replace("e", ".0e");
        }
        return this.is_float && indexOf(str, ".") === -1 ? this.value + ".0" : str;
      };
      Term.prototype.toString = function(options2, priority, from) {
        options2 = !options2 ? {} : options2;
        options2.quoted = options2.quoted === void 0 ? false : options2.quoted;
        options2.ignore_ops = options2.ignore_ops === void 0 ? false : options2.ignore_ops;
        options2.numbervars = options2.numbervars === void 0 ? false : options2.numbervars;
        options2.variable_names = options2.variable_names === void 0 ? false : options2.variable_names;
        priority = priority === void 0 ? { priority: 1200, class: "", indicator: "" } : priority;
        from = from === void 0 ? "" : from;
        var arg_priority = { priority: 999, class: "", indicator: "" };
        if (options2.numbervars && this.indicator === "$VAR/1" && pl.type.is_integer(this.args[0]) && this.args[0].value >= 0) {
          var i2 = this.args[0].value;
          var number = Math.floor(i2 / 26);
          var letter = i2 % 26;
          return "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[letter] + (number !== 0 ? number : "");
        }
        switch (this.indicator) {
          case "[]/0":
          case "{}/0":
          case "!/0":
            return this.id;
          case "{}/1":
            if (options2.ignore_ops === false) {
              return "{" + this.args[0].toString(options2) + "}";
            } else {
              return "{}(" + this.args[0].toString(options2) + ")";
            }
          case "./2":
            if (options2.ignore_ops === false) {
              var list = "[" + this.args[0].toString(options2, arg_priority);
              var pointer = this.args[1];
              while (pointer.indicator === "./2") {
                list += "," + pointer.args[0].toString(options2, arg_priority);
                pointer = pointer.args[1];
              }
              if (pointer.indicator !== "[]/0") {
                list += "|" + pointer.toString(options2, arg_priority);
              }
              list += "]";
              return list;
            }
          default:
            var id = this.id;
            var operator = options2.session ? options2.session.lookup_operator(this.id, this.args.length) : null;
            if (options2.session === void 0 || options2.ignore_ops || operator === null) {
              if (options2.quoted && (!/^(!|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+)$/.test(id) && id !== "{}" && id !== "[]" || indexOf([".", ",", ";"], id) !== -1 || id.substring(0, 2) === "/*"))
                id = "'" + redoEscape(id) + "'";
              if (this.args.length === 0 && is_graphic_token(this.id) && priority.indicator !== "")
                return "(" + id + ")";
              return id + (this.args.length > 0 ? "(" + map(this.args, function(x) {
                return x.toString(options2, arg_priority);
              }).join(",") + ")" : "");
            } else {
              var priority_op = parseInt(operator.priority);
              var priority_arg = parseInt(priority.priority);
              var cond = priority_op > priority_arg || priority_op === priority_arg && (operator.class === "xfx" || operator.class === "xfy" && this.indicator !== priority.indicator || operator.class === "yfx" && this.indicator !== priority.indicator || this.indicator === priority.indicator && operator.class === "yfx" && from === "right" || this.indicator === priority.indicator && operator.class === "xfy" && from === "left" || this.indicator === priority.indicator && operator.class === "xf" && from === "left" || this.indicator === priority.indicator && operator.class === "fx" && from === "right");
              operator.indicator = this.indicator;
              var lpar = cond ? "(" : "";
              var rpar = cond ? ")" : "";
              var space = !(is_graphic_token(this.id) || this.id === "," || this.id === ";") || operator.class.length === 2 || operator.class.length === 3 && pl.type.is_number(this.args[1]) && this.args[1].value < 0 ? " " : "";
              if (this.args.length === 0) {
                return lpar + this.id + rpar;
              } else if (["fy", "fx"].indexOf(operator.class) !== -1) {
                return lpar + id + space + this.args[0].toString(options2, operator, "right") + rpar;
              } else if (["yf", "xf"].indexOf(operator.class) !== -1) {
                return lpar + this.args[0].toString(options2, operator, "left") + space + id + rpar;
              } else {
                return lpar + this.args[0].toString(options2, operator, "left") + space + this.id + space + this.args[1].toString(options2, operator, "right") + rpar;
              }
            }
        }
      };
      Stream.prototype.toString = function(_) {
        return "<stream>(" + this.id + ")";
      };
      Substitution.prototype.toString = function(options2) {
        var str = "{";
        for (var link in this.links) {
          if (!this.links.hasOwnProperty(link))
            continue;
          if (str !== "{") {
            str += ", ";
          }
          str += link + "/" + this.links[link].toString(options2);
        }
        str += "}";
        return str;
      };
      State.prototype.toString = function(options2) {
        if (this.goal === null) {
          return "<" + this.substitution.toString(options2) + ">";
        } else {
          return "<" + this.goal.toString(options2) + ", " + this.substitution.toString(options2) + ">";
        }
      };
      Rule.prototype.toString = function(options2) {
        if (!this.body) {
          return this.head.toString(options2) + ".";
        } else {
          return this.head.toString(options2, 1200, "left") + " :- " + this.body.toString(options2, 1200, "right") + ".";
        }
      };
      Session.prototype.toString = function(options2) {
        var str = "";
        for (var prop in this.modules) {
          if (this.modules.hasOwnProperty(prop) && this.modules[prop].is_library)
            str += ":- use_module(library(" + this.modules[prop] + ")).\n";
        }
        str += "\n";
        for (var key in this.modules.user.rules) {
          if (!this.modules.user.rules.hasOwnProperty(key))
            continue;
          for (i = 0; i < this.modules.user.rules[key].length; i++) {
            str += this.modules.user.rules[key][i].toString(options2);
            str += "\n";
          }
        }
        return str;
      };
      Var.prototype.clone = function() {
        return new Var(this.id);
      };
      Num.prototype.clone = function() {
        return new Num(this.value, this.is_float);
      };
      Term.prototype.clone = function() {
        var term = new Term(this.id, map(this.args, function(arg) {
          return arg.clone();
        }));
        if (this.definition_module)
          term.definition_module = this.definition_module;
        return term;
      };
      Stream.prototype.clone = function() {
        return new Stream(this.stream, this.mode, this.alias, this.type, this.reposition, this.eof_action);
      };
      Substitution.prototype.clone = function() {
        var links = {};
        var attrs = {};
        for (var link in this.links) {
          if (!this.links.hasOwnProperty(link))
            continue;
          links[link] = this.links[link].clone();
        }
        for (var attr in this.attrs) {
          if (!this.attrs.hasOwnProperty(attrs))
            continue;
          attrs[attr] = {};
          for (var m in this.attrs[attr]) {
            if (!this.attrs[attr].hasOwnProperty(m))
              continue;
            attrs[attr][m] = this.attrs[attr][m].clone();
          }
        }
        return new Substitution(links, attrs);
      };
      State.prototype.clone = function() {
        return new State(this.goal.clone(), this.substitution.clone(), this.parent);
      };
      Rule.prototype.clone = function() {
        return new Rule(this.head.clone(), this.body !== null ? this.body.clone() : null);
      };
      Var.prototype.equals = function(obj) {
        return pl.type.is_variable(obj) && this.id === obj.id;
      };
      Num.prototype.equals = function(obj) {
        return pl.type.is_number(obj) && this.value === obj.value && this.is_float === obj.is_float;
      };
      Term.prototype.equals = function(obj) {
        if (!pl.type.is_term(obj) || this.indicator !== obj.indicator) {
          return false;
        }
        for (var i2 = 0; i2 < this.args.length; i2++) {
          if (!this.args[i2].equals(obj.args[i2])) {
            return false;
          }
        }
        return true;
      };
      Stream.prototype.equals = function(obj) {
        return pl.type.is_stream(obj) && this.id === obj.id;
      };
      Substitution.prototype.equals = function(obj) {
        var link;
        if (!pl.type.is_substitution(obj)) {
          return false;
        }
        for (link in this.links) {
          if (!this.links.hasOwnProperty(link))
            continue;
          if (!obj.links[link] || !this.links[link].equals(obj.links[link])) {
            return false;
          }
        }
        for (link in obj.links) {
          if (!obj.links.hasOwnProperty(link))
            continue;
          if (!this.links[link]) {
            return false;
          }
        }
        return true;
      };
      State.prototype.equals = function(obj) {
        return pl.type.is_state(obj) && this.goal.equals(obj.goal) && this.substitution.equals(obj.substitution) && this.parent === obj.parent;
      };
      Rule.prototype.equals = function(obj) {
        return pl.type.is_rule(obj) && this.head.equals(obj.head) && (this.body === null && obj.body === null || this.body !== null && this.body.equals(obj.body));
      };
      Var.prototype.rename = function(thread) {
        return thread.get_free_variable(this);
      };
      Num.prototype.rename = function(_) {
        return this;
      };
      Term.prototype.rename = function(thread) {
        if (this.indicator === "./2") {
          var arr = [], pointer = this;
          var last_neq = -1, pointer_neq = null, i2 = 0;
          while (pointer.indicator === "./2") {
            var app2 = pointer.args[0].rename(thread);
            var cmp = app2 == pointer.args[0];
            arr.push(app2);
            pointer = pointer.args[1];
            if (!cmp) {
              last_neq = i2;
              pointer_neq = pointer;
            }
            i2++;
          }
          var list = pointer.rename(thread);
          var cmp = list == pointer;
          if (last_neq === -1 && cmp)
            return this;
          var start = cmp ? last_neq : arr.length - 1;
          var list = cmp ? pointer_neq : list;
          for (var i2 = start; i2 >= 0; i2--) {
            list = new Term(".", [arr[i2], list]);
          }
          return list;
        }
        var eq = true;
        var args = [];
        for (var i2 = 0; i2 < this.args.length; i2++) {
          var app2 = this.args[i2].rename(thread);
          eq = eq && this.args[i2] == app2;
          args.push(app2);
        }
        return new Term(this.id, args);
      };
      Stream.prototype.rename = function(thread) {
        return this;
      };
      Rule.prototype.rename = function(thread) {
        return new Rule(this.head.rename(thread), this.body !== null ? this.body.rename(thread) : null);
      };
      Var.prototype.is_rename = function(obj, links) {
        links = links || {};
        if (!pl.type.is_variable(obj) || links.hasOwnProperty(this.id) && links[this.id] !== obj.id || links.hasOwnProperty(obj.id) && links[obj.id] !== this.id)
          return false;
        links[this.id] = obj.id;
        links[obj.id] = this.id;
        return true;
      };
      Num.prototype.is_rename = function(obj, _links) {
        return this.equals(obj);
      };
      Term.prototype.is_rename = function(obj, links) {
        links = links || {};
        if (!pl.type.is_term(obj) || this.indicator !== obj.indicator)
          return false;
        for (var i2 = 0; i2 < this.args.length; i2++) {
          if (!pl.is_rename(this.args[i2], obj.args[i2], links))
            return false;
        }
        return true;
      };
      Stream.prototype.is_rename = function(obj, _links) {
        return this.equals(obj);
      };
      Var.prototype.variables = function() {
        return [this.id];
      };
      Num.prototype.variables = function() {
        return [];
      };
      Term.prototype.variables = function() {
        return [].concat.apply([], map(this.args, function(arg) {
          return arg.variables();
        }));
      };
      Stream.prototype.variables = function() {
        return [];
      };
      Rule.prototype.variables = function() {
        if (this.body === null) {
          return this.head.variables();
        } else {
          return this.head.variables().concat(this.body.variables());
        }
      };
      Var.prototype.apply = function(subs) {
        if (subs.lookup(this.id)) {
          return subs.lookup(this.id);
        }
        return this;
      };
      Num.prototype.apply = function(_) {
        return this;
      };
      Term.prototype.apply = function(subs) {
        if (this.args.length === 0)
          return this;
        if (this.indicator === "./2") {
          var arr = [], pointer = this;
          var last_neq = -1, pointer_neq = null, i2 = 0;
          while (pointer.indicator === "./2") {
            var app2 = pointer.args[0].apply(subs);
            var cmp = app2 == pointer.args[0];
            arr.push(app2);
            pointer = pointer.args[1];
            if (!cmp) {
              last_neq = i2;
              pointer_neq = pointer;
            }
            i2++;
          }
          var list = pointer.apply(subs);
          var cmp = list == pointer;
          if (last_neq === -1 && cmp)
            return this;
          var start = cmp ? last_neq : arr.length - 1;
          var list = cmp ? pointer_neq : list;
          for (var i2 = start; i2 >= 0; i2--) {
            list = new Term(".", [arr[i2], list]);
          }
          return list;
        }
        var eq = true;
        var args = [];
        for (var i2 = 0; i2 < this.args.length; i2++) {
          var app2 = this.args[i2].apply(subs);
          eq = eq && this.args[i2] == app2;
          args.push(app2);
        }
        if (eq)
          return this;
        return new Term(this.id, args, this.ref);
      };
      Stream.prototype.apply = function(_) {
        return this;
      };
      Rule.prototype.apply = function(subs) {
        return new Rule(this.head.apply(subs), this.body !== null ? this.body.apply(subs) : null);
      };
      Substitution.prototype.apply = function(subs) {
        var link, links = {}, attr, attrs = {}, m;
        for (link in this.links) {
          if (!this.links.hasOwnProperty(link))
            continue;
          links[link] = this.links[link].apply(subs);
        }
        for (attr in this.attrs) {
          if (!this.attrs.hasOwnProperty(attr))
            continue;
          attrs[attr] = {};
          for (m in this.attrs[attr]) {
            if (!this.attrs[attr].hasOwnProperty(m))
              continue;
            attrs[attr][m] = this.attrs[attr][m].apply(subs);
          }
        }
        return new Substitution(links, attrs);
      };
      Term.prototype.select = function() {
        var pointer = this;
        while (pl.type.is_term(pointer) && pointer.indicator === ",/2")
          pointer = pointer.args[0];
        return pointer;
      };
      Term.prototype.replace = function(expr) {
        if (this.indicator === ",/2") {
          if (this.args[0].indicator === ",/2") {
            return new Term(",", [this.args[0].replace(expr), this.args[1]]);
          } else {
            return expr === null ? this.args[1] : new Term(",", [expr, this.args[1]]);
          }
        } else {
          return expr;
        }
      };
      Term.prototype.search = function(expr) {
        if (this == expr || this.ref === expr.ref)
          return true;
        for (var i2 = 0; i2 < this.args.length; i2++)
          if (pl.type.is_term(this.args[i2]) && this.args[i2].search(expr))
            return true;
        return false;
      };
      Session.prototype.setMaxInferences = function(max) {
        this.limit = typeof max === "number" && max > 0 ? max : null;
      };
      Thread.prototype.setMaxInferences = function(max) {
        this.session.setMaxInferences(max);
        this.current_limit = this.session.limit;
        this.has_limit = this.session.limit !== null;
      };
      Session.prototype.format_answer = function(answer, options2) {
        return this.thread.format_answer(answer, options2);
      };
      Thread.prototype.format_answer = function(answer, options2) {
        return pl.format_answer(answer, this, options2);
      };
      Session.prototype.get_current_input = function() {
        return this.current_input;
      };
      Thread.prototype.get_current_input = function() {
        return this.session.get_current_input();
      };
      Session.prototype.get_current_output = function() {
        return this.current_output;
      };
      Thread.prototype.get_current_output = function() {
        return this.session.get_current_output();
      };
      Session.prototype.set_current_input = function(input2) {
        this.current_input = input2;
      };
      Thread.prototype.set_current_input = function(input2) {
        return this.session.set_current_input(input2);
      };
      Session.prototype.set_current_output = function(output) {
        this.current_output = output;
      };
      Thread.prototype.set_current_output = function(output) {
        return this.session.set_current_output(output);
      };
      Session.prototype.get_stream_by_alias = function(alias) {
        return this.streams[alias];
      };
      Thread.prototype.get_stream_by_alias = function(alias) {
        return this.session.get_stream_by_alias(alias);
      };
      Session.prototype.file_system_open = function(path, type, mode) {
        if (this.get_flag("nodejs").indicator === "false/0")
          path = this.absolute_file_name(path);
        return this.file_system.open(path, type, mode);
      };
      Thread.prototype.file_system_open = function(path, type, mode) {
        return this.session.file_system_open(path, type, mode);
      };
      Session.prototype.absolute_file_name = function(filename) {
        var absolute;
        if (this.get_flag("nodejs").indicator === "true/0") {
          var path = require("path");
          absolute = filename;
          for (var prop in process.env) {
            if (!process.env.hasOwnProperty(prop))
              continue;
            absolute = absolute.replace(new RegExp("\\$" + prop, "g"), process.env[prop]);
          }
          return path.resolve(absolute);
        } else {
          var cwd = this.working_directory;
          if (filename[0] === "/")
            absolute = filename;
          else
            absolute = cwd + (cwd[cwd.length - 1] === "/" ? filename : "/" + filename);
          absolute = absolute.replace(/\/\.\//g, "/");
          var dirs = absolute.split("/");
          var dirs2 = [];
          for (var i2 = 0; i2 < dirs.length; i2++) {
            if (dirs[i2] !== "..") {
              dirs2.push(dirs[i2]);
            } else {
              if (dirs2.length !== 0)
                dirs2.pop();
            }
          }
          absolute = dirs2.join("/").replace(/\/\.$/, "/");
        }
        return absolute;
      };
      Thread.prototype.absolute_file_name = function(path, cwd) {
        return this.session.absolute_file_name(path, cwd);
      };
      Session.prototype.get_char_conversion = function(char) {
        return this.__char_conversion[char] || char;
      };
      Thread.prototype.get_char_conversion = function(char) {
        return this.session.get_char_conversion(char);
      };
      Session.prototype.parse = function(string) {
        return this.thread.parse(string);
      };
      Thread.prototype.parse = function(string) {
        var tokenizer = new Tokenizer(this);
        tokenizer.new_text(string);
        var tokens = tokenizer.get_tokens();
        if (tokens === null)
          return false;
        var expr = parseExpr(this, tokens, 0, this.__get_max_priority(), false);
        if (expr.len !== tokens.length)
          return false;
        return { value: expr.value, expr, tokens };
      };
      Session.prototype.get_flag = function(flag) {
        return this.flag[flag];
      };
      Thread.prototype.get_flag = function(flag) {
        return this.session.get_flag(flag);
      };
      Session.prototype.add_rule = function(rule, options2) {
        return this.thread.add_rule(rule, options2);
      };
      Thread.prototype.add_rule = function(rule, options2) {
        options2 = options2 ? options2 : {};
        options2.from = options2.from ? options2.from : "$tau-js";
        var module_id, get_module;
        if (pl.type.is_term(rule.head) && rule.head.indicator === ":/2") {
          if (!pl.type.is_atom(rule.head.args[0])) {
            this.throw_warning(pl.error.type("module", rule.head.args[0], "top_level/0"));
            return;
          }
          module_id = rule.head.args[0].id;
          rule.head = rule.head.args[1];
        }
        if (module_id) {
          get_module = this.session.modules[module_id];
          if (!pl.type.is_module(get_module)) {
            get_module = new Module(module_id, {}, "all", { session: this.session });
            this.session.modules[module_id] = get_module;
          }
        } else {
          get_module = this.session.modules[options2.context_module];
        }
        get_module.src_predicates[rule.head.indicator] = options2.from;
        if (!get_module.rules.hasOwnProperty(rule.head.indicator)) {
          get_module.rules[rule.head.indicator] = [];
        }
        get_module.rules[rule.head.indicator].push(rule);
        if (!get_module.public_predicates.hasOwnProperty(rule.head.indicator))
          get_module.public_predicates[rule.head.indicator] = false;
        return true;
      };
      Session.prototype.run_directive = function(directive, options2) {
        return this.thread.run_directive(directive, options2);
      };
      Thread.prototype.run_directive = function(directive, options2) {
        if (pl.type.is_directive(directive)) {
          if (pl.directive[directive.indicator])
            return pl.directive[directive.indicator](this, directive, options2);
          else
            return pl.directive[directive.id + "/*"](this, directive, options2);
        }
        return false;
      };
      Session.prototype.__get_max_priority = function() {
        return "1200";
      };
      Thread.prototype.__get_max_priority = function() {
        return this.session.__get_max_priority();
      };
      Session.prototype.__get_next_priority = function(priority) {
        var max = 0;
        priority = parseInt(priority);
        for (var key in this.__operators) {
          if (!this.__operators.hasOwnProperty(key))
            continue;
          var n = parseInt(key);
          if (n > max && n < priority)
            max = n;
        }
        return max.toString();
      };
      Thread.prototype.__get_next_priority = function(priority) {
        return this.session.__get_next_priority(priority);
      };
      Session.prototype.__lookup_operator_classes = function(priority, operator) {
        if (this.__operators.hasOwnProperty(priority) && this.__operators[priority][operator] instanceof Array) {
          return this.__operators[priority][operator] || false;
        }
        return false;
      };
      Thread.prototype.__lookup_operator_classes = function(priority, operator) {
        return this.session.__lookup_operator_classes(priority, operator);
      };
      Session.prototype.lookup_operator = function(name, arity) {
        for (var p in this.__operators)
          if (this.__operators[p][name]) {
            for (var i2 = 0; i2 < this.__operators[p][name].length; i2++)
              if (this.__operators[p][name][i2].length === arity + 1)
                return { priority: p, class: this.__operators[p][name][i2] };
          }
        return null;
      };
      Thread.prototype.lookup_operator = function(name, arity) {
        return this.session.lookup_operator(name, arity);
      };
      Session.prototype.throw_warning = function(warning) {
        this.thread.throw_warning(warning);
      };
      Thread.prototype.throw_warning = function(warning) {
        this.warnings.push(warning);
      };
      Session.prototype.get_warnings = function() {
        return this.thread.get_warnings();
      };
      Thread.prototype.get_warnings = function() {
        return this.warnings;
      };
      Session.prototype.add_goal = function(goal, unique) {
        this.thread.add_goal(goal, unique);
      };
      Thread.prototype.add_goal = function(goal, unique, parent) {
        parent = parent ? parent : null;
        if (unique === true)
          this.points = [];
        var vars = goal.variables();
        var links = {};
        for (var i2 = 0; i2 < vars.length; i2++)
          links[vars[i2]] = new Var(vars[i2]);
        this.points.push(new State(goal, new Substitution(links), parent));
      };
      Session.prototype.consult = function(program, options2) {
        return this.thread.consult(program, options2);
      };
      Thread.prototype.consult = function(program, options2) {
        var string = "", success = false;
        var opts = {};
        var callback = typeof options2 === "function" ? options2 : function() {
        };
        options2 = options2 === void 0 || typeof options2 === "function" ? {} : options2;
        opts.context_module = options2.context_module === void 0 ? "user" : options2.context_module;
        opts.text = options2.text === void 0 ? true : options2.text;
        opts.html = options2.html === void 0 ? true : options2.html;
        opts.url = options2.url === void 0 ? true : options2.url;
        opts.file = options2.file === void 0 ? true : options2.file;
        opts.script = options2.script === void 0 ? true : options2.script;
        opts.success = options2.success === void 0 ? callback : options2.success;
        opts.error = options2.error === void 0 ? callback : options2.error;
        if (typeof program === "string") {
          string = program;
          if (opts.script && this.get_flag("nodejs").indicator === "false/0" && program != "" && document.getElementById(string)) {
            var script = document.getElementById(string);
            var type = script.getAttribute("type");
            if (type !== null && type.replace(/ /g, "").toLowerCase() === "text/prolog") {
              string = script.text;
              success = true;
            }
          }
          if (!success && opts.file && this.get_flag("nodejs").indicator === "true/0") {
            var fs2 = require("fs");
            var thread = this;
            fs2.readFile(program, function(error2, data) {
              if (error2) {
                opts.file = false;
                thread.consult(program, opts);
              } else {
                parseProgram(thread, data.toString(), opts);
              }
            });
            return;
          }
          if (!success && this.get_flag("nodejs").indicator === "false/0" && opts.url && program !== "" && !/\s/.test(program)) {
            try {
              var xhttp = new XMLHttpRequest();
              var thread = this;
              xhttp.onreadystatechange = function() {
                if (this.readyState == 4) {
                  if (this.status == 200) {
                    string = xhttp.responseText;
                    success = true;
                    parseProgram(thread, string, opts);
                  } else {
                    opts.url = false;
                    thread.consult(program, opts);
                  }
                }
              };
              xhttp.open("GET", program, true);
              xhttp.send();
              return;
            } catch (ex) {
              opts.error(ex);
              return;
            }
          }
          if (!success && opts.text) {
            success = true;
          }
        } else if (opts.html && program.nodeName) {
          switch (program.nodeName.toLowerCase()) {
            case "input":
            case "textarea":
              string = program.value;
              success = true;
              break;
            default:
              string = program.innerHTML;
              success = true;
              break;
          }
        } else {
          opts.error(pl.error.existence("source_sink", new Term(string), "top_level/0"));
        }
        this.warnings = [];
        parseProgram(this, string, opts);
      };
      Session.prototype.query = function(string, options2) {
        return this.thread.query(string, options2);
      };
      Thread.prototype.query = function(string, options2) {
        this.points = [];
        this.debugger_states = [];
        this.level = new Term("top_level");
        return parseQuery(this, string, options2);
      };
      Session.prototype.head_point = function() {
        return this.thread.head_point();
      };
      Thread.prototype.head_point = function() {
        return this.points[this.points.length - 1];
      };
      Session.prototype.get_free_variable = function(variable) {
        return this.thread.get_free_variable(variable);
      };
      Thread.prototype.get_free_variable = function(variable) {
        var variables = [];
        if (variable.id === "_" || this.session.renamed_variables[variable.id] === void 0) {
          this.session.rename++;
          if (this.current_point)
            variables = this.current_point.substitution.domain();
          while (indexOf(variables, pl.format_variable(this.session.rename, variable.id)) !== -1) {
            this.session.rename++;
          }
          if (variable.id === "_") {
            return new Var(pl.format_variable(this.session.rename, variable.id));
          } else {
            this.session.renamed_variables[variable.id] = pl.format_variable(this.session.rename, variable.id);
          }
        }
        return new Var(this.session.renamed_variables[variable.id]);
      };
      Session.prototype.next_free_variable = function() {
        return this.thread.next_free_variable();
      };
      Thread.prototype.next_free_variable = function() {
        this.session.rename++;
        var variables = [];
        if (this.current_point)
          variables = this.current_point.substitution.domain();
        while (indexOf(variables, pl.format_variable(this.session.rename)) !== -1) {
          this.session.rename++;
        }
        return new Var(pl.format_variable(this.session.rename));
      };
      Session.prototype.is_public_predicate = function(indicator2, module_id) {
        module_id = module_id === void 0 ? "user" : module_id;
        return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_public_predicate(indicator2);
      };
      Thread.prototype.is_public_predicate = function(indicator2, module_id) {
        return this.session.is_public_predicate(indicator2, module_id);
      };
      Session.prototype.is_multifile_predicate = function(indicator2, module_id) {
        module_id = module_id === void 0 ? "user" : module_id;
        return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_multifile_predicate(indicator2);
      };
      Thread.prototype.is_multifile_predicate = function(indicator2, module_id) {
        return this.session.is_multifile_predicate(indicator2, module_id);
      };
      Session.prototype.is_meta_predicate = function(indicator2, module_id) {
        module_id = module_id === void 0 ? "user" : module_id;
        if (pl.type.is_module(this.modules[module_id]))
          return this.modules[module_id].is_meta_predicate(indicator2);
        return null;
      };
      Thread.prototype.is_meta_predicate = function(indicator2, module_id) {
        return this.session.is_meta_predicate(indicator2, module_id);
      };
      Session.prototype.prepend = function(states) {
        return this.thread.prepend(states);
      };
      Thread.prototype.prepend = function(states) {
        for (var i2 = states.length - 1; i2 >= 0; i2--)
          this.points.push(states[i2]);
      };
      Session.prototype.success = function(point, parent) {
        return this.thread.success(point, parent);
      };
      Thread.prototype.success = function(point, parent) {
        var parent = typeof parent === "undefined" ? point : parent;
        this.prepend([new State(point.goal.replace(null), point.substitution, parent)]);
      };
      Session.prototype.throw_error = function(error2) {
        return this.thread.throw_error(error2);
      };
      Thread.prototype.throw_error = function(error2) {
        if (pl.type.is_variable(error2))
          error2 = pl.error.instantiation(this.level.indicator);
        var state = new State(new Term("throw", [error2]), new Substitution(), null);
        state.error = true;
        this.prepend([state]);
      };
      Session.prototype.lookup_module = function(atom, context_module) {
        return this.thread.lookup_module(atom, context_module);
      };
      Thread.prototype.lookup_module = function(atom, context_module) {
        var get_module = this.session.modules[context_module];
        if (!pl.type.is_module(get_module))
          get_module = this.session.modules.user;
        if (get_module.rules.hasOwnProperty(atom.indicator) && (get_module.exports_predicate(atom.indicator) || get_module.rules.hasOwnProperty(this.level.indicator) || context_module === get_module.id))
          return get_module;
        get_module.modules.system = pl.modules.system;
        get_module.modules.user = this.session.modules.user;
        for (var prop in get_module.modules) {
          if (!this.session.modules.hasOwnProperty(prop))
            continue;
          var get_module = this.session.modules[prop];
          if (get_module.rules.hasOwnProperty(atom.indicator) && (get_module.exports_predicate(atom.indicator) || get_module.rules.hasOwnProperty(this.level.indicator) || context_module === get_module.id))
            return get_module;
        }
        return null;
      };
      Session.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
        return this.thread.expand_meta_predicate(atom, definition_module, context_module);
      };
      Thread.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
        var get_module = this.session.modules[definition_module];
        if (!get_module)
          return;
        var meta = get_module.is_meta_predicate(atom.indicator);
        if (!meta)
          return;
        for (var i2 = 0; i2 < meta.args.length; i2++) {
          if (pl.type.is_integer(meta.args[i2]) || pl.type.is_atom(meta.args[i2]) && indexOf([":"], meta.args[i2].id) !== -1) {
            if (!pl.type.is_term(atom.args[i2]) || atom.args[i2].indicator !== ":/2") {
              atom.args[i2] = new Term(":", [new Term(context_module), atom.args[i2]]);
            }
          } else if (pl.type.is_atom(meta.args[i2]) && meta.args[i2].id === "^") {
            var pointer_last = atom;
            var pointer_index = i2;
            var pointer = atom.args[i2];
            while (pl.type.is_term(pointer) && pointer.indicator === "^/2") {
              pointer_last = pointer;
              pointer_index = 1;
              pointer = pointer.args[1];
            }
            if (!pl.type.is_term(pointer) || pointer.indicator !== ":/2") {
              pointer_last.args[pointer_index] = new Term(":", [new Term(context_module), pointer]);
            }
          }
        }
      };
      Session.prototype.step = function() {
        return this.thread.step();
      };
      Thread.prototype.step = function() {
        if (this.points.length === 0) {
          return;
        }
        var asyn = false;
        var point = this.points.pop();
        this.current_point = point;
        if (this.debugger)
          this.debugger_states.push(point);
        var atom = pl.type.is_term(point.goal) ? point.goal.select() : point.goal;
        if (pl.type.is_term(atom) && (atom.indicator !== ":/2" || pl.type.is_term(atom.args[1]))) {
          var context_module = null;
          var states = [];
          if (atom !== null) {
            this.total_steps++;
            var level = point;
            while (level.parent !== null && level.parent.goal.search(atom))
              level = level.parent;
            if (level.parent === null) {
              this.level = new Term("top_level");
            } else {
              this.level = level.parent.goal.select();
              if (this.level.indicator === ":/2")
                this.level = this.level.args[1];
            }
            if (pl.type.is_term(atom) && atom.indicator === ":/2") {
              context_module = atom.args[0];
              atom = atom.args[1];
              if (!pl.type.is_atom(context_module)) {
                this.throw_error(pl.error.type("module", context_module, this.level.indicator));
                return;
              }
              context_module = context_module.id;
            } else {
              if (this.level.definition_module) {
                context_module = this.level.definition_module;
              } else {
                context_module = "user";
              }
            }
            atom.context_module = context_module;
            if (atom.indicator === ",/2") {
              this.prepend([new State(point.goal.replace(new Term(",", [
                new Term(":", [new Term(context_module), atom.args[0]]),
                new Term(":", [new Term(context_module), atom.args[1]])
              ])), point.substitution, point)]);
              return;
            }
            this.__call_indicator = atom.indicator;
            var get_module = this.lookup_module(atom, context_module);
            atom.definition_module = pl.type.is_module(get_module) ? get_module.id : "user";
            this.expand_meta_predicate(atom, atom.definition_module, context_module);
            var get_rules = get_module === null ? null : get_module.rules[atom.indicator];
            if (get_rules === null) {
              if (!this.session.modules.user.rules.hasOwnProperty(atom.indicator)) {
                if (this.get_flag("unknown").id === "error") {
                  this.throw_error(pl.error.existence("procedure", atom.indicator, this.level.indicator));
                } else if (this.get_flag("unknown").id === "warning") {
                  this.throw_warning("unknown procedure " + atom.indicator + " (from " + this.level.indicator + ")");
                }
              }
            } else if (get_rules instanceof Function) {
              asyn = get_rules(this, point, atom);
            } else {
              if (this.__goal_expansion && atom.indicator === "goal_expansion/2")
                get_rules = get_rules.concat(pl.builtin.rules["goal_expansion/2"]);
              for (var _rule in get_rules) {
                if (!get_rules.hasOwnProperty(_rule))
                  continue;
                var rule = get_rules[_rule];
                this.session.renamed_variables = {};
                rule = rule.rename(this);
                var occurs_check = this.get_flag("occurs_check").indicator === "true/0";
                var state = new State();
                var mgu = pl.unify(atom, rule.head, occurs_check);
                if (mgu !== null) {
                  state.goal = point.goal.replace(rule.body);
                  if (state.goal !== null) {
                    state.goal = state.goal.apply(mgu);
                  }
                  state.substitution = point.substitution.apply(mgu);
                  state.parent = point;
                  states.push(state);
                }
              }
              this.prepend(states);
            }
          }
        } else {
          var term = pl.type.is_term(atom) && atom.indicator === ":/2" ? atom.args[1] : atom;
          if (pl.type.is_variable(term))
            this.throw_error(pl.error.instantiation(this.level.indicator));
          else
            this.throw_error(pl.error.type("callable", term, this.level.indicator));
        }
        return asyn;
      };
      Session.prototype.answer = function(options2) {
        return this.thread.answer(options2);
      };
      Thread.prototype.answer = function(options2) {
        var opts = {};
        options2 = options2 || function() {
        };
        if (typeof options2 === "function") {
          opts = {
            success: options2,
            error: options2,
            fail: options2,
            limit: options2
          };
        } else {
          opts.success = options2.success === void 0 ? function() {
          } : options2.success;
          opts.error = options2.error === void 0 ? function() {
          } : options2.error;
          opts.fail = options2.fail === void 0 ? function() {
          } : options2.fail;
          opts.limit = options2.limit === void 0 ? function() {
          } : options2.limit;
        }
        this.__calls.push(opts);
        if (this.__calls.length > 1) {
          return;
        }
        this.again();
      };
      Session.prototype.answers = function(callback, max, after) {
        return this.thread.answers(callback, max, after);
      };
      Thread.prototype.answers = function(callback, max, after) {
        var answers = max === void 0 ? 1e3 : max;
        var thread = this;
        if (answers <= 0) {
          if (after)
            after();
          return;
        }
        this.answer(function(answer) {
          callback(answer);
          if (answer !== false) {
            setTimeout(function() {
              thread.answers(callback, answers - 1, after);
            }, 0);
          } else if (after) {
            after();
          }
        });
      };
      Session.prototype.again = function(reset_limit2) {
        return this.thread.again(reset_limit2);
      };
      Thread.prototype.again = function(reset_limit2) {
        var t0 = Date.now();
        while (this.__calls.length > 0) {
          this.warnings = [];
          if (reset_limit2 !== false)
            this.current_limit = this.session.limit;
          while ((!this.has_limit || this.current_limit > 0) && this.points.length > 0 && this.head_point().goal !== null && !pl.type.is_error_state(this.head_point())) {
            if (this.has_limit)
              this.current_limit--;
            if (this.step() === true)
              return;
          }
          var t1 = Date.now();
          this.cpu_time_last = t1 - t0;
          this.cpu_time += this.cpu_time_last;
          var call = this.__calls.shift();
          if (this.has_limit && this.current_limit <= 0) {
            (function(call2) {
              return setTimeout(function() {
                call2.limit(null);
              }, 0);
            })(call);
          } else if (this.points.length === 0) {
            (function(call2) {
              return setTimeout(function() {
                call2.fail(false);
              }, 0);
            })(call);
          } else if (pl.type.is_error(this.head_point().goal)) {
            var error2 = this.format_error(this.points.pop());
            this.points = [];
            (function(error3, call2) {
              return setTimeout(function() {
                call2.error(error3);
              }, 0);
            })(error2, call);
          } else {
            if (this.debugger)
              this.debugger_states.push(this.head_point());
            var answer = this.format_success(this.points.pop());
            (function(answer2, call2) {
              return setTimeout(function() {
                call2.success(answer2);
              }, 0);
            })(answer, call);
          }
        }
      };
      Session.prototype.unfold = function(rule) {
        if (rule.body === null)
          return false;
        var head = rule.head;
        var body = rule.body;
        var atom = body.select();
        var thread = new Thread(this);
        var unfolded = [];
        thread.add_goal(atom);
        thread.step();
        for (var i2 = thread.points.length - 1; i2 >= 0; i2--) {
          var point = thread.points[i2];
          var head2 = head.apply(point.substitution);
          var body2 = body.replace(point.goal);
          if (body2 !== null)
            body2 = body2.apply(point.substitution);
          unfolded.push(new Rule(head2, body2));
        }
        var rules2 = this.modules.user.rules[head.indicator];
        var index = indexOf(rules2, rule);
        if (unfolded.length > 0 && index !== -1) {
          rules2.splice.apply(rules2, [index, 1].concat(unfolded));
          return true;
        }
        return false;
      };
      Thread.prototype.unfold = function(rule) {
        return this.session.unfold(rule);
      };
      Var.prototype.interpret = function(thread) {
        return pl.error.instantiation(thread.level.indicator);
      };
      Num.prototype.interpret = function(thread) {
        return this;
      };
      Term.prototype.interpret = function(thread) {
        if (pl.type.is_unitary_list(this)) {
          return this.args[0].interpret(thread);
        } else {
          return pl.operate(thread, this);
        }
      };
      Var.prototype.compare = function(obj) {
        if (this.id < obj.id) {
          return -1;
        } else if (this.id > obj.id) {
          return 1;
        } else {
          return 0;
        }
      };
      Num.prototype.compare = function(obj) {
        if (this.value === obj.value && this.is_float === obj.is_float) {
          return 0;
        } else if (this.value < obj.value || this.value === obj.value && this.is_float && !obj.is_float) {
          return -1;
        } else if (this.value > obj.value) {
          return 1;
        }
      };
      Term.prototype.compare = function(obj) {
        if (this.args.length < obj.args.length || this.args.length === obj.args.length && this.id < obj.id) {
          return -1;
        } else if (this.args.length > obj.args.length || this.args.length === obj.args.length && this.id > obj.id) {
          return 1;
        } else {
          for (var i2 = 0; i2 < this.args.length; i2++) {
            var arg = pl.compare(this.args[i2], obj.args[i2]);
            if (arg !== 0) {
              return arg;
            }
          }
          return 0;
        }
      };
      Substitution.prototype.lookup = function(variable) {
        if (this.links[variable]) {
          return this.links[variable];
        } else {
          return null;
        }
      };
      Substitution.prototype.filter = function(predicate) {
        var links = {};
        for (var id in this.links) {
          if (!this.links.hasOwnProperty(id))
            continue;
          var value = this.links[id];
          if (predicate(id, value)) {
            links[id] = value;
          }
        }
        return new Substitution(links, this.attrs);
      };
      Substitution.prototype.exclude = function(variables) {
        var links = {};
        for (var variable in this.links) {
          if (!this.links.hasOwnProperty(variable))
            continue;
          if (indexOf(variables, variable) === -1) {
            links[variable] = this.links[variable];
          }
        }
        return new Substitution(links, this.attrs);
      };
      Substitution.prototype.add = function(variable, value) {
        this.links[variable] = value;
      };
      Substitution.prototype.domain = function(plain) {
        var f = plain === true ? function(x2) {
          return x2;
        } : function(x2) {
          return new Var(x2);
        };
        var vars = [];
        for (var x in this.links)
          vars.push(f(x));
        return vars;
      };
      Substitution.prototype.get_attribute = function(variable, module3) {
        if (this.attrs[variable])
          return this.attrs[variable][module3];
      };
      Substitution.prototype.set_attribute = function(variable, module3, value) {
        var subs = new Substitution(this.links);
        for (var v in this.attrs) {
          if (v === variable) {
            subs.attrs[v] = {};
            for (var m in this.attrs[v]) {
              subs.attrs[v][m] = this.attrs[v][m];
            }
          } else {
            subs.attrs[v] = this.attrs[v];
          }
        }
        if (!subs.attrs[variable]) {
          subs.attrs[variable] = {};
        }
        subs.attrs[variable][module3] = value;
        return subs;
      };
      Substitution.prototype.has_attributes = function(variable) {
        return this.attrs[variable] && this.attrs[variable] !== {};
      };
      Var.prototype.compile = function() {
        return 'new pl.type.Var("' + this.id.toString() + '")';
      };
      Num.prototype.compile = function() {
        return "new pl.type.Num(" + this.value.toString() + ", " + this.is_float.toString() + ")";
      };
      Term.prototype.compile = function() {
        return 'new pl.type.Term("' + this.id.replace(/"/g, '\\"') + '", [' + map(this.args, function(arg) {
          return arg.compile();
        }) + "])";
      };
      Rule.prototype.compile = function() {
        return "new pl.type.Rule(" + this.head.compile() + ", " + (this.body === null ? "null" : this.body.compile()) + ")";
      };
      Session.prototype.compile = function() {
        var str, obj = [], rules2;
        for (var _indicator in this.modules.user.rules) {
          if (!this.modules.user.rules.hasOwnProperty(_indicator))
            continue;
          var indicator2 = this.modules.user.rules[_indicator];
          rules2 = [];
          str = '"' + _indicator + '": [';
          for (var i2 = 0; i2 < indicator2.length; i2++) {
            rules2.push(indicator2[i2].compile());
          }
          str += rules2.join();
          str += "]";
          obj.push(str);
        }
        return "{" + obj.join() + "};";
      };
      Module.prototype.compile = function() {
        var length = 0;
        var dependencies = 0;
        var str = "var pl;\n";
        str += "(function(pl) {\n";
        str += '	var name = "' + this.id + '";\n';
        str += "	var predicates = function() {\n";
        str += "		return {\n";
        for (var prop in this.rules) {
          if (length > 0)
            str += ",\n";
          str += '			"' + prop + '": ';
          if (typeof this.rules[prop] === "function") {
            str += this.rules[prop];
          } else {
            str += "[\n";
            for (var i2 = 0; i2 < this.rules[prop].length; i2++) {
              str += "				" + this.rules[prop][i2].compile();
              if (i2 < this.rules[prop].length - 1)
                str += ",";
              str += "\n";
            }
            str += "			]";
          }
          length++;
        }
        str += "\n		};\n";
        str += "	};\n";
        str += "	var exports = [";
        for (var i2 = 0; i2 < this.exports.length; i2++) {
          if (i2 > 0)
            str += ", ";
          str += '"' + this.exports[i2] + '"';
        }
        str += "];\n";
        str += "	var options = function() {\n";
        str += "		return {\n";
        str += "			dependencies: [";
        for (var prop in this.modules) {
          if (dependencies > 0)
            str += ", ";
          str += '"' + prop + '"';
          dependencies++;
        }
        str += "]\n";
        str += "		};\n";
        str += "};\n";
        str += "	if(typeof module !== 'undefined') {\n";
        str += "		module.exports = function(p) {\n";
        str += "			pl = p;\n";
        str += "			new pl.type.Module(name, predicates(), exports, options());\n";
        str += "		};\n";
        str += "	} else {\n";
        str += "		new pl.type.Module(name, predicates(), exports, options());\n";
        str += "	}\n";
        str += "})(pl);\n";
        return str;
      };
      Var.prototype.toJavaScript = function() {
        return this.toString();
      };
      Num.prototype.toJavaScript = function() {
        return this.value;
      };
      Term.prototype.toJavaScript = function(options2) {
        if (this.args.length === 0 && this.indicator !== "[]/0") {
          return this.toString(options2);
        } else if (pl.type.is_list(this)) {
          var all_obj = true;
          var arr = [];
          var obj = {};
          var pointer = this;
          var value;
          while (pointer.indicator === "./2") {
            value = pointer.args[0].toJavaScript(options2);
            arr.push(value);
            all_obj = all_obj && pl.type.is_term(pointer.args[0]) && pointer.args[0].indicator === "-/2" && pl.type.is_atom(pointer.args[0].args[0]);
            if (all_obj)
              obj[pointer.args[0].args[0].id] = pointer.args[0].args[1].toJavaScript(options2);
            pointer = pointer.args[1];
          }
          if (pointer.indicator === "[]/0")
            return all_obj && arr.length > 0 ? obj : arr;
        }
        return this.toString(options2);
      };
      Rule.prototype.singleton_variables = function(include_named) {
        include_named = include_named || false;
        var variables = this.head.variables();
        var count = {};
        var singleton = [];
        if (this.body !== null)
          variables = variables.concat(this.body.variables());
        for (var i2 = 0; i2 < variables.length; i2++) {
          if (count[variables[i2]] === void 0)
            count[variables[i2]] = 0;
          count[variables[i2]]++;
        }
        for (var key in count) {
          if (!count.hasOwnProperty(key))
            continue;
          if (count[key] === 1) {
            var charcode = codePointAt(key, 1);
            if (!include_named || key === "_") {
              if (key === "_" || key[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
                continue;
            }
            singleton.push(key);
          }
        }
        return singleton;
      };
      var nodejs_flag = typeof process !== "undefined" && !process.browser;
      var nodejs_arguments = nodejs_flag ? arrayToList(map(process.argv.slice(1), function(arg) {
        return new Term(arg);
      })) : new Term("[]", []);
      var pl = {
        __env: nodejs_flag ? global : window,
        modules: {},
        version,
        parser: {
          tokenizer: Tokenizer,
          expression: parseExpr
        },
        utils: {
          str_indicator,
          codePointAt,
          fromCodePoint,
          stringLength
        },
        statistics: {
          getCountTerms: function() {
            return term_ref;
          }
        },
        fromJavaScript: {
          test: {
            boolean: function(obj, tobj) {
              return obj === true || obj === false;
            },
            number: function(obj, tobj) {
              return typeof obj === "number";
            },
            string: function(obj, tobj) {
              return typeof obj === "string";
            },
            list: function(obj, tobj) {
              return obj instanceof Array;
            },
            variable: function(obj, tobj) {
              return obj === void 0;
            },
            object: function(obj, tobj) {
              tobj = tobj === void 0 ? false : tobj;
              return tobj && !(obj instanceof Array) && typeof obj === "object";
            },
            any: function(_, tobj) {
              return true;
            }
          },
          conversion: {
            boolean: function(obj, tobj) {
              return new Term(obj ? "true" : "false", []);
            },
            number: function(obj, tobj) {
              return new Num(obj, obj % 1 !== 0);
            },
            string: function(obj, tobj) {
              return new Term(obj, []);
            },
            list: function(obj, tobj) {
              tobj = tobj === void 0 ? false : tobj;
              var arr = [];
              var elem;
              for (var i2 = 0; i2 < obj.length; i2++) {
                elem = pl.fromJavaScript.apply(obj[i2], tobj);
                if (elem === void 0)
                  return void 0;
                arr.push(elem);
              }
              return arrayToList(arr);
            },
            variable: function(obj, tobj) {
              return new Var("_");
            },
            object: function(obj, tobj) {
              tobj = tobj === void 0 ? false : tobj;
              var list = new Term("[]", []);
              var arr = [];
              for (var prop in obj) {
                if (!obj.hasOwnProperty(prop))
                  continue;
                arr.push(new Term("-", [
                  pl.fromJavaScript.apply(prop, tobj),
                  pl.fromJavaScript.apply(obj[prop], tobj)
                ]));
              }
              return arrayToList(arr);
            },
            any: function(obj, tobj) {
              return void 0;
            }
          },
          apply: function(obj, tobj) {
            tobj = tobj === void 0 ? false : tobj;
            for (var i2 in pl.fromJavaScript.test)
              if (i2 !== "any" && pl.fromJavaScript.test[i2](obj, tobj))
                return pl.fromJavaScript.conversion[i2](obj, tobj);
            return pl.fromJavaScript.conversion.any(obj, tobj);
          }
        },
        type: {
          Var,
          Num,
          Term,
          Rule,
          State,
          Stream,
          Module,
          Thread,
          Session,
          Substitution,
          File: TauFile,
          Directory: TauDirectory,
          order: [Var, Num, Term, Stream],
          compare: function(x, y) {
            var ord_x = indexOf(pl.type.order, x.constructor);
            var ord_y = indexOf(pl.type.order, y.constructor);
            if (ord_x < ord_y) {
              return -1;
            } else if (ord_x > ord_y) {
              return 1;
            } else {
              if (x.constructor === Num) {
                if (x.is_float && y.is_float)
                  return 0;
                else if (x.is_float)
                  return -1;
                else if (y.is_float)
                  return 1;
              }
              return 0;
            }
          },
          is_substitution: function(obj) {
            return obj instanceof Substitution;
          },
          is_state: function(obj) {
            return obj instanceof State;
          },
          is_rule: function(obj) {
            return obj instanceof Rule;
          },
          is_variable: function(obj) {
            return obj instanceof Var;
          },
          is_stream: function(obj) {
            return obj instanceof Stream;
          },
          is_anonymous_var: function(obj) {
            return obj instanceof Var && obj.id === "_";
          },
          is_callable: function(obj) {
            return obj instanceof Term && (indexOf([",/2", ";/2", "->/2"], obj.indicator) === -1 || pl.type.is_callable(obj.args[0]) && pl.type.is_callable(obj.args[1])) || obj instanceof Var;
          },
          is_number: function(obj) {
            return obj instanceof Num;
          },
          is_integer: function(obj) {
            return obj instanceof Num && !obj.is_float;
          },
          is_float: function(obj) {
            return obj instanceof Num && obj.is_float;
          },
          is_term: function(obj) {
            return obj instanceof Term;
          },
          is_atom: function(obj) {
            return obj instanceof Term && obj.args.length === 0;
          },
          is_ground: function(obj) {
            if (obj instanceof Var)
              return false;
            if (obj instanceof Term) {
              for (var i2 = 0; i2 < obj.args.length; i2++)
                if (!pl.type.is_ground(obj.args[i2]))
                  return false;
            }
            return true;
          },
          is_atomic: function(obj) {
            return obj instanceof Term && obj.args.length === 0 || obj instanceof Num;
          },
          is_compound: function(obj) {
            return obj instanceof Term && obj.args.length > 0;
          },
          is_list: function(obj) {
            return obj instanceof Term && (obj.indicator === "[]/0" || obj.indicator === "./2");
          },
          is_empty_list: function(obj) {
            return obj instanceof Term && obj.indicator === "[]/0";
          },
          is_non_empty_list: function(obj) {
            return obj instanceof Term && obj.indicator === "./2";
          },
          is_fully_list: function(obj) {
            while (obj instanceof Term && obj.indicator === "./2") {
              obj = obj.args[1];
            }
            return obj instanceof Var || obj instanceof Term && obj.indicator === "[]/0";
          },
          is_instantiated_list: function(obj) {
            while (obj instanceof Term && obj.indicator === "./2") {
              obj = obj.args[1];
            }
            return obj instanceof Term && obj.indicator === "[]/0";
          },
          is_unitary_list: function(obj) {
            return obj instanceof Term && obj.indicator === "./2" && obj.args[1] instanceof Term && obj.args[1].indicator === "[]/0";
          },
          is_character: function(obj) {
            return obj instanceof Term && obj.args.length === 0 && (obj.id.length === 1 || obj.id.length > 0 && obj.id.length <= 2 && codePointAt(obj.id, 0) >= 65536);
          },
          is_in_character: function(obj) {
            return obj instanceof Term && (obj.indicator === "end_of_file/0" || obj.id.length === 1 || obj.id.length > 0 && obj.id.length <= 2 && codePointAt(obj.id, 0) >= 65536);
          },
          is_character_code: function(obj) {
            return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 1114111;
          },
          is_in_character_code: function(obj) {
            return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 1114111;
          },
          is_byte: function(obj) {
            return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 255;
          },
          is_in_byte: function(obj) {
            return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 255;
          },
          is_operator: function(obj) {
            return obj instanceof Term && pl.arithmetic.evaluation[obj.indicator];
          },
          is_directive: function(obj) {
            return obj instanceof Term && (pl.directive[obj.indicator] !== void 0 || pl.directive[obj.id + "/*"] !== void 0);
          },
          is_builtin: function(obj) {
            return obj instanceof Term && pl.builtin.rules.hasOwnProperty(obj.indicator) && obj.indicator !== "goal_expansion/2";
          },
          is_error: function(obj) {
            return obj instanceof Term && obj.indicator === "throw/1";
          },
          is_error_state: function(obj) {
            return pl.type.is_state(obj) && obj.error && obj.error === true;
          },
          is_predicate_indicator: function(obj) {
            return obj instanceof Term && obj.indicator === "//2" && obj.args[0] instanceof Term && obj.args[0].args.length === 0 && obj.args[1] instanceof Num && obj.args[1].is_float === false;
          },
          is_flag: function(obj) {
            return obj instanceof Term && obj.args.length === 0 && pl.flag[obj.id] !== void 0;
          },
          is_value_flag: function(flag, obj) {
            if (!pl.type.is_flag(flag))
              return false;
            for (var value in pl.flag[flag.id].allowed) {
              if (!pl.flag[flag.id].allowed.hasOwnProperty(value))
                continue;
              if (pl.flag[flag.id].allowed[value].equals(obj))
                return true;
            }
            return false;
          },
          is_io_mode: function(obj) {
            return pl.type.is_atom(obj) && ["read", "write", "append"].indexOf(obj.id) !== -1;
          },
          is_stream_option: function(obj) {
            return pl.type.is_term(obj) && (obj.indicator === "alias/1" && pl.type.is_atom(obj.args[0]) || obj.indicator === "reposition/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") || obj.indicator === "type/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary") || obj.indicator === "eof_action/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset"));
          },
          is_stream_position: function(obj) {
            return pl.type.is_term(obj) && (obj.indicator === "end_of_stream/0" || obj.indicator === "past_end_of_stream/0" || obj.indicator === "position/3" && pl.type.is_integer(obj.args[0]) && pl.type.is_integer(obj.args[1]) && pl.type.is_integer(obj.args[2]));
          },
          is_stream_property: function(obj) {
            return pl.type.is_term(obj) && (obj.indicator === "input/0" || obj.indicator === "output/0" || obj.indicator === "alias/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0])) || obj.indicator === "file_name/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0])) || obj.indicator === "reposition/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false")) || obj.indicator === "type/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary")) || obj.indicator === "mode/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "read" || obj.args[0].id === "write" || obj.args[0].id === "append")) || obj.indicator === "eof_action/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")) || obj.indicator === "end_of_stream/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "at" || obj.args[0].id === "past" || obj.args[0].id === "not")) || obj.indicator === "position/1" && (pl.type.is_variable(obj.args[0]) || pl.type.is_term(obj.args[0]) && obj.args[0].indicator === "position/3" && (pl.type.is_variable(obj.args[0].args[0]) || pl.type.is_integer(obj.args[0].args[0])) && (pl.type.is_variable(obj.args[0].args[1]) || pl.type.is_integer(obj.args[0].args[1])) && (pl.type.is_variable(obj.args[0].args[2]) || pl.type.is_integer(obj.args[0].args[2]))));
          },
          is_streamable: function(obj) {
            return obj.__proto__.stream !== void 0;
          },
          is_read_option: function(obj) {
            return pl.type.is_term(obj) && ["variables/1", "variable_names/1", "singletons/1"].indexOf(obj.indicator) !== -1;
          },
          is_write_option: function(obj) {
            return pl.type.is_term(obj) && (obj.indicator === "quoted/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") || obj.indicator === "ignore_ops/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") || obj.indicator === "numbervars/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") || obj.indicator === "variable_names/1" && pl.type.is_fully_list(obj.args[0]));
          },
          is_close_option: function(obj) {
            return pl.type.is_term(obj) && obj.indicator === "force/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false");
          },
          is_modifiable_flag: function(obj) {
            return pl.type.is_flag(obj) && pl.flag[obj.id].changeable;
          },
          is_module: function(obj) {
            return obj instanceof Module;
          },
          is_file: function(obj) {
            return obj instanceof TauFile;
          },
          is_directory: function(obj) {
            return obj instanceof TauDirectory;
          },
          is_predicate_property: function(obj) {
            return pl.type.is_term(obj) && (obj.indicator === "built_in/0" || obj.indicator === "static/0" || obj.indicator === "dynamic/0" || obj.indicator === "native_code/0" || obj.indicator === "multifile/0" || obj.indicator === "meta_predicate/1");
          },
          is_meta_argument_specifier: function(obj) {
            return pl.type.is_integer(obj) && obj.value >= 0 || pl.type.is_atom(obj) && indexOf(["+", "-", "?", "*", "^", ":", "//"], obj.id) !== -1;
          },
          is_time_property: function(obj) {
            return pl.type.is_term(obj) && obj.args.length === 1 && (pl.type.is_variable(obj.args[0]) || pl.type.is_integer(obj.args[0])) && indexOf(["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"], obj.id) !== -1;
          }
        },
        arithmetic: {
          evaluation: {
            "e/0": {
              type_args: null,
              type_result: true,
              fn: function(_) {
                return Math.E;
              }
            },
            "pi/0": {
              type_args: null,
              type_result: true,
              fn: function(_) {
                return Math.PI;
              }
            },
            "tau/0": {
              type_args: null,
              type_result: true,
              fn: function(_) {
                return 2 * Math.PI;
              }
            },
            "epsilon/0": {
              type_args: null,
              type_result: true,
              fn: function(_) {
                return Number.EPSILON;
              }
            },
            "+/1": {
              type_args: null,
              type_result: null,
              fn: function(x, _) {
                return x;
              }
            },
            "-/1": {
              type_args: null,
              type_result: null,
              fn: function(x, _) {
                return -x;
              }
            },
            "\\/1": {
              type_args: false,
              type_result: false,
              fn: function(x, _) {
                return ~x;
              }
            },
            "abs/1": {
              type_args: null,
              type_result: null,
              fn: function(x, _) {
                return Math.abs(x);
              }
            },
            "sign/1": {
              type_args: null,
              type_result: null,
              fn: function(x, _) {
                return Math.sign(x);
              }
            },
            "float_integer_part/1": {
              type_args: true,
              type_result: false,
              fn: function(x, _) {
                return parseInt(x);
              }
            },
            "float_fractional_part/1": {
              type_args: true,
              type_result: true,
              fn: function(x, _) {
                return x - parseInt(x);
              }
            },
            "float/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return parseFloat(x);
              }
            },
            "floor/1": {
              type_args: true,
              type_result: false,
              fn: function(x, _) {
                return Math.floor(x);
              }
            },
            "truncate/1": {
              type_args: true,
              type_result: false,
              fn: function(x, _) {
                return parseInt(x);
              }
            },
            "round/1": {
              type_args: true,
              type_result: false,
              fn: function(x, _) {
                return Math.round(x);
              }
            },
            "ceiling/1": {
              type_args: true,
              type_result: false,
              fn: function(x, _) {
                return Math.ceil(x);
              }
            },
            "sin/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.sin(x);
              }
            },
            "cos/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.cos(x);
              }
            },
            "tan/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.tan(x);
              }
            },
            "asin/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return Math.abs(x) <= 1 ? Math.asin(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "acos/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return Math.abs(x) <= 1 ? Math.acos(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "atan/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.atan(x);
              }
            },
            "atan2/2": {
              type_args: null,
              type_result: true,
              fn: function(x, y, thread) {
                return x === 0 && y === 0 ? pl.error.evaluation("undefined", thread.__call_indicator) : Math.atan2(x, y);
              }
            },
            "acosh/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return x >= 1 ? Math.acosh(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "asinh/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.asinh(x);
              }
            },
            "atanh/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return Math.abs(x) < 1 ? Math.atanh(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "cosh/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.cosh(x);
              }
            },
            "sinh/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.sinh(x);
              }
            },
            "tanh/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.tanh(x);
              }
            },
            "exp/1": {
              type_args: null,
              type_result: true,
              fn: function(x, _) {
                return Math.exp(x);
              }
            },
            "sqrt/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return x >= 0 ? Math.sqrt(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "log/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return x > 0 ? Math.log(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "log/2": {
              type_args: null,
              type_result: true,
              fn: function(x, y, thread) {
                return x > 0 && y > 0 ? Math.log(y) / Math.log(x) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "log10/1": {
              type_args: null,
              type_result: true,
              fn: function(x, thread) {
                return x > 0 ? Math.log(x) / Math.log(10) : pl.error.evaluation("undefined", thread.__call_indicator);
              }
            },
            "+/2": {
              type_args: null,
              type_result: null,
              fn: function(x, y, _) {
                return x + y;
              }
            },
            "-/2": {
              type_args: null,
              type_result: null,
              fn: function(x, y, _) {
                return x - y;
              }
            },
            "*/2": {
              type_args: null,
              type_result: null,
              fn: function(x, y, _) {
                return x * y;
              }
            },
            "//2": {
              type_args: null,
              type_result: true,
              fn: function(x, y, thread) {
                return y ? x / y : pl.error.evaluation("zero_divisor", thread.__call_indicator);
              }
            },
            "///2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, thread) {
                return y ? Math.trunc(x / y) : pl.error.evaluation("zero_divisor", thread.__call_indicator);
              }
            },
            "div/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, thread) {
                return y ? Math.floor(x / y) : pl.error.evaluation("zero_divisor", thread.__call_indicator);
              }
            },
            "**/2": {
              type_args: null,
              type_result: true,
              fn: function(x, y, thread) {
                return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y);
              }
            },
            "^/2": {
              type_args: null,
              type_result: null,
              fn: function(x, y, thread) {
                return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y);
              }
            },
            "<</2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, _) {
                return x << y;
              }
            },
            ">>/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, _) {
                return x >> y;
              }
            },
            "/\\/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, _) {
                return x & y;
              }
            },
            "\\//2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, _) {
                return x | y;
              }
            },
            "xor/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, _) {
                return x ^ y;
              }
            },
            "rem/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, thread) {
                return y ? x % y : pl.error.evaluation("zero_divisor", thread.__call_indicator);
              }
            },
            "mod/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, thread) {
                return y ? x - Math.floor(x / y) * y : pl.error.evaluation("zero_divisor", thread.__call_indicator);
              }
            },
            "max/2": {
              type_args: null,
              type_result: null,
              fn: function(x, y, _) {
                return Math.max(x, y);
              }
            },
            "min/2": {
              type_args: null,
              type_result: null,
              fn: function(x, y, _) {
                return Math.min(x, y);
              }
            },
            "gcd/2": {
              type_args: false,
              type_result: false,
              fn: function(x, y, _) {
                return gcd(x, y);
              }
            }
          }
        },
        directive: {
          "dynamic/1": function(thread, atom, options2) {
            var indicators = atom.args[0];
            if (!pl.type.is_list(indicators))
              indicators = arrayToList([indicators]);
            var pointer = indicators;
            while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
              indicator = pointer.args[0];
              if (pl.type.is_variable(indicator)) {
                thread.throw_warning(pl.error.instantiation(atom.indicator));
              } else if (!pl.type.is_compound(indicator) || indicator.indicator !== "//2") {
                thread.throw_warning(pl.error.type("predicate_indicator", indicator, atom.indicator));
              } else if (pl.type.is_variable(indicator.args[0]) || pl.type.is_variable(indicator.args[1])) {
                thread.throw_warning(pl.error.instantiation(atom.indicator));
              } else if (!pl.type.is_atom(indicator.args[0])) {
                thread.throw_warning(pl.error.type("atom", indicator.args[0], atom.indicator));
              } else if (!pl.type.is_integer(indicator.args[1])) {
                thread.throw_warning(pl.error.type("integer", indicator.args[1], atom.indicator));
              } else {
                var key = indicator.args[0].id + "/" + indicator.args[1].value;
                var get_module = thread.session.modules[options2.context_module];
                get_module.public_predicates[key] = true;
                if (!get_module.rules[key])
                  get_module.rules[key] = [];
              }
              pointer = pointer.args[1];
            }
            if (pl.type.is_variable(pointer)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
              thread.throw_warning(pl.error.type("predicate_indicator", indicator, atom.indicator));
            }
          },
          "dynamic/*": function(thread, atom) {
            for (var i2 = 0; i2 < atom.args.length; i2++) {
              pl.directive["dynamic/1"](thread, new Term("dynamic", [atom.args[i2]]));
            }
          },
          "multifile/1": function(thread, atom, options2) {
            var indicator2 = atom.args[0];
            if (pl.type.is_variable(indicator2)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_compound(indicator2) || indicator2.indicator !== "//2") {
              thread.throw_warning(pl.error.type("predicate_indicator", indicator2, atom.indicator));
            } else if (pl.type.is_variable(indicator2.args[0]) || pl.type.is_variable(indicator2.args[1])) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_atom(indicator2.args[0])) {
              thread.throw_warning(pl.error.type("atom", indicator2.args[0], atom.indicator));
            } else if (!pl.type.is_integer(indicator2.args[1])) {
              thread.throw_warning(pl.error.type("integer", indicator2.args[1], atom.indicator));
            } else {
              var predicate_indicator = atom.args[0].args[0].id + "/" + atom.args[0].args[1].value;
              var get_module = thread.session.modules[options2.context_module];
              get_module.multifile_predicates[predicate_indicator] = true;
              if (!get_module.rules.hasOwnProperty(predicate_indicator)) {
                get_module.rules[predicate_indicator] = [];
                get_module.public_predicates[predicate_indicator] = false;
              }
            }
          },
          "meta_predicate/1": function(thread, atom, options2) {
            var options2 = options2 === void 0 ? {} : options2;
            var head = atom.args[0];
            if (pl.type.is_variable(head)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_callable(head)) {
              thread.throw_warning(pl.error.type("callable", head, atom.indicator));
            } else {
              for (var i2 = 0; i2 < head.args.length; i2++) {
                var arg = head.args[i2];
                if (!pl.type.is_meta_argument_specifier(arg)) {
                  thread.throw_warning(pl.error.type("meta_argument_specifier", arg, atom.indicator));
                  return;
                }
              }
              thread.session.modules[options2.context_module].meta_predicates[head.indicator] = head;
            }
          },
          "set_prolog_flag/2": function(thread, atom) {
            var flag = atom.args[0], value = atom.args[1];
            if (pl.type.is_variable(flag) || pl.type.is_variable(value)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_atom(flag)) {
              thread.throw_warning(pl.error.type("atom", flag, atom.indicator));
            } else if (!pl.type.is_flag(flag)) {
              thread.throw_warning(pl.error.domain("prolog_flag", flag, atom.indicator));
            } else if (!pl.type.is_modifiable_flag(flag)) {
              thread.throw_warning(pl.error.permission("modify", "flag", flag, atom.indicator));
            } else if (!pl.type.is_value_flag(flag, value)) {
              thread.throw_warning(pl.error.domain("flag_value", new Term("+", [flag, value]), atom.indicator));
            } else {
              thread.session.flag[flag.id] = value;
            }
          },
          "module/2": function(thread, atom, options2) {
            var options2 = options2 === void 0 ? {} : options2;
            options2.context_module = options2.context_module === void 0 ? "user" : options2.context_module;
            var module_id = atom.args[0], exports3 = atom.args[1];
            if (pl.type.is_variable(module_id) || pl.type.is_variable(exports3)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_atom(module_id)) {
              thread.throw_warning(pl.error.type("atom", module_id, atom.indicator));
            } else if (!pl.type.is_list(exports3)) {
              thread.throw_warning(pl.error.type("list", exports3, atom.indicator));
            } else {
              if (!pl.type.is_module(thread.session.modules[module_id.indicator])) {
                var pointer = exports3;
                var indicators = [];
                while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
                  var predicate = pointer.args[0];
                  if (!pl.type.is_predicate_indicator(predicate)) {
                    thread.throw_warning(pl.error.type("predicate_indicator", predicate, atom.indicator));
                  } else {
                    indicators.push(predicate.args[0].id + "/" + predicate.args[1].value);
                  }
                  pointer = pointer.args[1];
                }
                if (pl.type.is_variable(pointer)) {
                  thread.throw_warning(pl.error.instantiation(atom.indicator));
                } else if (!pl.type.is_empty_list(pointer)) {
                  thread.throw_warning(pl.error.type("list", exports3, atom.indicator));
                }
                var new_module = new Module(module_id.id, {}, indicators, {
                  session: thread.session
                });
                thread.session.modules[module_id.id] = new_module;
                thread.session.modules[options2.context_module].modules[module_id.id] = new_module;
                options2.context_module = module_id.id;
              } else {
                thread.throw_warning(pl.error.permission("create", "module", module_id, atom.indicator));
              }
            }
          },
          "use_module/1": function(thread, atom, options2) {
            var options2 = options2 === void 0 ? {} : options2;
            options2.context_module = options2.context_module === void 0 ? "user" : options2.context_module;
            var module_id = atom.args[0];
            if (pl.type.is_variable(module_id)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_term(module_id)) {
              thread.throw_warning(pl.error.type("term", module_id, atom.indicator));
            } else {
              if (module_id.indicator === "library/1") {
                var name = module_id.args[0].id;
                var get_module = pl.modules[name];
                if (pl.type.is_module(get_module)) {
                  if (!thread.session.modules[options2.context_module].modules.hasOwnProperty(name)) {
                    thread.session.modules[name] = get_module;
                    thread.session.modules[options2.context_module].modules[name] = get_module;
                    for (var i2 = 0; i2 < get_module.dependencies.length; i2++) {
                      var term = new Term("use_module", [new Term("library", [new Term(get_module.dependencies[i2])])]);
                      pl.directive["use_module/1"](thread, term, {
                        context_module: name
                      });
                    }
                  }
                } else {
                  thread.throw_warning(pl.error.existence("module", module_id, atom.indicator));
                }
              } else {
                var name = module_id.id;
                thread.consult(name, {
                  context_module: options2.context_module,
                  text: false,
                  success: function() {
                    parseProgram(thread, options2.string, options2);
                  },
                  error: function() {
                    options2.error(pl.error.existence("module", module_id, atom.indicator));
                  }
                });
                return true;
              }
            }
          },
          "char_conversion/2": function(thread, atom, options2) {
            var inchar = atom.args[0], outchar = atom.args[1];
            if (pl.type.is_variable(inchar) || pl.type.is_variable(outchar)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_character(inchar)) {
              thread.throw_warning(pl.error.type("character", inchar, atom.indicator));
            } else if (!pl.type.is_character(outchar)) {
              thread.throw_warning(pl.error.type("character", outchar, atom.indicator));
            } else {
              if (inchar.id === outchar.id) {
                delete thread.session.__char_conversion[inchar.id];
              } else {
                thread.session.__char_conversion[inchar.id] = outchar.id;
              }
              options2.tokens = options2.tokenizer.get_tokens(options2.current_token);
              options2.current_token = 0;
              return true;
            }
          },
          "op/3": function(thread, atom) {
            var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
            if (pl.type.is_atom(operators))
              operators = new Term(".", [operators, new Term("[]")]);
            if (pl.type.is_variable(priority) || pl.type.is_variable(type) || pl.type.is_variable(operators)) {
              thread.throw_warning(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_integer(priority)) {
              thread.throw_warning(pl.error.type("integer", priority, atom.indicator));
            } else if (!pl.type.is_atom(type)) {
              thread.throw_warning(pl.error.type("atom", type, atom.indicator));
            } else if (!pl.type.is_list(operators)) {
              thread.throw_warning(pl.error.type("list", operators, atom.indicator));
            } else if (pl.type.is_empty_list(operators)) {
              thread.throw_warning(pl.error.permission("create", "operator", operators, atom.indicator));
            } else {
              var pointer = operators;
              while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
                var operator = pointer.args[0];
                pointer = pointer.args[1];
                if (pl.type.is_variable(operator)) {
                  thread.throw_warning(pl.error.instantiation(atom.indicator));
                } else if (!pl.type.is_atom(operator)) {
                  thread.throw_warning(pl.error.type("atom", operator, atom.indicator));
                } else if (priority.value < 0 || priority.value > 1200) {
                  thread.throw_warning(pl.error.domain("operator_priority", priority, atom.indicator));
                } else if (operator.id === ",") {
                  thread.throw_error(pl.error.permission("modify", "operator", operator, atom.indicator));
                } else if (operator.id === "{}") {
                  thread.throw_warning(pl.error.permission("create", "operator", operator, atom.indicator));
                } else if (operator.id === "[]") {
                  thread.throw_warning(pl.error.permission("create", "operator", operator, atom.indicator));
                } else if (operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3)) {
                  thread.throw_warning(pl.error.permission("create", "operator", operator, atom.indicator));
                } else if (["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf(type.id) === -1) {
                  thread.throw_warning(pl.error.domain("operator_specifier", type, atom.indicator));
                } else {
                  var fix = { prefix: null, infix: null, postfix: null };
                  for (var p in thread.session.__operators) {
                    if (!thread.session.__operators.hasOwnProperty(p))
                      continue;
                    var classes = thread.session.__operators[p][operator.id];
                    if (classes) {
                      if (indexOf(classes, "fx") !== -1) {
                        fix.prefix = { priority: p, type: "fx" };
                      }
                      if (indexOf(classes, "fy") !== -1) {
                        fix.prefix = { priority: p, type: "fy" };
                      }
                      if (indexOf(classes, "xf") !== -1) {
                        fix.postfix = { priority: p, type: "xf" };
                      }
                      if (indexOf(classes, "yf") !== -1) {
                        fix.postfix = { priority: p, type: "yf" };
                      }
                      if (indexOf(classes, "xfx") !== -1) {
                        fix.infix = { priority: p, type: "xfx" };
                      }
                      if (indexOf(classes, "xfy") !== -1) {
                        fix.infix = { priority: p, type: "xfy" };
                      }
                      if (indexOf(classes, "yfx") !== -1) {
                        fix.infix = { priority: p, type: "yfx" };
                      }
                    }
                  }
                  var current_class;
                  switch (type.id) {
                    case "fy":
                    case "fx":
                      current_class = "prefix";
                      break;
                    case "yf":
                    case "xf":
                      current_class = "postfix";
                      break;
                    default:
                      current_class = "infix";
                      break;
                  }
                  if (fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
                    thread.throw_warning(pl.error.permission("create", "operator", operator, atom.indicator));
                  } else {
                    if (fix[current_class]) {
                      remove(thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type);
                      if (thread.session.__operators[fix[current_class].priority][operator.id].length === 0) {
                        delete thread.session.__operators[fix[current_class].priority][operator.id];
                      }
                    }
                    if (priority.value > 0) {
                      if (!thread.session.__operators[priority.value])
                        thread.session.__operators[priority.value.toString()] = {};
                      if (!thread.session.__operators[priority.value][operator.id])
                        thread.session.__operators[priority.value][operator.id] = [];
                      thread.session.__operators[priority.value][operator.id].push(type.id);
                    }
                  }
                }
              }
              if (pl.type.is_variable(pointer)) {
                thread.throw_warning(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
                thread.throw_warning(pl.error.type("list", operators, atom.indicator));
                return;
              }
            }
          },
          "initialization/1": function(thread, atom, options2) {
            var goal = atom.args[0];
            options2.initialization.push(goal);
          }
        },
        flag: {
          bounded: {
            allowed: [new Term("true"), new Term("false")],
            value: new Term("true"),
            changeable: false
          },
          max_integer: {
            allowed: [new Num(Number.MAX_SAFE_INTEGER)],
            value: new Num(Number.MAX_SAFE_INTEGER),
            changeable: false
          },
          min_integer: {
            allowed: [new Num(Number.MIN_SAFE_INTEGER)],
            value: new Num(Number.MIN_SAFE_INTEGER),
            changeable: false
          },
          integer_rounding_function: {
            allowed: [new Term("down"), new Term("toward_zero")],
            value: new Term("toward_zero"),
            changeable: false
          },
          char_conversion: {
            allowed: [new Term("on"), new Term("off")],
            value: new Term("on"),
            changeable: true
          },
          debug: {
            allowed: [new Term("on"), new Term("off")],
            value: new Term("off"),
            changeable: true
          },
          max_arity: {
            allowed: [new Term("unbounded")],
            value: new Term("unbounded"),
            changeable: false
          },
          unknown: {
            allowed: [new Term("error"), new Term("fail"), new Term("warning")],
            value: new Term("error"),
            changeable: true
          },
          double_quotes: {
            allowed: [new Term("chars"), new Term("codes"), new Term("atom")],
            value: new Term("chars"),
            changeable: true
          },
          occurs_check: {
            allowed: [new Term("false"), new Term("true")],
            value: new Term("false"),
            changeable: true
          },
          dialect: {
            allowed: [new Term("tau")],
            value: new Term("tau"),
            changeable: false
          },
          version_data: {
            allowed: [new Term("tau", [new Num(version.major, false), new Num(version.minor, false), new Num(version.patch, false), new Term(version.status)])],
            value: new Term("tau", [new Num(version.major, false), new Num(version.minor, false), new Num(version.patch, false), new Term(version.status)]),
            changeable: false
          },
          nodejs: {
            allowed: [new Term("true"), new Term("false")],
            value: new Term(nodejs_flag ? "true" : "false"),
            changeable: false
          },
          argv: {
            allowed: [nodejs_arguments],
            value: nodejs_arguments,
            changeble: false
          }
        },
        unify: function(s2, t, occurs_check) {
          occurs_check = occurs_check === void 0 ? false : occurs_check;
          var G = [{ left: s2, right: t }], links = {};
          while (G.length !== 0) {
            var eq = G.pop();
            s2 = eq.left;
            t = eq.right;
            if (s2 == t)
              continue;
            if (pl.type.is_term(s2) && pl.type.is_term(t)) {
              if (s2.indicator !== t.indicator)
                return null;
              if (s2.indicator === "./2") {
                var pointer_s = s2, pointer_t = t;
                while (pointer_s.indicator === "./2" && pointer_t.indicator === "./2") {
                  G.push({ left: pointer_s.args[0], right: pointer_t.args[0] });
                  pointer_s = pointer_s.args[1];
                  pointer_t = pointer_t.args[1];
                }
                G.push({ left: pointer_s, right: pointer_t });
              } else {
                for (var i2 = 0; i2 < s2.args.length; i2++)
                  G.push({ left: s2.args[i2], right: t.args[i2] });
              }
            } else if (pl.type.is_number(s2) && pl.type.is_number(t)) {
              if (s2.value !== t.value || s2.is_float !== t.is_float)
                return null;
            } else if (pl.type.is_variable(s2)) {
              if (pl.type.is_variable(t) && s2.id === t.id)
                continue;
              if (occurs_check === true && indexOf(t.variables(), s2.id) !== -1)
                return null;
              if (s2.id !== "_") {
                var subs = new Substitution();
                subs.add(s2.id, t);
                for (var i2 = 0; i2 < G.length; i2++) {
                  G[i2].left = G[i2].left.apply(subs);
                  G[i2].right = G[i2].right.apply(subs);
                }
                for (var i2 in links)
                  links[i2] = links[i2].apply(subs);
                links[s2.id] = t;
              }
            } else if (pl.type.is_variable(t)) {
              G.push({ left: t, right: s2 });
            } else if (s2.unify !== void 0) {
              if (!s2.unify(t))
                return null;
            } else {
              return null;
            }
          }
          return new Substitution(links);
        },
        is_rename: function(obj1, obj2, links) {
          links = links || {};
          if (obj1.is_rename && obj2.is_rename)
            return obj1.is_rename(obj2, links);
          else if (obj1.equals && obj2.equals)
            return obj1.equals(obj2);
          else
            return false;
        },
        compare: function(obj1, obj2) {
          var type = pl.type.compare(obj1, obj2);
          return type !== 0 ? type : obj1.compare(obj2);
        },
        arithmetic_compare: function(thread, obj1, obj2) {
          var expr1 = obj1.interpret(thread);
          if (!pl.type.is_number(expr1)) {
            return expr1;
          } else {
            var expr2 = obj2.interpret(thread);
            if (!pl.type.is_number(expr2)) {
              return expr2;
            } else {
              return expr1.value < expr2.value ? -1 : expr1.value > expr2.value ? 1 : 0;
            }
          }
        },
        operate: function(thread, obj) {
          if (pl.type.is_operator(obj)) {
            var op = pl.type.is_operator(obj);
            var args = [], value;
            var type = false;
            for (var i2 = 0; i2 < obj.args.length; i2++) {
              value = obj.args[i2].interpret(thread);
              if (!pl.type.is_number(value)) {
                return value;
              } else if (op.type_args !== null && value.is_float !== op.type_args) {
                return pl.error.type(op.type_args ? "float" : "integer", value, thread.__call_indicator);
              } else {
                args.push(value.value);
              }
              type = type || value.is_float;
            }
            args.push(thread);
            value = pl.arithmetic.evaluation[obj.indicator].fn.apply(this, args);
            if (obj.indicator === "^/2" && !type && value !== parseInt(value, 10))
              return pl.error.type("float", new Num(args[0], false), thread.__call_indicator);
            type = op.type_result === null ? type : op.type_result;
            if (pl.type.is_term(value)) {
              return value;
            } else if (value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY) {
              return pl.error.evaluation("float_overflow", thread.__call_indicator);
            } else if (type === false && thread.get_flag("bounded").id === "true" && (value > thread.get_flag("max_integer").value || value < thread.get_flag("min_integer").value)) {
              return pl.error.evaluation("int_overflow", thread.__call_indicator);
            } else {
              return new Num(value, type);
            }
          } else {
            return pl.error.type("evaluable", str_indicator(obj.indicator), thread.__call_indicator);
          }
        },
        error: {
          existence: function(type, object, indicator2) {
            if (typeof object === "string")
              object = str_indicator(object);
            return new Term("error", [new Term("existence_error", [new Term(type), object]), str_indicator(indicator2)]);
          },
          type: function(expected2, found, indicator2) {
            return new Term("error", [new Term("type_error", [new Term(expected2), found]), str_indicator(indicator2)]);
          },
          instantiation: function(indicator2) {
            return new Term("error", [new Term("instantiation_error"), str_indicator(indicator2)]);
          },
          uninstantiation: function(found, indicator2) {
            return new Term("error", [new Term("uninstantiation_error", [new Term(found)]), str_indicator(indicator2)]);
          },
          domain: function(expected2, found, indicator2) {
            return new Term("error", [new Term("domain_error", [new Term(expected2), found]), str_indicator(indicator2)]);
          },
          representation: function(flag, indicator2) {
            return new Term("error", [new Term("representation_error", [new Term(flag)]), str_indicator(indicator2)]);
          },
          permission: function(operation, type, found, indicator2) {
            return new Term("error", [new Term("permission_error", [new Term(operation), new Term(type), found]), str_indicator(indicator2)]);
          },
          evaluation: function(error2, indicator2) {
            return new Term("error", [new Term("evaluation_error", [new Term(error2)]), str_indicator(indicator2)]);
          },
          syntax: function(token, expected2, last) {
            token = token || { value: "", line: 0, column: 0, matches: [""], start: 0 };
            var position = last && token.matches.length > 0 ? token.start + token.matches[0].length : token.start;
            var found = last ? new Term("token_not_found") : new Term("found", [new Term(token.value.toString())]);
            var info = new Term(".", [new Term("line", [new Num(token.line + 1)]), new Term(".", [new Term("column", [new Num(position)]), new Term(".", [found, new Term("[]", [])])])]);
            return new Term("error", [new Term("syntax_error", [new Term(expected2)]), info]);
          },
          syntax_by_predicate: function(expected2, indicator2) {
            return new Term("error", [new Term("syntax_error", [new Term(expected2)]), str_indicator(indicator2)]);
          }
        },
        warning: {
          singleton: function(variables, rule, line) {
            var list = new Term("[]");
            for (var i2 = variables.length - 1; i2 >= 0; i2--)
              list = new Term(".", [new Var(variables[i2]), list]);
            return new Term("warning", [new Term("singleton_variables", [list, str_indicator(rule)]), new Term(".", [new Term("line", [new Num(line, false)]), new Term("[]")])]);
          },
          failed_goal: function(goal, line) {
            return new Term("warning", [new Term("failed_goal", [goal]), new Term(".", [new Term("line", [new Num(line, false)]), new Term("[]")])]);
          }
        },
        format_variable: function(id, variable) {
          var charcode = variable && variable.length > 0 ? codePointAt(variable, 1) : 0;
          if (variable === "_" || variable && variable[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
            return "__" + id;
          return "_" + id;
        },
        format_answer: function(answer, thread, options2) {
          if (thread instanceof Session)
            thread = thread.thread;
          var options2 = options2 ? options2 : {};
          options2.session = thread ? thread.session : void 0;
          if (pl.type.is_error(answer)) {
            return "uncaught exception: " + answer.args[0].toString(options2);
          } else if (answer === false) {
            return "false.";
          } else if (answer === null) {
            return "limit exceeded ;";
          } else {
            var i2 = 0;
            var str = "";
            if (pl.type.is_substitution(answer)) {
              var dom = answer.domain(true);
              for (var link in answer.links) {
                if (!answer.links.hasOwnProperty(link))
                  continue;
                if (pl.type.is_variable(answer.links[link])) {
                  var links = {};
                  links[answer.links[link].id] = new Var(link);
                  answer = answer.apply(new Substitution(links));
                }
              }
              answer = answer.filter(function(id, value) {
                return !pl.type.is_variable(value) || pl.type.is_variable(value) && answer.has_attributes(id) || indexOf(dom, value.id) !== -1 && id !== value.id;
              });
            }
            for (var link in answer.links) {
              if (!answer.links.hasOwnProperty(link))
                continue;
              if (pl.type.is_variable(answer.links[link]) && link === answer.links[link].id) {
                var attrs = answer.attrs[link];
                for (var module3 in attrs) {
                  if (!attrs.hasOwnProperty(module3))
                    continue;
                  i2++;
                  if (str !== "")
                    str += ", ";
                  str += "put_attr(" + link + ", " + module3 + ", " + attrs[module3].toString(options2) + ")";
                }
              } else {
                i2++;
                if (str !== "")
                  str += ", ";
                str += link.toString(options2) + " = " + answer.links[link].toString(options2, { priority: "700", class: "xfx", indicator: "=/2" }, "right");
              }
            }
            var delimiter = typeof thread === "undefined" || thread.points.length > 0 ? " ;" : ".";
            if (i2 === 0) {
              return "true" + delimiter;
            } else {
              return str + delimiter;
            }
          }
        },
        flatten_error: function(error2) {
          if (!pl.type.is_error(error2))
            return null;
          error2 = error2.args[0];
          var obj = {};
          obj.type = error2.args[0].id;
          obj.thrown = obj.type === "syntax_error" ? null : error2.args[1].id;
          obj.expected = null;
          obj.found = null;
          obj.representation = null;
          obj.existence = null;
          obj.existence_type = null;
          obj.line = null;
          obj.column = null;
          obj.permission_operation = null;
          obj.permission_type = null;
          obj.evaluation_type = null;
          if (obj.type === "type_error" || obj.type === "domain_error") {
            obj.expected = error2.args[0].args[0].id;
            obj.found = error2.args[0].args[1].toString();
          } else if (obj.type === "syntax_error") {
            if (error2.args[1].indicator === "./2") {
              obj.expected = error2.args[0].args[0].id;
              obj.found = error2.args[1].args[1].args[1].args[0];
              obj.found = obj.found.id === "token_not_found" ? obj.found.id : obj.found.args[0].id;
              obj.line = error2.args[1].args[0].args[0].value;
              obj.column = error2.args[1].args[1].args[0].args[0].value;
            } else {
              obj.thrown = error2.args[1].id;
            }
          } else if (obj.type === "permission_error") {
            obj.found = error2.args[0].args[2].toString();
            obj.permission_operation = error2.args[0].args[0].id;
            obj.permission_type = error2.args[0].args[1].id;
          } else if (obj.type === "evaluation_error") {
            obj.evaluation_type = error2.args[0].args[0].id;
          } else if (obj.type === "representation_error") {
            obj.representation = error2.args[0].args[0].id;
          } else if (obj.type === "existence_error") {
            obj.existence = error2.args[0].args[1].toString();
            obj.existence_type = error2.args[0].args[0].id;
          }
          return obj;
        },
        create: function(limit) {
          return new pl.type.Session(limit);
        }
      };
      pl.builtin = new Module("system", {
        "goal_expansion/2": [
          new Rule(new Term("goal_expansion", [new Term(",", [new Var("X"), new Var("Y")]), new Term(",", [new Var("X_"), new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"), new Var("X_")]), new Term(";", [new Term("goal_expansion", [new Var("Y"), new Var("Y_")]), new Term("=", [new Var("Y_"), new Var("Y")])])]), new Term(",", [new Term("=", [new Var("X"), new Var("X_")]), new Term("goal_expansion", [new Var("Y"), new Var("Y_")])])])),
          new Rule(new Term("goal_expansion", [new Term(";", [new Var("X"), new Var("Y")]), new Term(";", [new Var("X_"), new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"), new Var("X_")]), new Term(";", [new Term("goal_expansion", [new Var("Y"), new Var("Y_")]), new Term("=", [new Var("Y_"), new Var("Y")])])]), new Term(",", [new Term("=", [new Var("X"), new Var("X_")]), new Term("goal_expansion", [new Var("Y"), new Var("Y_")])])])),
          new Rule(new Term("goal_expansion", [new Term("->", [new Var("X"), new Var("Y")]), new Term("->", [new Var("X_"), new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"), new Var("X_")]), new Term(";", [new Term("goal_expansion", [new Var("Y"), new Var("Y_")]), new Term("=", [new Var("Y_"), new Var("Y")])])]), new Term(",", [new Term("=", [new Var("X"), new Var("X_")]), new Term("goal_expansion", [new Var("Y"), new Var("Y_")])])])),
          new Rule(new Term("goal_expansion", [new Term("catch", [new Var("X"), new Var("Y"), new Var("Z")]), new Term("catch", [new Var("X_"), new Var("Y"), new Var("Z_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"), new Var("X_")]), new Term(";", [new Term("goal_expansion", [new Var("Z"), new Var("Z_")]), new Term("=", [new Var("Z_"), new Var("Z")])])]), new Term(",", [new Term("=", [new Var("X_"), new Var("X")]), new Term("goal_expansion", [new Var("Z"), new Var("Z_")])])])),
          new Rule(new Term("goal_expansion", [new Term("\\+", [new Var("X")]), new Term("\\+", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]), new Term("goal_expansion", [new Var("X"), new Var("X_")])])),
          new Rule(new Term("goal_expansion", [new Term("once", [new Var("X")]), new Term("once", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]), new Term("goal_expansion", [new Var("X"), new Var("X_")])])),
          new Rule(new Term("goal_expansion", [new Term("findall", [new Var("X"), new Var("Y"), new Var("Z")]), new Term("findall", [new Var("X"), new Var("Y_"), new Var("Z")])]), new Term("goal_expansion", [new Var("Y"), new Var("Y_")])),
          new Rule(new Term("goal_expansion", [new Term("setof", [new Var("X"), new Var("Y"), new Var("Z")]), new Term("findall", [new Var("X"), new Var("Y_"), new Var("Z")])]), new Term("goal_expansion", [new Var("Y"), new Var("Y_")])),
          new Rule(new Term("goal_expansion", [new Term("bagof", [new Var("X"), new Var("Y"), new Var("Z")]), new Term("findall", [new Var("X"), new Var("Y_"), new Var("Z")])]), new Term("goal_expansion", [new Var("Y"), new Var("Y_")])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X")]), new Term("call", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]), new Term("goal_expansion", [new Var("X"), new Var("X_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term("[]", [])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1"), new Var("A2")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term(".", [new Var("A2"), new Term("[]", [])])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1"), new Var("A2"), new Var("A3")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term(".", [new Var("A2"), new Term(".", [new Var("A3"), new Term("[]", [])])])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1"), new Var("A2"), new Var("A3"), new Var("A4")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term(".", [new Var("A2"), new Term(".", [new Var("A3"), new Term(".", [new Var("A4"), new Term("[]", [])])])])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1"), new Var("A2"), new Var("A3"), new Var("A4"), new Var("A5")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term(".", [new Var("A2"), new Term(".", [new Var("A3"), new Term(".", [new Var("A4"), new Term(".", [new Var("A5"), new Term("[]", [])])])])])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1"), new Var("A2"), new Var("A3"), new Var("A4"), new Var("A5"), new Var("A6")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term(".", [new Var("A2"), new Term(".", [new Var("A3"), new Term(".", [new Var("A4"), new Term(".", [new Var("A5"), new Term(".", [new Var("A6"), new Term("[]", [])])])])])])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])])),
          new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"), new Var("A1"), new Var("A2"), new Var("A3"), new Var("A4"), new Var("A5"), new Var("A6"), new Var("A7")]), new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"), new Term(".", [new Var("X"), new Term(".", [new Var("A1"), new Term(".", [new Var("A2"), new Term(".", [new Var("A3"), new Term(".", [new Var("A4"), new Term(".", [new Var("A5"), new Term(".", [new Var("A6"), new Term(".", [new Var("A7"), new Term("[]", [])])])])])])])])])]), new Term("goal_expansion", [new Var("F"), new Var("F_")])]))
        ],
        "put_attr/3": function(thread, point, atom) {
          var variable = atom.args[0], module3 = atom.args[1], value = atom.args[2];
          if (!pl.type.is_variable(variable)) {
            thread.throw_error(pl.error.type("variable", variable, atom.indicator));
          } else if (!pl.type.is_atom(module3)) {
            thread.throw_error(pl.error.type("atom", module3, atom.indicator));
          } else {
            var subs = point.substitution.set_attribute(variable.id, module3, value);
            thread.prepend([new State(point.goal.replace(null), subs, point)]);
          }
        },
        "get_attr/3": function(thread, point, atom) {
          var variable = atom.args[0], module3 = atom.args[1], value = atom.args[2];
          if (!pl.type.is_variable(variable)) {
            thread.throw_error(pl.error.type("variable", variable, atom.indicator));
          } else if (!pl.type.is_atom(module3)) {
            thread.throw_error(pl.error.type("atom", module3, atom.indicator));
          } else {
            var attr = point.substitution.get_attribute(variable.id, module3);
            if (attr) {
              thread.prepend([new State(point.goal.replace(new Term("=", [value, attr])), point.substitution, point)]);
            }
          }
        },
        "op/3": function(thread, point, atom) {
          var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
          if (pl.type.is_atom(operators))
            operators = new Term(".", [operators, new Term("[]")]);
          if (pl.type.is_variable(priority) || pl.type.is_variable(type) || pl.type.is_variable(operators)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_integer(priority)) {
            thread.throw_error(pl.error.type("integer", priority, atom.indicator));
          } else if (!pl.type.is_atom(type)) {
            thread.throw_error(pl.error.type("atom", type, atom.indicator));
          } else if (!pl.type.is_list(operators)) {
            thread.throw_error(pl.error.type("list", operators, atom.indicator));
          } else if (pl.type.is_empty_list(operators)) {
            thread.throw_error(pl.error.permission("create", "operator", operators, atom.indicator));
          } else {
            var pointer = operators;
            while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
              var operator = pointer.args[0];
              pointer = pointer.args[1];
              if (pl.type.is_variable(operator)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_atom(operator)) {
                thread.throw_error(pl.error.type("atom", operator, atom.indicator));
                return;
              } else if (priority.value < 0 || priority.value > 1200) {
                thread.throw_error(pl.error.domain("operator_priority", priority, atom.indicator));
                return;
              } else if (operator.id === ",") {
                thread.throw_error(pl.error.permission("modify", "operator", operator, atom.indicator));
                return;
              } else if (operator.id === "{}") {
                thread.throw_error(pl.error.permission("create", "operator", operator, atom.indicator));
                return;
              } else if (operator.id === "[]") {
                thread.throw_error(pl.error.permission("create", "operator", operator, atom.indicator));
                return;
              } else if (operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3)) {
                thread.throw_error(pl.error.permission("create", "operator", operator, atom.indicator));
                return;
              } else if (["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf(type.id) === -1) {
                thread.throw_error(pl.error.domain("operator_specifier", type, atom.indicator));
                return;
              } else {
                var fix = { prefix: null, infix: null, postfix: null };
                for (var p in thread.session.__operators) {
                  if (!thread.session.__operators.hasOwnProperty(p))
                    continue;
                  var classes = thread.session.__operators[p][operator.id];
                  if (classes) {
                    if (indexOf(classes, "fx") !== -1) {
                      fix.prefix = { priority: p, type: "fx" };
                    }
                    if (indexOf(classes, "fy") !== -1) {
                      fix.prefix = { priority: p, type: "fy" };
                    }
                    if (indexOf(classes, "xf") !== -1) {
                      fix.postfix = { priority: p, type: "xf" };
                    }
                    if (indexOf(classes, "yf") !== -1) {
                      fix.postfix = { priority: p, type: "yf" };
                    }
                    if (indexOf(classes, "xfx") !== -1) {
                      fix.infix = { priority: p, type: "xfx" };
                    }
                    if (indexOf(classes, "xfy") !== -1) {
                      fix.infix = { priority: p, type: "xfy" };
                    }
                    if (indexOf(classes, "yfx") !== -1) {
                      fix.infix = { priority: p, type: "yfx" };
                    }
                  }
                }
                var current_class;
                switch (type.id) {
                  case "fy":
                  case "fx":
                    current_class = "prefix";
                    break;
                  case "yf":
                  case "xf":
                    current_class = "postfix";
                    break;
                  default:
                    current_class = "infix";
                    break;
                }
                if (fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
                  thread.throw_error(pl.error.permission("create", "operator", operator, atom.indicator));
                  return;
                } else {
                  if (fix[current_class]) {
                    remove(thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type);
                    if (thread.session.__operators[fix[current_class].priority][operator.id].length === 0) {
                      delete thread.session.__operators[fix[current_class].priority][operator.id];
                    }
                  }
                  if (priority.value > 0) {
                    if (!thread.session.__operators[priority.value])
                      thread.session.__operators[priority.value.toString()] = {};
                    if (!thread.session.__operators[priority.value][operator.id])
                      thread.session.__operators[priority.value][operator.id] = [];
                    thread.session.__operators[priority.value][operator.id].push(type.id);
                  }
                }
              }
            }
            if (pl.type.is_variable(pointer)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
              return;
            } else if (!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
              thread.throw_error(pl.error.type("list", operators, atom.indicator));
              return;
            } else {
              thread.success(point);
            }
          }
        },
        "current_op/3": function(thread, point, atom) {
          var priority = atom.args[0], specifier = atom.args[1], operator = atom.args[2];
          var points = [];
          if (!pl.type.is_variable(priority) && !pl.type.is_integer(priority)) {
            thread.throw_error(pl.error.type("integer", priority, atom.indicator));
          } else if (pl.type.is_integer(priority) && (priority.value < 0 || priority.value > 1200)) {
            thread.throw_error(pl.error.domain("operator_priority", priority, atom.indicator));
          } else if (!pl.type.is_variable(specifier) && !pl.type.is_atom(specifier)) {
            thread.throw_error(pl.error.type("atom", specifier, atom.indicator));
          } else if (pl.type.is_atom(specifier) && indexOf(["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"], specifier.id) === -1) {
            thread.throw_error(pl.error.domain("operator_specifier", specifier, atom.indicator));
          } else if (!pl.type.is_variable(operator) && !pl.type.is_atom(operator)) {
            thread.throw_error(pl.error.type("atom", operator, atom.indicator));
          } else {
            for (var p in thread.session.__operators)
              for (var o in thread.session.__operators[p])
                for (var i2 = 0; i2 < thread.session.__operators[p][o].length; i2++)
                  points.push(new State(point.goal.replace(new Term(",", [
                    new Term("=", [new Num(p, false), priority]),
                    new Term(",", [
                      new Term("=", [new Term(thread.session.__operators[p][o][i2], []), specifier]),
                      new Term("=", [new Term(o, []), operator])
                    ])
                  ])), point.substitution, point));
            thread.prepend(points);
          }
        },
        ";/2": function(thread, point, atom) {
          var left = atom.args[0], right = atom.args[1];
          var context_left = left.args[0];
          var free_left = left.indicator === ":/2" ? left.args[1] : left;
          if (pl.type.is_term(free_left) && free_left.indicator === "->/2") {
            var cond = left.indicator === ":/2" ? new Term(":", [context_left, new Term("call", [free_left.args[0]])]) : free_left.args[0];
            var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
            var otherwise = right;
            var goal_fst = point.goal.replace(new Term(",", [cond, new Term(",", [new Term("!"), then])]));
            var goal_snd = point.goal.replace(new Term(",", [new Term("!"), otherwise]));
            thread.prepend([
              new State(goal_fst, point.substitution, point),
              new State(goal_snd, point.substitution, point)
            ]);
          } else {
            thread.prepend([
              new State(point.goal.replace(left), point.substitution, point),
              new State(point.goal.replace(right), point.substitution, point)
            ]);
          }
        },
        "!/0": function(thread, point, atom) {
          var parent_cut, last_cut, states = [];
          parent_cut = point;
          last_cut = null;
          while (parent_cut.parent !== null && parent_cut.parent.goal.search(atom)) {
            last_cut = parent_cut;
            parent_cut = parent_cut.parent;
            if (parent_cut.goal !== null) {
              var selected = parent_cut.goal.select();
              if (selected && selected.indicator === ":/2")
                selected = selected.args[1];
              if (selected && selected.id === "call" && selected.search(atom)) {
                parent_cut = last_cut;
                break;
              }
            }
          }
          var setup_call_cleanup = null;
          for (var i2 = thread.points.length - 1; i2 >= 0; i2--) {
            var state = thread.points[i2];
            var node = state.parent;
            while (node !== null && node !== parent_cut.parent) {
              node = node.parent;
            }
            if (node === null && node !== parent_cut.parent)
              states.push(state);
            else if (state.setup_call_cleanup_goal)
              setup_call_cleanup = state.setup_call_cleanup_goal;
          }
          thread.points = states.reverse();
          thread.prepend([new State(point.goal.replace(setup_call_cleanup), point.substitution, point)]);
        },
        "\\+/1": function(thread, point, atom) {
          var goal = atom.args[0];
          if (pl.type.is_variable(goal)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(goal)) {
            thread.throw_error(pl.error.type("callable", goal, atom.indicator));
          } else {
            thread.prepend([
              new State(point.goal.replace(new Term(",", [new Term(",", [new Term("call", [goal]), new Term("!", [])]), new Term("fail", [])])), point.substitution, point),
              new State(point.goal.replace(null), point.substitution, point)
            ]);
          }
        },
        "->/2": function(thread, point, atom) {
          var cond = atom.args[0], then = atom.args[1];
          var goal = point.goal.replace(new Term(",", [
            new Term("call", [cond]),
            new Term(",", [new Term("!"), then])
          ]));
          thread.prepend([new State(goal, point.substitution, point)]);
        },
        "fail/0": function(_1, _2, _3) {
        },
        "false/0": function(_1, _2, _3) {
        },
        "true/0": function(thread, point, _) {
          thread.success(point);
        },
        "call/1": callN(1),
        "call/2": callN(2),
        "call/3": callN(3),
        "call/4": callN(4),
        "call/5": callN(5),
        "call/6": callN(6),
        "call/7": callN(7),
        "call/8": callN(8),
        "once/1": function(thread, point, atom) {
          var goal = atom.args[0];
          thread.prepend([new State(point.goal.replace(new Term(",", [new Term("call", [goal]), new Term("!", [])])), point.substitution, point)]);
        },
        "forall/2": function(thread, point, atom) {
          var generate = atom.args[0], test = atom.args[1];
          thread.prepend([new State(point.goal.replace(new Term("\\+", [new Term(",", [new Term("call", [generate]), new Term("\\+", [new Term("call", [test])])])])), point.substitution, point)]);
        },
        "repeat/0": function(thread, point, _) {
          thread.prepend([new State(point.goal.replace(null), point.substitution, point), point]);
        },
        "throw/1": function(thread, point, atom) {
          var error2 = atom.args[0];
          if (pl.type.is_variable(error2)) {
            thread.throw_error(pl.error.instantiation(thread.level.indicator));
          } else {
            for (var i2 = 0; i2 < thread.points.length; i2++) {
              var state = thread.points[i2];
              if (state.setup_call_cleanup_catch) {
                thread.points = [new State(new Term(",", [
                  new Term("catch", [
                    state.setup_call_cleanup_catch,
                    new Var("_"),
                    new Term("throw", [error2])
                  ]),
                  new Term("throw", [error2])
                ]), point.substitution, point)];
                return;
              }
            }
            thread.throw_error(error2);
          }
        },
        "catch/3": function(thread, point, atom) {
          var goal = atom.args[0], catcher = atom.args[1], recover = atom.args[2];
          var nthread;
          if (!point.catch) {
            nthread = new Thread(thread.session);
            nthread.debugger = thread.debugger;
            nthread.format_success = function(state) {
              return state.substitution;
            };
            nthread.format_error = function(state) {
              return state.goal;
            };
            nthread.add_goal(goal, true, point);
            point.catch = nthread;
          } else {
            nthread = point.catch;
          }
          var callback = function(answer) {
            if (pl.type.is_error(answer)) {
              var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
              var state = new State();
              var mgu = pl.unify(answer.args[0], catcher, occurs_check);
              if (mgu !== null) {
                state.substitution = point.substitution.apply(mgu);
                state.goal = point.goal.replace(recover).apply(mgu);
                state.parent = point;
                thread.prepend([state]);
              } else {
                thread.throw_error(answer.args[0]);
              }
            } else if (answer !== false && answer !== null) {
              var state = answer === null ? [] : new State(point.goal.apply(answer).replace(null), point.substitution.apply(answer), point);
              thread.prepend([state, point]);
            } else if (answer === null) {
              thread.prepend([point]);
              if (thread.has_limit)
                thread.current_limit = 0;
            }
            thread.again(answer !== null);
          };
          nthread.answer(callback);
          return true;
        },
        "call_cleanup/2": function(thread, point, atom) {
          var call = atom.args[0], cleanup = atom.args[1];
          if (pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(call)) {
            thread.throw_error(pl.error.type("callable", call, atom.indicator));
          } else if (!pl.type.is_callable(cleanup)) {
            thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
          } else {
            var nthread, callback;
            if (point.hasOwnProperty("setup_call_cleanup_thread")) {
              nthread = point.setup_call_cleanup_thread;
              callback = point.setup_call_cleanup_callback;
            } else {
              var goal = new Term("call", [call]);
              nthread = new Thread(thread.session);
              nthread.add_goal(goal, true, point);
              callback = function(answer) {
                if (answer === null) {
                  var state = new State(point.goal, point.substitution, point);
                  state.setup_call_cleanup_thread = nthread;
                  state.setup_call_cleanup_callback = callback;
                  thread.prepend([state]);
                } else if (answer === false) {
                  var cleanup_and_fail = new Term(",", [
                    new Term("call", [cleanup]),
                    new Term("fail")
                  ]);
                  var state = new State(point.goal.replace(cleanup_and_fail), point.substitution, point);
                  thread.prepend([state]);
                } else if (pl.type.is_error(answer)) {
                  var cleanup_and_throw = new Term(",", [
                    new Term("call", [cleanup]),
                    answer
                  ]);
                  var state = new State(point.goal.replace(cleanup_and_throw), point.substitution, point);
                  thread.prepend([state]);
                } else {
                  if (nthread.points.length === 0) {
                    var state = new State(point.goal.replace(new Term("call", [cleanup])).apply(answer), point.substitution.apply(answer), point);
                    thread.prepend([state]);
                  } else {
                    var state1 = new State(point.goal.apply(answer).replace(null), point.substitution.apply(answer), point);
                    var state2 = new State(point.goal, point.substitution, point);
                    state2.setup_call_cleanup_thread = nthread;
                    state2.setup_call_cleanup_callback = callback;
                    state2.setup_call_cleanup_goal = cleanup.apply(answer);
                    state2.setup_call_cleanup_catch = cleanup;
                    thread.prepend([state1, state2]);
                  }
                }
                thread.again();
              };
            }
            nthread.answer(callback);
            return true;
          }
        },
        "setup_call_cleanup/3": function(thread, point, atom) {
          var setup = atom.args[0], call = atom.args[1], cleanup = atom.args[2];
          if (pl.type.is_variable(setup) || pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(setup)) {
            thread.throw_error(pl.error.type("callable", setup, atom.indicator));
          } else if (!pl.type.is_callable(call)) {
            thread.throw_error(pl.error.type("callable", call, atom.indicator));
          } else if (!pl.type.is_callable(cleanup)) {
            thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
          } else {
            thread.prepend([new State(point.goal.replace(new Term(",", [
              new Term("once", [setup]),
              new Term("call_cleanup", [call, cleanup])
            ])), point.substitution, point)]);
          }
        },
        "=/2": function(thread, point, atom) {
          var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
          var state = new State();
          var mgu = pl.unify(atom.args[0], atom.args[1], occurs_check);
          if (mgu !== null) {
            state.goal = point.goal.apply(mgu).replace(null);
            state.substitution = point.substitution.apply(mgu);
            state.parent = point;
            thread.prepend([state]);
          }
        },
        "unify_with_occurs_check/2": function(thread, point, atom) {
          var state = new State();
          var mgu = pl.unify(atom.args[0], atom.args[1], true);
          if (mgu !== null) {
            state.goal = point.goal.apply(mgu).replace(null);
            state.substitution = point.substitution.apply(mgu);
            state.parent = point;
            thread.prepend([state]);
          }
        },
        "\\=/2": function(thread, point, atom) {
          var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
          var mgu = pl.unify(atom.args[0], atom.args[1], occurs_check);
          if (mgu === null) {
            thread.success(point);
          }
        },
        "subsumes_term/2": function(thread, point, atom) {
          var general = atom.args[0], specific = atom.args[1];
          var vars1 = thread.next_free_variable();
          var vars2 = thread.next_free_variable();
          thread.prepend([new State(point.goal.replace(new Term("\\+", [
            new Term("\\+", [
              new Term(",", [
                new Term("term_variables", [specific, vars1]),
                new Term(",", [
                  new Term("unify_with_occurs_check", [general, specific]),
                  new Term(",", [
                    new Term("term_variables", [vars1, vars2]),
                    new Term("==", [vars1, vars2])
                  ])
                ])
              ])
            ])
          ])), point.substitution, point)]);
        },
        "findall/3": function(thread, point, atom) {
          var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
          var tail = new Term("[]", []);
          thread.prepend([new State(point.goal.replace(new Term("findall", [template, goal, instances, tail])), point.substitution, point)]);
        },
        "findall/4": function(thread, point, atom) {
          var template = atom.args[0], goal = atom.args[1], instances = atom.args[2], tail = atom.args[3];
          if (pl.type.is_variable(goal)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(goal)) {
            thread.throw_error(pl.error.type("callable", goal, atom.indicator));
          } else if (!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
            thread.throw_error(pl.error.type("list", instances, atom.indicator));
          } else if (!pl.type.is_variable(tail) && !pl.type.is_list(tail)) {
            thread.throw_error(pl.error.type("list", tail, atom.indicator));
          } else {
            if (!pl.type.is_variable(instances)) {
              var pointer = instances;
              while (pl.type.is_term(pointer) && pointer.indicator === "./2")
                pointer = pointer.args[1];
              if (!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
                thread.throw_error(pl.error.type("list", instances, atom.indicator));
                return;
              }
            }
            if (!pl.type.is_variable(tail)) {
              var pointer_t = tail;
              while (pl.type.is_term(pointer_t) && pointer_t.indicator === "./2")
                pointer_t = pointer_t.args[1];
              if (!pl.type.is_variable(pointer_t) && !pl.type.is_empty_list(pointer_t)) {
                thread.throw_error(pl.error.type("list", tail, atom.indicator));
                return;
              }
            }
            var variable = thread.next_free_variable();
            var newGoal = new Term(",", [
              new Term("call", [goal]),
              new Term("=", [variable, template])
            ]);
            var nthread = new Thread(thread.session);
            nthread.debugger = thread.debugger;
            nthread.format_success = function(state) {
              return state.substitution;
            };
            nthread.format_error = function(state) {
              return state.goal;
            };
            nthread.add_goal(newGoal, true, point);
            nthread.head_point().parent = point;
            var answers = [];
            var callback = function(answer) {
              if (answer !== false && answer !== null && !pl.type.is_error(answer)) {
                nthread.session.renamed_variables = {};
                answers.push(answer.links[variable.id].rename(nthread));
                nthread.answer(callback);
              } else {
                var reset_limit2 = true;
                if (pl.type.is_error(answer)) {
                  thread.throw_error(answer.args[0]);
                } else if (!nthread.has_limit || nthread.current_limit > 0) {
                  var list = arrayToList(answers, tail);
                  thread.prepend([new State(point.goal.replace(new Term("=", [instances, list])), point.substitution, point)]);
                } else {
                  thread.prepend([point]);
                  if (thread.has_limit)
                    thread.current_limit = 0;
                  reset_limit2 = false;
                }
                if (reset_limit2 && nthread.debugger)
                  thread.debugger_states = thread.debugger_states.concat(nthread.debugger_states);
                thread.again(reset_limit2);
              }
            };
            nthread.answer(callback);
            return true;
          }
        },
        "bagof/3": function(thread, point, atom) {
          var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
          if (pl.type.is_variable(goal)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(goal)) {
            thread.throw_error(pl.error.type("callable", goal, atom.indicator));
          } else if (!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
            thread.throw_error(pl.error.type("list", instances, atom.indicator));
          } else {
            if (!pl.type.is_variable(instances)) {
              var pointer = instances;
              while (pl.type.is_term(pointer) && pointer.indicator === "./2")
                pointer = pointer.args[1];
              if (!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
                thread.throw_error(pl.error.type("list", instances, atom.indicator));
                return;
              }
            }
            thread.session.renamed_variables = {};
            template = template.rename(thread);
            goal = goal.rename(thread);
            var variable = thread.next_free_variable();
            var template_vars = [];
            while (goal.indicator === "^/2") {
              template_vars = template_vars.concat(goal.args[0].variables());
              goal = goal.args[1];
            }
            template_vars = template_vars.concat(template.variables());
            var free_vars = goal.variables().filter(function(v) {
              return indexOf(template_vars, v) === -1;
            });
            var list_vars = new Term("[]");
            for (var i2 = free_vars.length - 1; i2 >= 0; i2--) {
              list_vars = new Term(".", [new Var(free_vars[i2]), list_vars]);
            }
            var newGoal = new Term(",", [goal, new Term("=", [variable, new Term(",", [list_vars, template])])]);
            var nthread = new Thread(thread.session);
            nthread.debugger = thread.debugger;
            nthread.format_success = function(state) {
              return state.substitution;
            };
            nthread.format_error = function(state) {
              return state.goal;
            };
            nthread.add_goal(newGoal, true, point);
            nthread.head_point().parent = point;
            var answers = [];
            var callback = function(answer) {
              if (answer !== false && answer !== null && !pl.type.is_error(answer)) {
                var match = false;
                var arg_vars = answer.links[variable.id].args[0];
                var arg_template = answer.links[variable.id].args[1];
                var var_template = arg_template.variables();
                var sub_template = new Substitution();
                for (var prop in answer.links) {
                  if (!answer.links.hasOwnProperty(prop))
                    continue;
                  var value = answer.links[prop];
                  var index = indexOf(var_template, value.id);
                  if (pl.type.is_variable(value) && index !== -1 && !sub_template.links.hasOwnProperty(var_template[index]) && indexOf(template_vars, prop) === -1 && indexOf(free_vars, var_template[index]) === -1) {
                    sub_template.add(var_template[index], new Var(prop));
                  }
                }
                arg_vars = arg_vars.apply(sub_template);
                arg_template = arg_template.apply(sub_template);
                nthread.session.renamed_variables = {};
                for (var _elem in answers) {
                  if (!answers.hasOwnProperty(_elem))
                    continue;
                  var elem = answers[_elem];
                  if (pl.is_rename(elem.variables, arg_vars)) {
                    elem.answers.push(arg_template.rename(nthread));
                    match = true;
                    break;
                  }
                }
                if (!match)
                  answers.push({ variables: arg_vars, answers: [arg_template] });
                nthread.answer(callback);
              } else {
                reset_limit = true;
                if (pl.type.is_error(answer)) {
                  thread.throw_error(answer.args[0]);
                } else if (!nthread.has_limit || nthread.current_limit > 0) {
                  var states = [];
                  for (var i3 = 0; i3 < answers.length; i3++) {
                    answer = answers[i3].answers;
                    var list = arrayToList(answer);
                    states.push(new State(point.goal.replace(new Term(",", [new Term("=", [list_vars, answers[i3].variables]), new Term("=", [instances, list])])), point.substitution, point));
                  }
                  thread.prepend(states);
                } else {
                  thread.prepend([point]);
                  if (thread.has_limit)
                    thread.current_limit = 0;
                  reset_limit = false;
                }
                if (reset_limit && nthread.debugger)
                  thread.debugger_states = thread.debugger_states.concat(nthread.debugger_states);
                thread.again(reset_limit);
              }
            };
            nthread.answer(callback);
            return true;
          }
        },
        "setof/3": function(thread, point, atom) {
          var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
          if (pl.type.is_variable(goal)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(goal)) {
            thread.throw_error(pl.error.type("callable", goal, atom.indicator));
          } else if (!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
            thread.throw_error(pl.error.type("list", instances, atom.indicator));
          } else {
            if (!pl.type.is_variable(instances)) {
              var pointer = instances;
              while (pl.type.is_term(pointer) && pointer.indicator === "./2")
                pointer = pointer.args[1];
              if (!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
                thread.throw_error(pl.error.type("list", instances, atom.indicator));
                return;
              }
            }
            thread.session.renamed_variables = {};
            template = template.rename(thread);
            goal = goal.rename(thread);
            var variable = thread.next_free_variable();
            var template_vars = [];
            while (goal.indicator === "^/2") {
              template_vars = template_vars.concat(goal.args[0].variables());
              goal = goal.args[1];
            }
            template_vars = template_vars.concat(template.variables());
            var free_vars = goal.variables().filter(function(v) {
              return indexOf(template_vars, v) === -1;
            });
            var list_vars = new Term("[]");
            for (var i2 = free_vars.length - 1; i2 >= 0; i2--) {
              list_vars = new Term(".", [new Var(free_vars[i2]), list_vars]);
            }
            var newGoal = new Term(",", [goal, new Term("=", [variable, new Term(",", [list_vars, template])])]);
            var nthread = new Thread(thread.session);
            nthread.debugger = thread.debugger;
            nthread.format_success = function(state) {
              return state.substitution;
            };
            nthread.format_error = function(state) {
              return state.goal;
            };
            nthread.add_goal(newGoal, true, point);
            nthread.head_point().parent = point;
            var answers = [];
            var callback = function(answer) {
              if (answer !== false && answer !== null && !pl.type.is_error(answer)) {
                var match = false;
                var arg_vars = answer.links[variable.id].args[0];
                var arg_template = answer.links[variable.id].args[1];
                var var_template = arg_template.variables();
                var sub_template = new Substitution();
                for (var prop in answer.links) {
                  if (!answer.links.hasOwnProperty(prop))
                    continue;
                  var value = answer.links[prop];
                  var index = indexOf(var_template, value.id);
                  if (pl.type.is_variable(value) && index !== -1 && !sub_template.links.hasOwnProperty(var_template[index]) && indexOf(template_vars, prop) === -1 && indexOf(free_vars, var_template[index]) === -1) {
                    sub_template.add(var_template[index], new Var(prop));
                  }
                }
                arg_vars = arg_vars.apply(sub_template);
                arg_template = arg_template.apply(sub_template);
                nthread.session.renamed_variables = {};
                for (var _elem in answers) {
                  if (!answers.hasOwnProperty(_elem))
                    continue;
                  var elem = answers[_elem];
                  if (pl.is_rename(elem.variables, arg_vars)) {
                    elem.answers.push(arg_template.rename(nthread));
                    match = true;
                    break;
                  }
                }
                if (!match)
                  answers.push({ variables: arg_vars, answers: [arg_template] });
                nthread.answer(callback);
              } else {
                reset_limit = true;
                if (pl.type.is_error(answer)) {
                  thread.throw_error(answer.args[0]);
                } else if (!nthread.has_limit || nthread.current_limit > 0) {
                  var states = [];
                  for (var i3 = 0; i3 < answers.length; i3++) {
                    var arr_sorted = answers[i3].answers.sort(pl.compare);
                    var arr_filter = [];
                    var last = null;
                    for (var j = 0; j < arr_sorted.length; j++) {
                      if (!last || pl.compare(last, arr_sorted[j]) !== 0) {
                        last = arr_sorted[j];
                        arr_filter.push(last);
                      }
                    }
                    var list = arrayToList(arr_filter);
                    states.push(new State(point.goal.replace(new Term(",", [new Term("=", [list_vars, answers[i3].variables]), new Term("=", [instances, list])])), point.substitution, point));
                  }
                  thread.prepend(states);
                } else {
                  thread.prepend([point]);
                  if (thread.has_limit)
                    thread.current_limit = 0;
                  reset_limit = false;
                }
                if (reset_limit && nthread.debugger)
                  thread.debugger_states = thread.debugger_states.concat(nthread.debugger_states);
                thread.again(reset_limit);
              }
            };
            nthread.answer(callback);
            return true;
          }
        },
        "functor/3": function(thread, point, atom) {
          var subs;
          var term = atom.args[0], name = atom.args[1], arity = atom.args[2];
          if (pl.type.is_variable(term) && (pl.type.is_variable(name) || pl.type.is_variable(arity))) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(arity) && !pl.type.is_integer(arity)) {
            thread.throw_error(pl.error.type("integer", atom.args[2], atom.indicator));
          } else if (!pl.type.is_variable(name) && !pl.type.is_atomic(name)) {
            thread.throw_error(pl.error.type("atomic", atom.args[1], atom.indicator));
          } else if (pl.type.is_variable(term) && !pl.type.is_atom(name) && pl.type.is_integer(arity) && arity.value > 0) {
            thread.throw_error(pl.error.type("atom", atom.args[1], atom.indicator));
          } else if (pl.type.is_variable(term) && pl.type.is_integer(arity) && arity.value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", atom.args[2], atom.indicator));
          } else if (pl.type.is_variable(term)) {
            if (atom.args[2].value >= 0) {
              var args = [];
              for (var i2 = 0; i2 < arity.value; i2++)
                args.push(thread.next_free_variable());
              var functor = pl.type.is_number(name) ? name : new Term(name.id, args);
              thread.prepend([new State(point.goal.replace(new Term("=", [term, functor])), point.substitution, point)]);
            }
          } else {
            var id = pl.type.is_number(term) ? term : new Term(term.id, []);
            var length = pl.type.is_number(term) ? new Num(0, false) : new Num(term.args.length, false);
            var goal = new Term(",", [new Term("=", [id, name]), new Term("=", [length, arity])]);
            thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
          }
        },
        "arg/3": function(thread, point, atom) {
          if (pl.type.is_variable(atom.args[0]) || pl.type.is_variable(atom.args[1])) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_integer(atom.args[0])) {
            thread.throw_error(pl.error.type("integer", atom.args[0], atom.indicator));
          } else if (atom.args[0].value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", atom.args[0], atom.indicator));
          } else if (!pl.type.is_compound(atom.args[1])) {
            thread.throw_error(pl.error.type("compound", atom.args[1], atom.indicator));
          } else {
            var n = atom.args[0].value;
            if (n > 0 && n <= atom.args[1].args.length) {
              var goal = new Term("=", [atom.args[1].args[n - 1], atom.args[2]]);
              thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
            }
          }
        },
        "=../2": function(thread, point, atom) {
          var list;
          if (pl.type.is_variable(atom.args[0]) && (pl.type.is_variable(atom.args[1]) || pl.type.is_non_empty_list(atom.args[1]) && pl.type.is_variable(atom.args[1].args[0]))) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_fully_list(atom.args[1])) {
            thread.throw_error(pl.error.type("list", atom.args[1], atom.indicator));
          } else if (pl.type.is_variable(atom.args[0]) && pl.type.is_empty_list(atom.args[1])) {
            thread.throw_error(pl.error.domain("non_empty_list", atom.args[1], atom.indicator));
          } else if (!pl.type.is_variable(atom.args[0])) {
            if (pl.type.is_term(atom.args[0]) && atom.args[0].args.length > 0) {
              list = new Term("[]");
              for (var i2 = atom.args[0].args.length - 1; i2 >= 0; i2--) {
                list = new Term(".", [atom.args[0].args[i2], list]);
              }
              list = new Term(".", [new Term(atom.args[0].id), list]);
            } else {
              list = new Term(".", [atom.args[0], new Term("[]")]);
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [list, atom.args[1]])), point.substitution, point)]);
          } else if (!pl.type.is_variable(atom.args[1])) {
            var args = [];
            list = atom.args[1].args[1];
            while (list.indicator === "./2") {
              args.push(list.args[0]);
              list = list.args[1];
            }
            if (pl.type.is_variable(atom.args[0]) && pl.type.is_variable(list)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
            } else if (args.length === 0 && pl.type.is_compound(atom.args[1].args[0])) {
              thread.throw_error(pl.error.type("atomic", atom.args[1].args[0], atom.indicator));
            } else if (args.length > 0 && (pl.type.is_compound(atom.args[1].args[0]) || pl.type.is_number(atom.args[1].args[0]))) {
              thread.throw_error(pl.error.type("atom", atom.args[1].args[0], atom.indicator));
            } else {
              if (args.length === 0) {
                thread.prepend([new State(point.goal.replace(new Term("=", [atom.args[1].args[0], atom.args[0]], point)), point.substitution, point)]);
              } else {
                thread.prepend([new State(point.goal.replace(new Term("=", [new Term(atom.args[1].args[0].id, args), atom.args[0]])), point.substitution, point)]);
              }
            }
          }
        },
        "copy_term/2": function(thread, point, atom) {
          thread.session.renamed_variables = {};
          var renamed = atom.args[0].rename(thread);
          thread.prepend([new State(point.goal.replace(new Term("=", [renamed, atom.args[1]])), point.substitution, point.parent)]);
        },
        "term_variables/2": function(thread, point, atom) {
          var term = atom.args[0], vars = atom.args[1];
          if (!pl.type.is_fully_list(vars)) {
            thread.throw_error(pl.error.type("list", vars, atom.indicator));
          } else {
            var list = arrayToList(map(nub(term.variables()), function(v) {
              return new Var(v);
            }));
            thread.prepend([new State(point.goal.replace(new Term("=", [vars, list])), point.substitution, point)]);
          }
        },
        "numbervars/3": function(thread, point, atom) {
          var term = atom.args[0], start = atom.args[1], end = atom.args[2];
          if (pl.type.is_variable(start)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_integer(start)) {
            thread.throw_error(pl.error.type("integer", start, atom.indicator));
          } else if (!pl.type.is_variable(end) && !pl.type.is_integer(end)) {
            thread.throw_error(pl.error.type("integer", end, atom.indicator));
          } else {
            var variables = nub(term.variables());
            var value = start.value;
            var unif_body = new Term("true");
            for (var i2 = 0; i2 < variables.length; i2++) {
              unif_body = new Term(",", [
                new Term("=", [
                  new Var(variables[i2]),
                  new Term("$VAR", [new Num(value, false)])
                ]),
                unif_body
              ]);
              value++;
            }
            var unif_end = new Term("=", [end, new Num(value, false)]);
            if (pl.type.is_variable(end) || end.value === value) {
              thread.prepend([new State(point.goal.replace(new Term(",", [unif_body, unif_end])), point.substitution, point)]);
            }
          }
        },
        "clause/2": function(thread, point, atom) {
          var head = atom.args[0], body = atom.args[1];
          var module_id = "user";
          if (pl.type.is_term(head) && head.indicator === ":/2") {
            if (!pl.type.is_atom(head.args[0])) {
              thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
              return;
            }
            module_id = head.args[0].id;
            head = head.args[1];
          }
          var get_module = thread.session.modules[module_id];
          if (pl.type.is_variable(head)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(head)) {
            thread.throw_error(pl.error.type("callable", head, atom.indicator));
          } else if (!pl.type.is_variable(body) && !pl.type.is_callable(body)) {
            thread.throw_error(pl.error.type("callable", body, atom.indicator));
          } else if (head.indicator === ",/2" || thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
            thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
          } else if (pl.type.is_module(get_module) && get_module.rules[head.indicator]) {
            if (get_module.is_public_predicate(head.indicator)) {
              var states = [];
              if (typeof get_module.rules[head.indicator] === "function") {
                thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
                return;
              }
              for (var i2 = 0; i2 < get_module.rules[head.indicator].length; i2++) {
                var rule = get_module.rules[head.indicator][i2];
                thread.session.renamed_variables = {};
                rule = rule.rename(thread);
                if (rule.body === null)
                  rule.body = new Term("true");
                var goal = new Term(",", [
                  new Term("=", [rule.head, head]),
                  new Term("=", [rule.body, body])
                ]);
                states.push(new State(point.goal.replace(goal), point.substitution, point));
              }
              thread.prepend(states);
            } else {
              thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
            }
          }
        },
        "current_predicate/1": function(thread, point, atom) {
          var indicator2 = atom.args[0];
          var module_id;
          if (pl.type.is_term(indicator2) && indicator2.indicator === ":/2") {
            if (!pl.type.is_atom(indicator2.args[0])) {
              thread.throw_error(pl.error.type("module", indicator2.args[0], atom.indicator));
              return;
            }
            module_id = indicator2.args[0].id;
            indicator2 = indicator2.args[1];
          } else {
            module_id = "user";
          }
          if (!pl.type.is_variable(indicator2) && (!pl.type.is_compound(indicator2) || indicator2.indicator !== "//2")) {
            thread.throw_error(pl.error.type("predicate_indicator", indicator2, atom.indicator));
          } else if (!pl.type.is_variable(indicator2) && !pl.type.is_variable(indicator2.args[0]) && !pl.type.is_atom(indicator2.args[0])) {
            thread.throw_error(pl.error.type("atom", indicator2.args[0], atom.indicator));
          } else if (!pl.type.is_variable(indicator2) && !pl.type.is_variable(indicator2.args[1]) && !pl.type.is_integer(indicator2.args[1])) {
            thread.throw_error(pl.error.type("integer", indicator2.args[1], atom.indicator));
          } else if (!pl.type.is_variable(indicator2) && pl.type.is_integer(indicator2.args[1]) && indicator2.args[1].value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", indicator2.args[1], atom.indicator));
          } else {
            var states = [];
            var get_module = thread.session.modules[module_id];
            if (pl.type.is_module(get_module)) {
              for (var prop in get_module.rules) {
                if (!get_module.rules.hasOwnProperty(prop))
                  continue;
                var predicate = str_indicator(prop);
                var goal = new Term("=", [predicate, indicator2]);
                states.push(new State(point.goal.replace(goal), point.substitution, point));
              }
              thread.prepend(states);
            }
          }
        },
        "current_module/1": function(thread, point, atom) {
          var module_id = atom.args[0];
          if (!pl.type.is_variable(module_id) && !pl.type.is_atom(module_id)) {
            thread.throw_error(pl.error.type("atom", module_id, atom.indicator));
          } else {
            if (pl.type.is_variable(module_id)) {
              var states = [];
              for (var prop in thread.session.modules) {
                if (!thread.session.modules.hasOwnProperty(prop))
                  continue;
                states.push(new State(point.goal.replace(new Term("=", [module_id, new Term(prop)])), point.substitution, point));
              }
              thread.prepend(states);
            } else {
              if (thread.session.modules.hasOwnProperty(module_id.id))
                thread.success(point);
            }
          }
        },
        "predicate_property/2": function(thread, point, atom) {
          var head = atom.args[0], property = atom.args[1];
          var module_id;
          if (pl.type.is_term(head) && head.indicator === ":/2") {
            if (!pl.type.is_atom(head.args[0])) {
              thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
              return;
            }
            module_id = head.args[0].id;
            head = head.args[1];
          }
          if (!pl.type.is_variable(head) && !pl.type.is_callable(head)) {
            thread.throw_error(pl.error.type("callable", head, atom.indicator));
          } else if (!pl.type.is_variable(property) && !pl.type.is_predicate_property(property)) {
            thread.throw_error(pl.error.domain("predicate_property", property, atom.indicator));
          } else {
            var get_module = module_id ? thread.session.modules[module_id] : thread.session.modules.user;
            var points = [];
            if (pl.type.is_variable(head)) {
              if (!module_id) {
                for (var prop in pl.builtin.rules) {
                  if (!pl.builtin.rules.hasOwnProperty(prop))
                    continue;
                  var indicator2 = str_indicator(prop);
                  var args = [];
                  for (var i2 = 0; i2 < indicator2.args[1].value; i2++)
                    args.push(thread.next_free_variable());
                  var unif_head = new Term(indicator2.args[0].id, args);
                  var current_properties = [
                    new Term("static"),
                    new Term("built_in"),
                    new Term("native_code")
                  ];
                  if (pl.builtin.meta_predicates.hasOwnProperty(prop))
                    current_properties.push(new Term("meta_predicate", [
                      pl.builtin.meta_predicates[prop]
                    ]));
                  for (var i2 = 0; i2 < current_properties.length; i2++) {
                    if (pl.type.is_variable(property) || current_properties[i2].indicator === property.indicator) {
                      points.push(new State(point.goal.replace(new Term(",", [
                        new Term("=", [head, unif_head]),
                        new Term("=", [property, current_properties[i2]])
                      ])), point.substitution, point));
                    }
                  }
                }
              }
              if (pl.type.is_module(get_module)) {
                for (var prop in get_module.rules) {
                  if (!get_module.rules.hasOwnProperty(prop))
                    continue;
                  var indicator2 = str_indicator(prop);
                  var args = [];
                  for (var i2 = 0; i2 < indicator2.args[1].value; i2++)
                    args.push(thread.next_free_variable());
                  var unif_head = new Term(indicator2.args[0].id, args);
                  var current_properties = [];
                  if (thread.is_public_predicate(prop, module_id))
                    current_properties.push(new Term("dynamic"));
                  else
                    current_properties.push(new Term("static"));
                  if (get_module.rules[prop] instanceof Function)
                    current_properties.push(new Term("native_code"));
                  if (thread.is_multifile_predicate(prop, module_id))
                    current_properties.push(new Term("multifile"));
                  if (get_module.meta_predicates.hasOwnProperty(prop))
                    current_properties.push(new Term("meta_predicate", [
                      get_module.meta_predicates[prop]
                    ]));
                  for (var i2 = 0; i2 < current_properties.length; i2++) {
                    if (pl.type.is_variable(property) || current_properties[i2].indicator === property.indicator) {
                      points.push(new State(point.goal.replace(new Term(",", [
                        new Term("=", [head, unif_head]),
                        new Term("=", [property, current_properties[i2]])
                      ])), point.substitution, point));
                    }
                  }
                }
              }
            } else {
              var builtin = !module_id && pl.type.is_builtin(head);
              var predicate = builtin ? pl.builtin.rules[head.indicator] : get_module.rules[head.indicator];
              get_module = builtin ? pl.builtin : get_module;
              if (predicate) {
                var current_properties;
                if (builtin) {
                  current_properties = [
                    new Term("static"),
                    new Term("built_in"),
                    new Term("native_code")
                  ];
                } else {
                  current_properties = [];
                  if (thread.is_public_predicate(head.indicator, module_id))
                    current_properties.push(new Term("dynamic"));
                  else
                    current_properties.push(new Term("static"));
                  if (predicate instanceof Function)
                    current_properties.push(new Term("native_code"));
                  if (thread.is_multifile_predicate(head.indicator, module_id))
                    current_properties.push(new Term("multifile"));
                }
                if (get_module.meta_predicates.hasOwnProperty(head.indicator))
                  current_properties.push(new Term("meta_predicate", [
                    get_module.meta_predicates[head.indicator]
                  ]));
                var args = [];
                for (var i2 = 0; i2 < head.args.length; i2++)
                  args.push(thread.next_free_variable());
                var unif_head = new Term(head.id, args);
                for (var i2 = 0; i2 < current_properties.length; i2++) {
                  if (pl.type.is_variable(property) || current_properties[i2].indicator === property.indicator) {
                    points.push(new State(point.goal.replace(new Term(",", [
                      new Term("=", [head, unif_head]),
                      new Term("=", [property, current_properties[i2]])
                    ])), point.substitution, point));
                  }
                }
              }
            }
            thread.prepend(points);
          }
        },
        "listing/0": function(thread, point, atom) {
          var context_module = atom.context_module ? atom.context_module : "user";
          var rules2 = {};
          if (pl.type.is_module(thread.session.modules[context_module])) {
            rules2 = thread.session.modules[context_module].rules;
          }
          var str = "";
          for (var indicator2 in rules2) {
            if (!rules2.hasOwnProperty(indicator2))
              continue;
            var predicate = rules2[indicator2];
            str += "% " + indicator2 + "\n";
            if (predicate instanceof Array) {
              for (var i2 = 0; i2 < predicate.length; i2++)
                str += predicate[i2].toString({ session: thread.session }) + "\n";
            } else {
              str += "/*\n" + predicate.toString() + "\n*/";
            }
            str += "\n";
          }
          thread.prepend([new State(point.goal.replace(new Term("write", [new Term(str, [])])), point.substitution, point)]);
        },
        "listing/1": function(thread, point, atom) {
          var indicator2 = atom.args[0];
          var context_module = "user";
          if (indicator2.indicator === ":/2") {
            context_module = indicator2.args[0].id;
            indicator2 = indicator2.args[1];
          }
          if (pl.type.is_variable(indicator2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_predicate_indicator(indicator2)) {
            thread.throw_error(pl.error.type("predicate_indicator", indicator2, atom.indicator));
          } else {
            var rules2 = {};
            if (pl.type.is_module(thread.session.modules[context_module])) {
              rules2 = thread.session.modules[context_module].rules;
            }
            var str = "";
            var str_indicator2 = indicator2.args[0].id + "/" + indicator2.args[1].value;
            if (rules2.hasOwnProperty(str_indicator2)) {
              var predicate = rules2[str_indicator2];
              if (predicate instanceof Array) {
                for (var i2 = 0; i2 < predicate.length; i2++)
                  str += predicate[i2].toString({ session: thread.session }) + "\n";
              } else {
                str += "/*\n" + predicate.toString() + "\n*/";
              }
              str += "\n";
            }
            thread.prepend([new State(point.goal.replace(new Term("write", [new Term(str, [])])), point.substitution, point)]);
          }
        },
        "sort/2": function(thread, point, atom) {
          var list = atom.args[0], expected2 = atom.args[1];
          if (pl.type.is_variable(list)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(expected2) && !pl.type.is_fully_list(expected2)) {
            thread.throw_error(pl.error.type("list", expected2, atom.indicator));
          } else {
            var arr = [];
            var pointer = list;
            while (pointer.indicator === "./2") {
              arr.push(pointer.args[0]);
              pointer = pointer.args[1];
            }
            if (pl.type.is_variable(pointer)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_empty_list(pointer)) {
              thread.throw_error(pl.error.type("list", list, atom.indicator));
            } else {
              var sorted_arr = arr.sort(pl.compare);
              for (var i2 = sorted_arr.length - 1; i2 > 0; i2--) {
                if (sorted_arr[i2].equals(sorted_arr[i2 - 1]))
                  sorted_arr.splice(i2, 1);
              }
              var sorted_list = new Term("[]");
              for (var i2 = sorted_arr.length - 1; i2 >= 0; i2--) {
                sorted_list = new Term(".", [sorted_arr[i2], sorted_list]);
              }
              thread.prepend([new State(point.goal.replace(new Term("=", [sorted_list, expected2])), point.substitution, point)]);
            }
          }
        },
        "keysort/2": function(thread, point, atom) {
          var list = atom.args[0], expected2 = atom.args[1];
          if (pl.type.is_variable(list)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(expected2) && !pl.type.is_fully_list(expected2)) {
            thread.throw_error(pl.error.type("list", expected2, atom.indicator));
          } else {
            var arr = [];
            var elem;
            var pointer = list;
            while (pointer.indicator === "./2") {
              elem = pointer.args[0];
              if (pl.type.is_variable(elem)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_term(elem) || elem.indicator !== "-/2") {
                thread.throw_error(pl.error.type("pair", elem, atom.indicator));
                return;
              }
              elem.args[0].pair = elem.args[1];
              arr.push(elem.args[0]);
              pointer = pointer.args[1];
            }
            if (pl.type.is_variable(pointer)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_empty_list(pointer)) {
              thread.throw_error(pl.error.type("list", list, atom.indicator));
            } else {
              if (!pl.type.is_variable(expected2)) {
                var pointer = expected2;
                while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
                  var head = pointer.args[0];
                  if (!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
                    thread.throw_error(pl.error.type("pair", head, atom.indicator));
                    return;
                  }
                  pointer = pointer.args[1];
                }
                if (!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
                  thread.throw_error(pl.error.type("list", expected2, atom.indicator));
                  return;
                }
              }
              var sorted_arr = arr.sort(pl.compare);
              var sorted_list = new pl.type.Term("[]");
              for (var i2 = sorted_arr.length - 1; i2 >= 0; i2--) {
                sorted_list = new pl.type.Term(".", [new pl.type.Term("-", [sorted_arr[i2], sorted_arr[i2].pair]), sorted_list]);
                delete sorted_arr[i2].pair;
              }
              thread.prepend([new pl.type.State(point.goal.replace(new pl.type.Term("=", [sorted_list, expected2])), point.substitution, point)]);
            }
          }
        },
        "asserta/1": function(thread, point, atom) {
          var clause = atom.args[0];
          var module_id = "user";
          if (pl.type.is_term(clause) && clause.indicator === ":/2") {
            module_id = clause.args[0].id;
            clause = clause.args[1];
          }
          if (pl.type.is_variable(clause)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(clause)) {
            thread.throw_error(pl.error.type("callable", clause, atom.indicator));
          } else {
            var head, body, get_module;
            if (clause.indicator === ":-/2") {
              head = clause.args[0];
              body = body_conversion(clause.args[1]);
            } else {
              head = clause;
              body = null;
            }
            if (pl.type.is_variable(head)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_callable(head)) {
              thread.throw_error(pl.error.type("callable", head, atom.indicator));
            } else if (body !== null && !pl.type.is_callable(body)) {
              thread.throw_error(pl.error.type("callable", body, atom.indicator));
            } else if ((!pl.type.is_module(thread.session.modules[module_id]) || thread.is_public_predicate(head.indicator, module_id)) && head.indicator !== ",/2" && !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
              if (!pl.type.is_module(thread.session.modules[module_id])) {
                get_module = new Module(module_id, {}, "all", { session: thread.session });
                thread.session.modules[module_id] = get_module;
              } else {
                get_module = thread.session.modules[module_id];
              }
              if (get_module.rules[head.indicator] === void 0)
                get_module.rules[head.indicator] = [];
              get_module.public_predicates[head.indicator] = true;
              get_module.rules[head.indicator] = [new Rule(head, body, true)].concat(get_module.rules[head.indicator]);
              thread.success(point);
            } else {
              thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
            }
          }
        },
        "assertz/1": function(thread, point, atom) {
          var clause = atom.args[0];
          var module_id = "user";
          if (pl.type.is_term(clause) && clause.indicator === ":/2") {
            module_id = clause.args[0].id;
            clause = clause.args[1];
          }
          if (pl.type.is_variable(clause)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(clause)) {
            thread.throw_error(pl.error.type("callable", clause, atom.indicator));
          } else {
            var head, body, get_module;
            if (clause.indicator === ":-/2") {
              head = clause.args[0];
              body = body_conversion(clause.args[1]);
            } else {
              head = clause;
              body = null;
            }
            if (pl.type.is_variable(head)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
            } else if (!pl.type.is_callable(head)) {
              thread.throw_error(pl.error.type("callable", head, atom.indicator));
            } else if (body !== null && !pl.type.is_callable(body)) {
              thread.throw_error(pl.error.type("callable", body, atom.indicator));
            } else if ((!pl.type.is_module(thread.session.modules[module_id]) || thread.is_public_predicate(head.indicator, module_id)) && head.indicator !== ",/2" && !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
              if (!pl.type.is_module(thread.session.modules[module_id])) {
                get_module = new Module(module_id, {}, "all", { session: thread.session });
                thread.session.modules[module_id] = get_module;
              } else {
                get_module = thread.session.modules[module_id];
              }
              if (get_module.rules[head.indicator] === void 0)
                get_module.rules[head.indicator] = [];
              get_module.public_predicates[head.indicator] = true;
              get_module.rules[head.indicator].push(new Rule(head, body, true));
              thread.success(point);
            } else {
              thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
            }
          }
        },
        "retract/1": function(thread, point, atom) {
          var clause = atom.args[0];
          if (pl.type.is_variable(clause)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(clause)) {
            thread.throw_error(pl.error.type("callable", clause, atom.indicator));
          } else {
            var head, body, module_atom, module_id;
            if (clause.indicator === ":/2") {
              module_atom = clause.args[0];
              clause = clause.args[1];
              if (!pl.type.is_atom(module_atom)) {
                thread.throw_error(pl.error.type("module", module_atom, atom.indicator));
                return;
              }
            } else {
              module_atom = new Term("user");
            }
            if (clause.indicator === ":-/2") {
              head = clause.args[0];
              body = clause.args[1];
            } else {
              head = clause;
              body = new Term("true");
            }
            if (pl.type.is_variable(head)) {
              thread.throw_error(pl.error.instantiation(atom.indicator));
              return;
            } else if (!pl.type.is_callable(head)) {
              thread.throw_error(pl.error.type("callable", head, atom.indicator));
              return;
            }
            module_id = module_atom.id;
            var get_module = thread.session.modules[module_id];
            if (!pl.type.is_module(get_module))
              return;
            if (!point.retract) {
              if (thread.is_public_predicate(head.indicator, module_id) && head.indicator !== ",/2" && !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
                if (get_module.rules[head.indicator] !== void 0) {
                  var states = [];
                  if (typeof get_module.rules[head.indicator] === "function") {
                    thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
                    return;
                  }
                  for (var i2 = 0; i2 < get_module.rules[head.indicator].length; i2++) {
                    thread.session.renamed_variables = {};
                    var orule = get_module.rules[head.indicator][i2];
                    var rule = orule.rename(thread);
                    if (rule.body === null)
                      rule.body = new Term("true", []);
                    var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
                    var mgu = pl.unify(new Term(",", [head, body]), new Term(",", [rule.head, rule.body]), occurs_check);
                    if (mgu !== null) {
                      var state = new State(point.goal.replace(new Term(",", [
                        new Term(":", [
                          module_atom,
                          new Term("retract", [new Term(":-", [head, body])])
                        ]),
                        new Term(",", [
                          new Term("=", [head, rule.head]),
                          new Term("=", [body, rule.body])
                        ])
                      ])), point.substitution, point);
                      state.retract = orule;
                      states.push(state);
                    }
                  }
                  thread.prepend(states);
                }
              } else {
                thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
              }
            } else {
              retract(thread, point, head.indicator, point.retract, get_module);
            }
          }
        },
        "retractall/1": function(thread, point, atom) {
          var head = atom.args[0];
          var context_module = "user";
          if (pl.type.is_term(head) && head.indicator === ":/2") {
            context_module = head.args[0].id;
            head = head.args[1];
          }
          if (pl.type.is_variable(head)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(head)) {
            thread.throw_error(pl.error.type("callable", head, atom.indicator));
          } else if (!thread.is_public_predicate(head.indicator, context_module) || head.indicator === ",/2" || thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
            thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
          } else {
            thread.prepend([
              new State(point.goal.replace(new Term(",", [
                new Term(":", [
                  new Term(context_module),
                  new Term("retract", [new pl.type.Term(":-", [head, new Var("_")])])
                ]),
                new Term("fail", [])
              ])), point.substitution, point),
              new State(point.goal.replace(null), point.substitution, point)
            ]);
          }
        },
        "abolish/1": function(thread, point, atom) {
          var predicate = atom.args[0];
          var module_id;
          if (pl.type.is_term(predicate) && predicate.indicator === ":/2") {
            if (!pl.type.is_atom(predicate.args[0])) {
              thread.throw_error(pl.error.type("module", predicate.args[0], atom.indicator));
              return;
            }
            module_id = predicate.args[0].id;
            predicate = predicate.args[1];
          } else {
            module_id = "user";
          }
          if (pl.type.is_variable(predicate) || pl.type.is_term(predicate) && predicate.indicator === "//2" && (pl.type.is_variable(predicate.args[0]) || pl.type.is_variable(predicate.args[1]))) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_term(predicate) || predicate.indicator !== "//2") {
            thread.throw_error(pl.error.type("predicate_indicator", predicate, atom.indicator));
          } else if (!pl.type.is_atom(predicate.args[0])) {
            thread.throw_error(pl.error.type("atom", predicate.args[0], atom.indicator));
          } else if (!pl.type.is_integer(predicate.args[1])) {
            thread.throw_error(pl.error.type("integer", predicate.args[1], atom.indicator));
          } else if (predicate.args[1].value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", predicate.args[1], atom.indicator));
          } else if (pl.type.is_number(thread.get_flag("max_arity")) && predicate.args[1].value > thread.get_flag("max_arity").value) {
            thread.throw_error(pl.error.representation("max_arity", atom.indicator));
          } else {
            var get_module = thread.session.modules[module_id];
            if (pl.type.is_module(get_module)) {
              var indicator2 = predicate.args[0].id + "/" + predicate.args[1].value;
              if (thread.is_public_predicate(indicator2, module_id) && indicator2 !== ",/2" && !thread.session.modules.system.rules.hasOwnProperty(indicator2)) {
                delete get_module.rules[indicator2];
                delete get_module.public_predicates[indicator2];
                delete get_module.multifile_predicates[indicator2];
                thread.success(point);
              } else {
                thread.throw_error(pl.error.permission("modify", "static_procedure", atom.args[0], atom.indicator));
              }
            } else {
              thread.success(point);
            }
          }
        },
        "atom_length/2": function(thread, point, atom) {
          if (pl.type.is_variable(atom.args[0])) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atom(atom.args[0])) {
            thread.throw_error(pl.error.type("atom", atom.args[0], atom.indicator));
          } else if (!pl.type.is_variable(atom.args[1]) && !pl.type.is_integer(atom.args[1])) {
            thread.throw_error(pl.error.type("integer", atom.args[1], atom.indicator));
          } else if (pl.type.is_integer(atom.args[1]) && atom.args[1].value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", atom.args[1], atom.indicator));
          } else {
            var length = new Num(stringLength(atom.args[0].id), false);
            thread.prepend([new State(point.goal.replace(new Term("=", [length, atom.args[1]])), point.substitution, point)]);
          }
        },
        "atom_concat/3": function(thread, point, atom) {
          var str, goal, start = atom.args[0], end = atom.args[1], whole = atom.args[2];
          if (pl.type.is_variable(whole) && (pl.type.is_variable(start) || pl.type.is_variable(end))) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(start) && !pl.type.is_atom(start)) {
            thread.throw_error(pl.error.type("atom", start, atom.indicator));
          } else if (!pl.type.is_variable(end) && !pl.type.is_atom(end)) {
            thread.throw_error(pl.error.type("atom", end, atom.indicator));
          } else if (!pl.type.is_variable(whole) && !pl.type.is_atom(whole)) {
            thread.throw_error(pl.error.type("atom", whole, atom.indicator));
          } else {
            var v1 = pl.type.is_variable(start);
            var v2 = pl.type.is_variable(end);
            if (!v1 && !v2) {
              goal = new Term("=", [whole, new Term(start.id + end.id)]);
              thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
            } else if (v1 && !v2) {
              str = whole.id.substr(0, whole.id.length - end.id.length);
              if (str + end.id === whole.id) {
                goal = new Term("=", [start, new Term(str)]);
                thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
              }
            } else if (v2 && !v1) {
              str = whole.id.substr(start.id.length);
              if (start.id + str === whole.id) {
                goal = new Term("=", [end, new Term(str)]);
                thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
              }
            } else {
              var states = [];
              for (var i2 = 0; i2 <= whole.id.length; i2++) {
                var atom1 = new Term(whole.id.substr(0, i2));
                var atom2 = new Term(whole.id.substr(i2));
                goal = new Term(",", [new Term("=", [atom1, start]), new Term("=", [atom2, end])]);
                states.push(new State(point.goal.replace(goal), point.substitution, point));
              }
              thread.prepend(states);
            }
          }
        },
        "sub_atom/5": function(thread, point, atom) {
          var i2, atom1 = atom.args[0], before = atom.args[1], length = atom.args[2], after = atom.args[3], subatom = atom.args[4];
          if (pl.type.is_variable(atom1)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atom(atom1)) {
            thread.throw_error(pl.error.type("atom", atom1, atom.indicator));
          } else if (!pl.type.is_variable(before) && !pl.type.is_integer(before)) {
            thread.throw_error(pl.error.type("integer", before, atom.indicator));
          } else if (!pl.type.is_variable(length) && !pl.type.is_integer(length)) {
            thread.throw_error(pl.error.type("integer", length, atom.indicator));
          } else if (!pl.type.is_variable(after) && !pl.type.is_integer(after)) {
            thread.throw_error(pl.error.type("integer", after, atom.indicator));
          } else if (pl.type.is_integer(before) && before.value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", before, atom.indicator));
          } else if (pl.type.is_integer(length) && length.value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", length, atom.indicator));
          } else if (pl.type.is_integer(after) && after.value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", after, atom.indicator));
          } else if (!pl.type.is_variable(subatom) && !pl.type.is_atom(subatom)) {
            thread.throw_error(pl.error.type("atom", subatom, atom.indicator));
          } else {
            var bs = [], ls = [], as = [];
            if (pl.type.is_variable(before)) {
              for (i2 = 0; i2 <= atom1.id.length; i2++) {
                bs.push(i2);
              }
            } else {
              bs.push(before.value);
            }
            if (pl.type.is_variable(length)) {
              for (i2 = 0; i2 <= atom1.id.length; i2++) {
                ls.push(i2);
              }
            } else {
              ls.push(length.value);
            }
            if (pl.type.is_variable(after)) {
              for (i2 = 0; i2 <= atom1.id.length; i2++) {
                as.push(i2);
              }
            } else {
              as.push(after.value);
            }
            var states = [];
            for (var _i in bs) {
              if (!bs.hasOwnProperty(_i))
                continue;
              i2 = bs[_i];
              for (var _j in ls) {
                if (!ls.hasOwnProperty(_j))
                  continue;
                var j = ls[_j];
                var k = atom1.id.length - i2 - j;
                if (indexOf(as, k) !== -1) {
                  if (i2 + j + k === atom1.id.length) {
                    var str = atom1.id.substr(i2, j);
                    if (atom1.id === atom1.id.substr(0, i2) + str + atom1.id.substr(i2 + j, k)) {
                      var pl1 = new Term("=", [new Term(str), subatom]);
                      var pl2 = new Term("=", [before, new Num(i2)]);
                      var pl3 = new Term("=", [length, new Num(j)]);
                      var pl4 = new Term("=", [after, new Num(k)]);
                      var goal = new Term(",", [new Term(",", [new Term(",", [pl2, pl3]), pl4]), pl1]);
                      states.push(new State(point.goal.replace(goal), point.substitution, point));
                    }
                  }
                }
              }
            }
            thread.prepend(states);
          }
        },
        "atom_chars/2": function(thread, point, atom) {
          var atom1 = atom.args[0], list = atom.args[1];
          if (pl.type.is_variable(atom1) && pl.type.is_variable(list)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(atom1) && !pl.type.is_atom(atom1)) {
            thread.throw_error(pl.error.type("atom", atom1, atom.indicator));
          } else {
            if (!pl.type.is_variable(atom1)) {
              if (!pl.type.is_variable(list)) {
                var pointer = list;
                while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
                  if (!pl.type.is_character(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
                    thread.throw_error(pl.error.type("character", pointer.args[0], atom.indicator));
                    return;
                  }
                  pointer = pointer.args[1];
                }
              }
              var list1 = new Term("[]");
              var unilen = stringLength(atom1.id);
              for (var i2 = unilen - 1; i2 >= 0; i2--) {
                list1 = new Term(".", [new Term(atom1.id.charAt(i2)), list1]);
              }
              thread.prepend([new State(point.goal.replace(new Term("=", [list, list1])), point.substitution, point)]);
            } else {
              var pointer = list;
              var v = pl.type.is_variable(atom1);
              var str = "";
              while (pointer.indicator === "./2") {
                if (!pl.type.is_character(pointer.args[0])) {
                  if (pl.type.is_variable(pointer.args[0]) && v) {
                    thread.throw_error(pl.error.instantiation(atom.indicator));
                    return;
                  } else if (!pl.type.is_variable(pointer.args[0])) {
                    thread.throw_error(pl.error.type("character", pointer.args[0], atom.indicator));
                    return;
                  }
                } else {
                  str += pointer.args[0].id;
                }
                pointer = pointer.args[1];
              }
              if (pl.type.is_variable(pointer) && v) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
              } else if (!pl.type.is_empty_list(pointer) && !pl.type.is_variable(pointer)) {
                thread.throw_error(pl.error.type("list", list, atom.indicator));
              } else {
                thread.prepend([new State(point.goal.replace(new Term("=", [new Term(str), atom1])), point.substitution, point)]);
              }
            }
          }
        },
        "atom_codes/2": function(thread, point, atom) {
          var atom1 = atom.args[0], list = atom.args[1];
          if (pl.type.is_variable(atom1) && pl.type.is_variable(list)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(atom1) && !pl.type.is_atom(atom1)) {
            thread.throw_error(pl.error.type("atom", atom1, atom.indicator));
          } else {
            if (!pl.type.is_variable(atom1)) {
              if (!pl.type.is_variable(list)) {
                var pointer = list;
                while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
                  if (!pl.type.is_character_code(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
                    thread.throw_error(pl.error.type("integer", pointer.args[0], atom.indicator));
                    return;
                  }
                  pointer = pointer.args[1];
                }
              }
              var list1 = new Term("[]");
              var unilen = stringLength(atom1.id);
              for (var i2 = unilen - 1; i2 >= 0; i2--) {
                list1 = new Term(".", [new Num(codePointAt(atom1.id, i2), false), list1]);
              }
              thread.prepend([new State(point.goal.replace(new Term("=", [list, list1])), point.substitution, point)]);
            } else {
              var pointer = list;
              var v = pl.type.is_variable(atom1);
              var str = "";
              while (pointer.indicator === "./2") {
                if (!pl.type.is_character_code(pointer.args[0])) {
                  if (pl.type.is_variable(pointer.args[0]) && v) {
                    thread.throw_error(pl.error.instantiation(atom.indicator));
                    return;
                  } else if (!pl.type.is_variable(pointer.args[0])) {
                    thread.throw_error(pl.error.representation("character_code", atom.indicator));
                    return;
                  }
                } else {
                  str += fromCodePoint(pointer.args[0].value);
                }
                pointer = pointer.args[1];
              }
              if (pl.type.is_variable(pointer) && v) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
              } else if (!pl.type.is_empty_list(pointer) && !pl.type.is_variable(pointer)) {
                thread.throw_error(pl.error.type("list", list, atom.indicator));
              } else {
                thread.prepend([new State(point.goal.replace(new Term("=", [new Term(str), atom1])), point.substitution, point)]);
              }
            }
          }
        },
        "char_code/2": function(thread, point, atom) {
          var char = atom.args[0], code = atom.args[1];
          if (pl.type.is_variable(char) && pl.type.is_variable(code)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(char) && !pl.type.is_character(char)) {
            thread.throw_error(pl.error.type("character", char, atom.indicator));
          } else if (!pl.type.is_variable(code) && !pl.type.is_integer(code)) {
            thread.throw_error(pl.error.type("integer", code, atom.indicator));
          } else if (!pl.type.is_variable(code) && !pl.type.is_character_code(code)) {
            thread.throw_error(pl.error.representation("character_code", atom.indicator));
          } else {
            if (pl.type.is_variable(code)) {
              var code1 = new Num(codePointAt(char.id, 0), false);
              thread.prepend([new State(point.goal.replace(new Term("=", [code1, code])), point.substitution, point)]);
            } else {
              var char1 = new Term(fromCodePoint(code.value));
              thread.prepend([new State(point.goal.replace(new Term("=", [char1, char])), point.substitution, point)]);
            }
          }
        },
        "number_chars/2": function(thread, point, atom) {
          var str, num = atom.args[0], list = atom.args[1];
          if (pl.type.is_variable(num) && pl.type.is_variable(list)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(num) && !pl.type.is_number(num)) {
            thread.throw_error(pl.error.type("number", num, atom.indicator));
          } else if (!pl.type.is_variable(list) && !pl.type.is_list(list)) {
            thread.throw_error(pl.error.type("list", list, atom.indicator));
          } else {
            var isvar = pl.type.is_variable(num);
            if (!pl.type.is_variable(list)) {
              var pointer = list;
              var total = true;
              str = "";
              while (pointer.indicator === "./2") {
                if (!pl.type.is_character(pointer.args[0])) {
                  if (pl.type.is_variable(pointer.args[0])) {
                    total = false;
                  } else if (!pl.type.is_variable(pointer.args[0])) {
                    thread.throw_error(pl.error.type("character", pointer.args[0], atom.indicator));
                    return;
                  }
                } else {
                  str += pointer.args[0].id;
                }
                pointer = pointer.args[1];
              }
              total = total && pl.type.is_empty_list(pointer);
              if (!pl.type.is_empty_list(pointer) && !pl.type.is_variable(pointer)) {
                thread.throw_error(pl.error.type("list", list, atom.indicator));
                return;
              }
              if (!total && isvar) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (total) {
                if (pl.type.is_variable(pointer) && isvar) {
                  thread.throw_error(pl.error.instantiation(atom.indicator));
                  return;
                } else {
                  var expr = thread.parse(str);
                  var num2 = expr.value;
                  if (!pl.type.is_number(num2) || expr.tokens[expr.tokens.length - 1].space) {
                    thread.throw_error(pl.error.syntax_by_predicate("parseable_number", atom.indicator));
                  } else {
                    thread.prepend([new State(point.goal.replace(new Term("=", [num, num2])), point.substitution, point)]);
                  }
                  return;
                }
              }
            }
            if (!isvar) {
              str = num.toString();
              var list2 = new Term("[]");
              for (var i2 = str.length - 1; i2 >= 0; i2--) {
                list2 = new Term(".", [new Term(str.charAt(i2)), list2]);
              }
              thread.prepend([new State(point.goal.replace(new Term("=", [list, list2])), point.substitution, point)]);
            }
          }
        },
        "number_codes/2": function(thread, point, atom) {
          var str, num = atom.args[0], list = atom.args[1];
          if (pl.type.is_variable(num) && pl.type.is_variable(list)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(num) && !pl.type.is_number(num)) {
            thread.throw_error(pl.error.type("number", num, atom.indicator));
          } else if (!pl.type.is_variable(list) && !pl.type.is_list(list)) {
            thread.throw_error(pl.error.type("list", list, atom.indicator));
          } else {
            var isvar = pl.type.is_variable(num);
            if (!pl.type.is_variable(list)) {
              var pointer = list;
              var total = true;
              str = "";
              while (pointer.indicator === "./2") {
                if (!pl.type.is_character_code(pointer.args[0])) {
                  if (pl.type.is_variable(pointer.args[0])) {
                    total = false;
                  } else if (!pl.type.is_variable(pointer.args[0])) {
                    thread.throw_error(pl.error.representation("character_code", atom.indicator));
                    return;
                  }
                } else {
                  str += fromCodePoint(pointer.args[0].value);
                }
                pointer = pointer.args[1];
              }
              total = total && pl.type.is_empty_list(pointer);
              if (!pl.type.is_empty_list(pointer) && !pl.type.is_variable(pointer)) {
                thread.throw_error(pl.error.type("list", list, atom.indicator));
                return;
              }
              if (!total && isvar) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (total) {
                if (pl.type.is_variable(pointer) && isvar) {
                  thread.throw_error(pl.error.instantiation(atom.indicator));
                  return;
                } else {
                  var expr = thread.parse(str);
                  var num2 = expr.value;
                  if (!pl.type.is_number(num2) || expr.tokens[expr.tokens.length - 1].space) {
                    thread.throw_error(pl.error.syntax_by_predicate("parseable_number", atom.indicator));
                  } else {
                    thread.prepend([new State(point.goal.replace(new Term("=", [num, num2])), point.substitution, point)]);
                  }
                  return;
                }
              }
            }
            if (!isvar) {
              str = num.toString();
              var list2 = new Term("[]");
              for (var i2 = str.length - 1; i2 >= 0; i2--) {
                list2 = new Term(".", [new Num(codePointAt(str, i2), false), list2]);
              }
              thread.prepend([new State(point.goal.replace(new Term("=", [list, list2])), point.substitution, point)]);
            }
          }
        },
        "upcase_atom/2": function(thread, point, atom) {
          var original = atom.args[0], upcase = atom.args[1];
          if (pl.type.is_variable(original)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atom(original)) {
            thread.throw_error(pl.error.type("atom", original, atom.indicator));
          } else if (!pl.type.is_variable(upcase) && !pl.type.is_atom(upcase)) {
            thread.throw_error(pl.error.type("atom", upcase, atom.indicator));
          } else {
            thread.prepend([new State(point.goal.replace(new Term("=", [upcase, new Term(original.id.toUpperCase(), [])])), point.substitution, point)]);
          }
        },
        "downcase_atom/2": function(thread, point, atom) {
          var original = atom.args[0], downcase = atom.args[1];
          if (pl.type.is_variable(original)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atom(original)) {
            thread.throw_error(pl.error.type("atom", original, atom.indicator));
          } else if (!pl.type.is_variable(downcase) && !pl.type.is_atom(downcase)) {
            thread.throw_error(pl.error.type("atom", downcase, atom.indicator));
          } else {
            thread.prepend([new State(point.goal.replace(new Term("=", [downcase, new Term(original.id.toLowerCase(), [])])), point.substitution, point)]);
          }
        },
        "atomic_concat/3": function(thread, point, atom) {
          var atomic1 = atom.args[0], atomic2 = atom.args[1], concat = atom.args[2];
          if (pl.type.is_variable(atomic1) || pl.type.is_variable(atomic2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atomic(atomic1)) {
            thread.throw_error(pl.error.type("atomic", atomic1, atom.indicator));
          } else if (!pl.type.is_atomic(atomic2)) {
            thread.throw_error(pl.error.type("atomic", atomic2, atom.indicator));
          } else if (!pl.type.is_variable(concat) && !pl.type.is_atom(concat)) {
            thread.throw_error(pl.error.type("atom", concat, atom.indicator));
          } else {
            var id = "";
            if (pl.type.is_atom(atomic1)) {
              id += atomic1.id;
            } else {
              id += "" + atomic1.value;
            }
            if (pl.type.is_atom(atomic2)) {
              id += atomic2.id;
            } else {
              id += "" + atomic2.value;
            }
            var atom = new Term(id, []);
            thread.prepend([new State(point.goal.replace(new Term("=", [atom, concat])), point.substitution, point)]);
          }
        },
        "atomic_list_concat/2": function(thread, point, atom) {
          var list = atom.args[0], concat = atom.args[1];
          thread.prepend([new State(point.goal.replace(new Term("atomic_list_concat", [list, new Term("", []), concat])), point.substitution, point)]);
        },
        "atomic_list_concat/3": function(thread, point, atom) {
          var list = atom.args[0], separator = atom.args[1], concat = atom.args[2];
          if (pl.type.is_variable(separator) || pl.type.is_variable(list) && pl.type.is_variable(concat)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(list) && !pl.type.is_list(list)) {
            thread.throw_error(pl.error.type("list", list, atom.indicator));
          } else if (!pl.type.is_variable(concat) && !pl.type.is_atom(concat)) {
            thread.throw_error(pl.error.type("atom", concat, atom.indicator));
          } else {
            if (!pl.type.is_variable(concat)) {
              var atomic = arrayToList(map(concat.id.split(separator.id), function(id2) {
                return new Term(id2, []);
              }));
              thread.prepend([new State(point.goal.replace(new Term("=", [atomic, list])), point.substitution, point)]);
            } else {
              var id = "";
              var pointer = list;
              while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
                if (!pl.type.is_atom(pointer.args[0]) && !pl.type.is_number(pointer.args[0])) {
                  thread.throw_error(pl.error.type("atomic", pointer.args[0], atom.indicator));
                  return;
                }
                if (id !== "")
                  id += separator.id;
                if (pl.type.is_atom(pointer.args[0]))
                  id += pointer.args[0].id;
                else
                  id += "" + pointer.args[0].value;
                pointer = pointer.args[1];
              }
              id = new Term(id, []);
              if (pl.type.is_variable(pointer)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
              } else if (!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
                thread.throw_error(pl.error.type("list", list, atom.indicator));
              } else {
                thread.prepend([new State(point.goal.replace(new Term("=", [id, concat])), point.substitution, point)]);
              }
            }
          }
        },
        "@=</2": function(thread, point, atom) {
          if (pl.compare(atom.args[0], atom.args[1]) <= 0) {
            thread.success(point);
          }
        },
        "==/2": function(thread, point, atom) {
          if (pl.compare(atom.args[0], atom.args[1]) === 0) {
            thread.success(point);
          }
        },
        "\\==/2": function(thread, point, atom) {
          if (pl.compare(atom.args[0], atom.args[1]) !== 0) {
            thread.success(point);
          }
        },
        "@</2": function(thread, point, atom) {
          if (pl.compare(atom.args[0], atom.args[1]) < 0) {
            thread.success(point);
          }
        },
        "@>/2": function(thread, point, atom) {
          if (pl.compare(atom.args[0], atom.args[1]) > 0) {
            thread.success(point);
          }
        },
        "@>=/2": function(thread, point, atom) {
          if (pl.compare(atom.args[0], atom.args[1]) >= 0) {
            thread.success(point);
          }
        },
        "compare/3": function(thread, point, atom) {
          var order = atom.args[0], left = atom.args[1], right = atom.args[2];
          if (!pl.type.is_variable(order) && !pl.type.is_atom(order)) {
            thread.throw_error(pl.error.type("atom", order, atom.indicator));
          } else if (pl.type.is_atom(order) && ["<", ">", "="].indexOf(order.id) === -1) {
            thread.throw_error(pl.error.domain("order", order, atom.indicator));
          } else {
            var compare = pl.compare(left, right);
            compare = compare === 0 ? "=" : compare === -1 ? "<" : ">";
            thread.prepend([new State(point.goal.replace(new Term("=", [order, new Term(compare, [])])), point.substitution, point)]);
          }
        },
        "is/2": function(thread, point, atom) {
          var op = atom.args[1].interpret(thread);
          if (!pl.type.is_number(op)) {
            thread.throw_error(op);
          } else {
            thread.prepend([new State(point.goal.replace(new Term("=", [atom.args[0], op], atom.indicator)), point.substitution, point)]);
          }
        },
        "between/3": function(thread, point, atom) {
          var lower = atom.args[0], upper = atom.args[1], bet = atom.args[2];
          if (pl.type.is_variable(lower) || pl.type.is_variable(upper)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_integer(lower)) {
            thread.throw_error(pl.error.type("integer", lower, atom.indicator));
          } else if (!pl.type.is_integer(upper)) {
            thread.throw_error(pl.error.type("integer", upper, atom.indicator));
          } else if (!pl.type.is_variable(bet) && !pl.type.is_integer(bet)) {
            thread.throw_error(pl.error.type("integer", bet, atom.indicator));
          } else {
            if (pl.type.is_variable(bet)) {
              if (lower.value <= upper.value) {
                var states = [new State(point.goal.replace(new Term("=", [bet, lower])), point.substitution, point)];
                states.push(new State(point.goal.replace(new Term("between", [new Num(lower.value + 1, false), upper, bet])), point.substitution, point));
                thread.prepend(states);
              }
            } else if (lower.value <= bet.value && upper.value >= bet.value) {
              thread.success(point);
            }
          }
        },
        "succ/2": function(thread, point, atom) {
          var n = atom.args[0], m = atom.args[1];
          if (pl.type.is_variable(n) && pl.type.is_variable(m)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(n) && !pl.type.is_integer(n)) {
            thread.throw_error(pl.error.type("integer", n, atom.indicator));
          } else if (!pl.type.is_variable(m) && !pl.type.is_integer(m)) {
            thread.throw_error(pl.error.type("integer", m, atom.indicator));
          } else if (!pl.type.is_variable(n) && n.value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", n, atom.indicator));
          } else if (!pl.type.is_variable(m) && m.value < 0) {
            thread.throw_error(pl.error.domain("not_less_than_zero", m, atom.indicator));
          } else {
            if (pl.type.is_variable(m) || m.value > 0) {
              if (pl.type.is_variable(n)) {
                thread.prepend([new State(point.goal.replace(new Term("=", [n, new Num(m.value - 1, false)])), point.substitution, point)]);
              } else {
                thread.prepend([new State(point.goal.replace(new Term("=", [m, new Num(n.value + 1, false)])), point.substitution, point)]);
              }
            }
          }
        },
        "=:=/2": function(thread, point, atom) {
          var cmp = pl.arithmetic_compare(thread, atom.args[0], atom.args[1]);
          if (pl.type.is_term(cmp)) {
            thread.throw_error(cmp);
          } else if (cmp === 0) {
            thread.success(point);
          }
        },
        "=\\=/2": function(thread, point, atom) {
          var cmp = pl.arithmetic_compare(thread, atom.args[0], atom.args[1]);
          if (pl.type.is_term(cmp)) {
            thread.throw_error(cmp);
          } else if (cmp !== 0) {
            thread.success(point);
          }
        },
        "</2": function(thread, point, atom) {
          var cmp = pl.arithmetic_compare(thread, atom.args[0], atom.args[1]);
          if (pl.type.is_term(cmp)) {
            thread.throw_error(cmp);
          } else if (cmp < 0) {
            thread.success(point);
          }
        },
        "=</2": function(thread, point, atom) {
          var cmp = pl.arithmetic_compare(thread, atom.args[0], atom.args[1]);
          if (pl.type.is_term(cmp)) {
            thread.throw_error(cmp);
          } else if (cmp <= 0) {
            thread.success(point);
          }
        },
        ">/2": function(thread, point, atom) {
          var cmp = pl.arithmetic_compare(thread, atom.args[0], atom.args[1]);
          if (pl.type.is_term(cmp)) {
            thread.throw_error(cmp);
          } else if (cmp > 0) {
            thread.success(point);
          }
        },
        ">=/2": function(thread, point, atom) {
          var cmp = pl.arithmetic_compare(thread, atom.args[0], atom.args[1]);
          if (pl.type.is_term(cmp)) {
            thread.throw_error(cmp);
          } else if (cmp >= 0) {
            thread.success(point);
          }
        },
        "var/1": function(thread, point, atom) {
          if (pl.type.is_variable(atom.args[0])) {
            thread.success(point);
          }
        },
        "atom/1": function(thread, point, atom) {
          if (pl.type.is_atom(atom.args[0])) {
            thread.success(point);
          }
        },
        "atomic/1": function(thread, point, atom) {
          if (pl.type.is_atomic(atom.args[0])) {
            thread.success(point);
          }
        },
        "compound/1": function(thread, point, atom) {
          if (pl.type.is_compound(atom.args[0])) {
            thread.success(point);
          }
        },
        "integer/1": function(thread, point, atom) {
          if (pl.type.is_integer(atom.args[0])) {
            thread.success(point);
          }
        },
        "float/1": function(thread, point, atom) {
          if (pl.type.is_float(atom.args[0])) {
            thread.success(point);
          }
        },
        "number/1": function(thread, point, atom) {
          if (pl.type.is_number(atom.args[0])) {
            thread.success(point);
          }
        },
        "nonvar/1": function(thread, point, atom) {
          if (!pl.type.is_variable(atom.args[0])) {
            thread.success(point);
          }
        },
        "ground/1": function(thread, point, atom) {
          if (atom.variables().length === 0) {
            thread.success(point);
          }
        },
        "acyclic_term/1": function(thread, point, atom) {
          var test = point.substitution.apply(point.substitution);
          var variables = atom.args[0].variables();
          for (var i2 = 0; i2 < variables.length; i2++)
            if (point.substitution.links[variables[i2]] !== void 0 && !point.substitution.links[variables[i2]].equals(test.links[variables[i2]]))
              return;
          thread.success(point);
        },
        "callable/1": function(thread, point, atom) {
          var callable = atom.args[0];
          if (pl.type.is_term(callable)) {
            thread.success(point);
          }
        },
        "is_list/1": function(thread, point, atom) {
          var list = atom.args[0];
          while (pl.type.is_term(list) && list.indicator === "./2")
            list = list.args[1];
          if (pl.type.is_term(list) && list.indicator === "[]/0")
            thread.success(point);
        },
        "current_input/1": function(thread, point, atom) {
          var stream = atom.args[0];
          if (!pl.type.is_variable(stream) && (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias) && !thread.get_stream_by_alias(stream.id)) && (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
            thread.throw_error(pl.error.domain("stream", stream, atom.indicator));
          } else {
            if (pl.type.is_atom(stream))
              stream = thread.get_stream_by_alias(stream.id);
            thread.prepend([
              new State(point.goal.replace(new Term("=", [stream, thread.get_current_input()])), point.substitution, point)
            ]);
          }
        },
        "current_output/1": function(thread, point, atom) {
          var stream = atom.args[0];
          if (!pl.type.is_variable(stream) && (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias) && !thread.get_stream_by_alias(stream.id)) && (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
            thread.throw_error(pl.error.domain("stream", stream, atom.indicator));
          } else {
            if (pl.type.is_atom(stream))
              stream = thread.get_stream_by_alias(stream.id);
            thread.prepend([
              new State(point.goal.replace(new Term("=", [stream, thread.get_current_output()])), point.substitution, point)
            ]);
          }
        },
        "set_input/1": function(thread, point, atom) {
          var input2 = atom.args[0];
          var stream = pl.type.is_stream(input2) ? input2 : thread.get_stream_by_alias(input2.id);
          if (pl.type.is_variable(input2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_stream(input2) && !pl.type.is_atom(input2)) {
            thread.throw_error(pl.error.domain("stream_or_alias", input2, atom.indicator));
          } else if (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(input2.alias) && !thread.get_stream_by_alias(input2.id)) {
            thread.throw_error(pl.error.existence("stream", input2, atom.indicator));
          } else if (stream.output === true) {
            thread.throw_error(pl.error.permission("input", "stream", input2, atom.indicator));
          } else {
            thread.set_current_input(stream);
            thread.success(point);
          }
        },
        "set_output/1": function(thread, point, atom) {
          var output = atom.args[0];
          var stream = pl.type.is_stream(output) ? output : thread.get_stream_by_alias(output.id);
          if (pl.type.is_variable(output)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_stream(output) && !pl.type.is_atom(output)) {
            thread.throw_error(pl.error.domain("stream_or_alias", output, atom.indicator));
          } else if (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(output.alias) && !thread.get_stream_by_alias(output.id)) {
            thread.throw_error(pl.error.existence("stream", output, atom.indicator));
          } else if (stream.input === true) {
            thread.throw_error(pl.error.permission("output", "stream", output, atom.indicator));
          } else {
            thread.set_current_output(stream);
            thread.success(point);
          }
        },
        "open/3": function(thread, point, atom) {
          var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2];
          thread.prepend([new State(point.goal.replace(new Term("open", [dest, mode, stream, new Term("[]", [])])), point.substitution, point)]);
        },
        "open/4": function(thread, point, atom) {
          var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2], options2 = atom.args[3];
          if (pl.type.is_variable(dest) || pl.type.is_variable(mode) || pl.type.is_variable(options2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(mode) && !pl.type.is_atom(mode)) {
            thread.throw_error(pl.error.type("atom", mode, atom.indicator));
          } else if (!pl.type.is_list(options2)) {
            thread.throw_error(pl.error.type("list", options2, atom.indicator));
          } else if (!pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.uninstantiation(stream, atom.indicator));
          } else if (!pl.type.is_atom(dest) && !pl.type.is_streamable(dest)) {
            thread.throw_error(pl.error.domain("source_sink", dest, atom.indicator));
          } else if (!pl.type.is_io_mode(mode)) {
            thread.throw_error(pl.error.domain("io_mode", mode, atom.indicator));
          } else {
            var obj_options = {};
            var pointer = options2;
            var property;
            while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
              property = pointer.args[0];
              if (pl.type.is_variable(property)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_stream_option(property)) {
                thread.throw_error(pl.error.domain("stream_option", property, atom.indicator));
                return;
              }
              obj_options[property.id] = property.args[0].id;
              pointer = pointer.args[1];
            }
            if (pointer.indicator !== "[]/0") {
              if (pl.type.is_variable(pointer))
                thread.throw_error(pl.error.instantiation(atom.indicator));
              else
                thread.throw_error(pl.error.type("list", options2, atom.indicator));
              return;
            } else {
              var alias = obj_options["alias"];
              if (alias && thread.get_stream_by_alias(alias)) {
                thread.throw_error(pl.error.permission("open", "source_sink", new Term("alias", [new Term(alias, [])]), atom.indicator));
                return;
              }
              if (!obj_options["type"])
                obj_options["type"] = "text";
              var file;
              if (pl.type.is_atom(dest))
                file = thread.file_system_open(dest.id, obj_options["type"], mode.id);
              else
                file = dest.stream(obj_options["type"], mode.id);
              if (file === false) {
                thread.throw_error(pl.error.permission("open", "source_sink", dest, atom.indicator));
                return;
              } else if (file === null) {
                thread.throw_error(pl.error.existence("source_sink", dest, atom.indicator));
                return;
              }
              var newstream = new Stream(file, mode.id, obj_options["alias"], obj_options["type"], obj_options["reposition"] === "true", obj_options["eof_action"]);
              if (alias)
                thread.session.streams[alias] = newstream;
              else
                thread.session.streams[newstream.id] = newstream;
              thread.prepend([new State(point.goal.replace(new Term("=", [stream, newstream])), point.substitution, point)]);
            }
          }
        },
        "close/1": function(thread, point, atom) {
          var stream = atom.args[0];
          thread.prepend([new State(point.goal.replace(new Term("close", [stream, new Term("[]", [])])), point.substitution, point)]);
        },
        "close/2": function(thread, point, atom) {
          var stream = atom.args[0], options2 = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(options2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_list(options2)) {
            thread.throw_error(pl.error.type("list", options2, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else {
            var obj_options = {};
            var pointer = options2;
            var property;
            while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
              property = pointer.args[0];
              if (pl.type.is_variable(property)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_close_option(property)) {
                thread.throw_error(pl.error.domain("close_option", property, atom.indicator));
                return;
              }
              obj_options[property.id] = property.args[0].id === "true";
              pointer = pointer.args[1];
            }
            if (pointer.indicator !== "[]/0") {
              if (pl.type.is_variable(pointer))
                thread.throw_error(pl.error.instantiation(atom.indicator));
              else
                thread.throw_error(pl.error.type("list", options2, atom.indicator));
              return;
            } else {
              if (stream2 === thread.session.standard_input || stream2 === thread.session.standard_output || stream2 === thread.session.standard_error) {
                thread.success(point);
                return;
              } else if (stream2 === thread.session.current_input) {
                thread.session.current_input = thread.session.standard_input;
              } else if (stream2 === thread.session.current_output) {
                thread.session.current_output = thread.session.standard_output;
              }
              if (stream2.alias !== null && stream2.alias !== void 0)
                delete thread.session.streams[stream2.alias];
              else
                delete thread.session.streams[stream2.id];
              if (stream2.output)
                stream2.stream.flush();
              var closed = stream2.stream.close();
              stream2.stream = null;
              if (obj_options.force === true || closed === true) {
                thread.success(point);
              }
            }
          }
        },
        "flush_output/0": [
          new Rule(new Term("flush_output", []), new Term(",", [new Term("current_output", [new Var("S")]), new Term("flush_output", [new Var("S")])]))
        ],
        "flush_output/1": function(thread, point, atom) {
          var stream = atom.args[0];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.input === true) {
            thread.throw_error(pl.error.permission("output", "stream", stream, atom.indicator));
          } else {
            stream2.stream.flush();
            thread.success(point);
          }
        },
        "stream_property/2": function(thread, point, atom) {
          var stream = atom.args[0], property = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (!pl.type.is_variable(stream) && !pl.type.is_stream(stream)) {
            thread.throw_error(pl.error.domain("stream", stream, atom.indicator));
          } else if (!pl.type.is_variable(stream) && (!pl.type.is_stream(stream2) || stream2.stream === null)) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (!pl.type.is_variable(property) && !pl.type.is_stream_property(property)) {
            thread.throw_error(pl.error.domain("stream_property", property, atom.indicator));
          } else {
            var streams = [];
            var states = [];
            var propvar = pl.type.is_variable(property);
            if (!pl.type.is_variable(stream))
              streams.push(stream2);
            else
              for (var key in thread.session.streams)
                streams.push(thread.session.streams[key]);
            for (var i2 = 0; i2 < streams.length; i2++) {
              var properties = [];
              if ((propvar || property.indicator === "file_name/1") && streams[i2].filename)
                properties.push(new Term("file_name", [new Term(streams[i2].file_name, [])]));
              if (propvar || property.indicator === "mode/1")
                properties.push(new Term("mode", [new Term(streams[i2].mode, [])]));
              if (propvar || property.indicator === "input/0" || property.indicator === "output/0")
                properties.push(new Term(streams[i2].input ? "input" : "output", []));
              if ((propvar || property.indicator === "alias/1") && streams[i2].alias)
                properties.push(new Term("alias", [new Term(streams[i2].alias, [])]));
              if (propvar || property.indicator === "position/1")
                properties.push(new Term("position", [
                  new Term("position", [
                    new Num(streams[i2].char_count, false),
                    new Num(streams[i2].line_count, false),
                    new Num(streams[i2].line_position, false)
                  ])
                ]));
              if (propvar || property.indicator === "end_of_stream/1")
                properties.push(new Term("end_of_stream", [new Term(streams[i2].position === "end_of_stream" || streams[i2].stream.eof && streams[i2].stream.eof(streams[i2].position) ? "at" : streams[i2].position === "past_end_of_stream" ? "past" : "not", [])]));
              if (propvar || property.indicator === "eof_action/1")
                properties.push(new Term("eof_action", [new Term(streams[i2].eof_action, [])]));
              if (propvar || property.indicator === "reposition/1")
                properties.push(new Term("reposition", [new Term(streams[i2].reposition ? "true" : "false", [])]));
              if (propvar || property.indicator === "type/1")
                properties.push(new Term("type", [new Term(streams[i2].type, [])]));
              for (var j = 0; j < properties.length; j++) {
                states.push(new State(point.goal.replace(new Term(",", [
                  new Term("=", [pl.type.is_variable(stream) ? stream : stream2, streams[i2]]),
                  new Term("=", [property, properties[j]])
                ])), point.substitution, point));
              }
            }
            thread.prepend(states);
          }
        },
        "stream_position_data/3": function(thread, point, atom) {
          var field = atom.args[0], position = atom.args[1], value = atom.args[2];
          if (pl.type.is_variable(position)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_term(position) || position.indicator !== "position/3") {
            thread.throw_error(pl.error.domain("stream_position", position, atom.indicator));
          } else if (!pl.type.is_variable(field) && !pl.type.is_atom(field)) {
            thread.throw_error(pl.error.type("atom", field, atom.indicator));
          } else if (!pl.type.is_variable(value) && !pl.type.is_integer(value)) {
            thread.throw_error(pl.error.type("integer", value, atom.indicator));
          } else {
            var fields = ["char_count", "line_count", "line_position"];
            var states = [];
            var data_pos = { char_count: 0, line_count: 1, line_position: 2 };
            if (pl.type.is_variable(field)) {
              for (var i2 = 0; i2 < fields.length; i2++) {
                states.push(new State(point.goal.replace(new Term(",", [
                  new Term("=", [new Term(fields[i2]), field]),
                  new Term("=", [value, position.args[data_pos[fields[i2]]]])
                ])), point.substitution, point));
              }
            } else if (data_pos.hasOwnProperty(field.id)) {
              states.push(new State(point.goal.replace(new Term("=", [value, position.args[data_pos[field.id]]])), point.substitution, point));
            }
            thread.prepend(states);
          }
        },
        "at_end_of_stream/0": [
          new Rule(new Term("at_end_of_stream", []), new pl.type.Term(",", [new Term("current_input", [new Var("S")]), new Term(",", [new Term("stream_property", [new Var("S"), new Term("end_of_stream", [new Var("E")])]), new Term(",", [new Term("!", []), new Term(";", [new Term("=", [new Var("E"), new Term("at", [])]), new Term("=", [new Var("E"), new Term("past", [])])])])])]))
        ],
        "at_end_of_stream/1": function(thread, point, atom) {
          var stream = atom.args[0];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else {
            var e = thread.next_free_variable();
            thread.prepend([new State(point.goal.replace(new Term(",", [
              new Term("stream_property", [stream2, new Term("end_of_stream", [e])]),
              new Term(",", [new Term("!", []), new Term(";", [
                new Term("=", [e, new Term("at", [])]),
                new Term("=", [e, new Term("past", [])])
              ])])
            ])), point.substitution, point)]);
          }
        },
        "set_stream_position/2": function(thread, point, atom) {
          var stream = atom.args[0], position = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(position)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (!pl.type.is_stream_position(position)) {
            thread.throw_error(pl.error.domain("stream_position", position, atom.indicator));
          } else if (stream2.reposition === false) {
            thread.throw_error(pl.error.permission("reposition", "stream", stream, atom.indicator));
          } else {
            if (position.indicator === "position/3") {
              stream2.position = position.args[0].value;
              stream2.char_count = position.args[0].value;
              stream2.line_count = position.args[1].value;
              stream2.line_position = position.args[2].value;
            } else {
              stream2.position = position.id;
            }
            thread.success(point);
          }
        },
        "get_char/1": [
          new Rule(new Term("get_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("get_char", [new Var("S"), new Var("C")])]))
        ],
        "get_char/2": function(thread, point, atom) {
          var stream = atom.args[0], char = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(char) && !pl.type.is_in_character(char)) {
            thread.throw_error(pl.error.type("in_character", char, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("input", "binary_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var stream_char;
            if (stream2.position === "end_of_stream") {
              stream_char = "end_of_file";
              stream2.position = "past_end_of_stream";
            } else {
              stream_char = stream2.stream.get(1, stream2.position);
              if (stream_char === null) {
                thread.throw_error(pl.error.representation("character", atom.indicator));
                return;
              } else if (stream_char === "end_of_stream") {
                stream_char = "end_of_file";
                stream2.position = "past_end_of_stream";
              } else {
                stream2.position++;
                stream2.char_count++;
                stream2.line_position++;
                if (stream_char === "\n") {
                  stream2.line_count++;
                  stream2.line_position = 0;
                }
              }
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [new Term(stream_char, []), char])), point.substitution, point)]);
          }
        },
        "get_code/1": [
          new Rule(new Term("get_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("get_code", [new Var("S"), new Var("C")])]))
        ],
        "get_code/2": function(thread, point, atom) {
          var stream = atom.args[0], code = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(code) && !pl.type.is_integer(code)) {
            thread.throw_error(pl.error.type("integer", code, atom.indicator));
          } else if (pl.type.is_integer(code) && !pl.type.is_in_character_code(code)) {
            thread.throw_error(pl.error.representation("in_character_code", atom.indicator));
          } else if (!pl.type.is_variable(stream) && !pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("input", "binary_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var stream_code;
            if (stream2.position === "end_of_stream") {
              stream_code = -1;
              stream2.position = "past_end_of_stream";
            } else {
              stream_code = stream2.stream.get(1, stream2.position);
              if (stream_code === null) {
                thread.throw_error(pl.error.representation("character", atom.indicator));
                return;
              } else if (stream_code === "end_of_stream") {
                stream_code = -1;
                stream2.position = "past_end_of_stream";
              } else {
                stream_code = codePointAt(stream_code, 0);
                stream2.position++;
                stream2.char_count++;
                stream2.line_position++;
                if (stream_code === 10) {
                  stream2.line_count++;
                  stream2.line_position = 0;
                }
              }
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [new Num(stream_code, false), code])), point.substitution, point)]);
          }
        },
        "peek_char/1": [
          new Rule(new Term("peek_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("peek_char", [new Var("S"), new Var("C")])]))
        ],
        "peek_char/2": function(thread, point, atom) {
          var stream = atom.args[0], char = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(char) && !pl.type.is_in_character(char)) {
            thread.throw_error(pl.error.type("in_character", char, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("input", "binary_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var stream_char;
            if (stream2.position === "end_of_stream") {
              stream_char = "end_of_file";
              stream2.position = "past_end_of_stream";
            } else {
              stream_char = stream2.stream.get(1, stream2.position);
              if (stream_char === null) {
                thread.throw_error(pl.error.representation("character", atom.indicator));
                return;
              } else if (stream_char === "end_of_stream") {
                stream_char = "end_of_file";
              }
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [new Term(stream_char, []), char])), point.substitution, point)]);
          }
        },
        "peek_code/1": [
          new Rule(new Term("peek_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("peek_code", [new Var("S"), new Var("C")])]))
        ],
        "peek_code/2": function(thread, point, atom) {
          var stream = atom.args[0], code = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(code) && !pl.type.is_integer(code)) {
            thread.throw_error(pl.error.type("integer", code, atom.indicator));
          } else if (pl.type.is_integer(code) && !pl.type.is_in_character_code(code)) {
            thread.throw_error(pl.error.representation("in_character_code", atom.indicator));
          } else if (!pl.type.is_variable(stream) && !pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("input", "binary_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var stream_code;
            if (stream2.position === "end_of_stream") {
              stream_code = -1;
              stream2.position = "past_end_of_stream";
            } else {
              stream_code = stream2.stream.get(1, stream2.position);
              if (stream_code === null) {
                thread.throw_error(pl.error.representation("character", atom.indicator));
                return;
              } else if (stream_code === "end_of_stream") {
                stream_code = -1;
              } else {
                stream_code = codePointAt(stream_code, 0);
              }
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [new Num(stream_code, false), code])), point.substitution, point)]);
          }
        },
        "put_char/1": [
          new Rule(new Term("put_char", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("put_char", [new Var("S"), new Var("C")])]))
        ],
        "put_char/2": function(thread, point, atom) {
          var stream = atom.args[0], char = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(char)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_character(char)) {
            thread.throw_error(pl.error.type("character", char, atom.indicator));
          } else if (!pl.type.is_variable(stream) && !pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.input) {
            thread.throw_error(pl.error.permission("output", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("output", "binary_stream", stream, atom.indicator));
          } else {
            if (stream2.stream.put(char.id, stream2.position)) {
              if (typeof stream2.position === "number")
                stream2.position++;
              stream2.char_count++;
              stream2.line_position++;
              if (char.id === "\n") {
                stream2.line_count++;
                stream2.line_position = 0;
              }
              thread.success(point);
            }
          }
        },
        "put_code/1": [
          new Rule(new Term("put_code", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("put_code", [new Var("S"), new Var("C")])]))
        ],
        "put_code/2": function(thread, point, atom) {
          var stream = atom.args[0], code = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(code)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_integer(code)) {
            thread.throw_error(pl.error.type("integer", code, atom.indicator));
          } else if (!pl.type.is_character_code(code)) {
            thread.throw_error(pl.error.representation("character_code", atom.indicator));
          } else if (!pl.type.is_variable(stream) && !pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.input) {
            thread.throw_error(pl.error.permission("output", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("output", "binary_stream", stream, atom.indicator));
          } else {
            if (stream2.stream.put(fromCodePoint(code.value), stream2.position)) {
              if (typeof stream2.position === "number")
                stream2.position++;
              stream2.char_count++;
              stream2.line_position++;
              if (code.value === 10) {
                stream2.line_count++;
                stream2.line_position = 0;
              }
              thread.success(point);
            }
          }
        },
        "nl/0": [
          new Rule(new Term("nl"), new Term(",", [new Term("current_output", [new Var("S")]), new Term("put_char", [new Var("S"), new Term("\n")])]))
        ],
        "nl/1": function(thread, point, atom) {
          var stream = atom.args[0];
          thread.prepend([new State(point.goal.replace(new Term("put_char", [stream, new Term("\n", [])])), point.substitution, point)]);
        },
        "get_byte/1": [
          new Rule(new Term("get_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("get_byte", [new Var("S"), new Var("B")])]))
        ],
        "get_byte/2": function(thread, point, atom) {
          var stream = atom.args[0], byte = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(byte) && !pl.type.is_in_byte(byte)) {
            thread.throw_error(pl.error.type("in_byte", byte, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "text") {
            thread.throw_error(pl.error.permission("input", "text_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var stream_byte;
            if (stream2.position === "end_of_stream") {
              stream_byte = -1;
              stream2.position = "past_end_of_stream";
            } else {
              stream_byte = stream2.stream.get_byte(stream2.position);
              if (stream_byte === null) {
                thread.throw_error(pl.error.representation("byte", atom.indicator));
                return;
              } else if (stream_byte === "end_of_stream") {
                stream_byte = -1;
                stream2.position = "past_end_of_stream";
              } else {
                stream2.position++;
                stream2.char_count++;
                stream2.line_position++;
              }
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [new Num(stream_byte, false), byte])), point.substitution, point)]);
          }
        },
        "peek_byte/1": [
          new Rule(new Term("peek_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("peek_byte", [new Var("S"), new Var("B")])]))
        ],
        "peek_byte/2": function(thread, point, atom) {
          var stream = atom.args[0], byte = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(byte) && !pl.type.is_in_byte(byte)) {
            thread.throw_error(pl.error.type("in_byte", byte, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "text") {
            thread.throw_error(pl.error.permission("input", "text_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var stream_byte;
            if (stream2.position === "end_of_stream") {
              stream_byte = -1;
              stream2.position = "past_end_of_stream";
            } else {
              stream_byte = stream2.stream.get_byte(stream2.position);
              if (stream_byte === null) {
                thread.throw_error(pl.error.representation("byte", atom.indicator));
                return;
              } else if (stream_byte === "end_of_stream") {
                stream_byte = -1;
              }
            }
            thread.prepend([new State(point.goal.replace(new Term("=", [new Num(stream_byte, false), byte])), point.substitution, point)]);
          }
        },
        "put_byte/1": [
          new Rule(new Term("put_byte", [new Var("B")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("put_byte", [new Var("S"), new Var("B")])]))
        ],
        "put_byte/2": function(thread, point, atom) {
          var stream = atom.args[0], byte = atom.args[1];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(byte)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_byte(byte)) {
            thread.throw_error(pl.error.type("byte", byte, atom.indicator));
          } else if (!pl.type.is_variable(stream) && !pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.input) {
            thread.throw_error(pl.error.permission("output", "stream", stream, atom.indicator));
          } else if (stream2.type === "text") {
            thread.throw_error(pl.error.permission("output", "text_stream", stream, atom.indicator));
          } else {
            if (stream2.stream.put_byte(byte.value, stream2.position)) {
              if (typeof stream2.position === "number")
                stream2.position++;
              stream2.char_count++;
              stream2.line_position++;
              thread.success(point);
            }
          }
        },
        "read/1": [
          new Rule(new Term("read", [new Var("T")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("read_term", [new Var("S"), new Var("T"), new Term("[]")])]))
        ],
        "read/2": [
          new Rule(new Term("read", [new Var("S"), new Var("T")]), new Term("read_term", [new Var("S"), new Var("T"), new Term("[]")]))
        ],
        "read_term/2": [
          new Rule(new Term("read_term", [new Var("T"), new Var("O")]), new Term(",", [new Term("current_input", [new Var("S")]), new Term("read_term", [new Var("S"), new Var("T"), new Var("O")])]))
        ],
        "read_term/3": function(thread, point, atom) {
          var stream = atom.args[0], term = atom.args[1], options2 = atom.args[2];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(options2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_list(options2)) {
            thread.throw_error(pl.error.type("list", options2, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.output) {
            thread.throw_error(pl.error.permission("input", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("input", "binary_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("input", "past_end_of_stream", stream, atom.indicator));
          } else {
            var obj_options = {};
            var pointer = options2;
            var property;
            while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
              property = pointer.args[0];
              if (pl.type.is_variable(property)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_read_option(property)) {
                thread.throw_error(pl.error.domain("read_option", property, atom.indicator));
                return;
              }
              obj_options[property.id] = property.args[0];
              pointer = pointer.args[1];
            }
            if (pointer.indicator !== "[]/0") {
              if (pl.type.is_variable(pointer))
                thread.throw_error(pl.error.instantiation(atom.indicator));
              else
                thread.throw_error(pl.error.type("list", options2, atom.indicator));
              return;
            } else {
              var char, tokenizer, expr;
              var text2 = "";
              var tokens = [];
              var last_token = null;
              var lexical_error = false;
              while (last_token === null || lexical_error || last_token.name !== "atom" || last_token.value !== "." || tokens.length > 0 && expr.type === ERROR) {
                char = stream2.stream.get(1, stream2.position);
                while (char !== null && char !== "." && char !== "end_of_stream" && char !== "past_end_of_stream") {
                  stream2.position++;
                  text2 += char;
                  char = stream2.stream.get(1, stream2.position);
                }
                if (char === null) {
                  thread.throw_error(pl.error.representation("character", atom.indicator));
                  return;
                } else if (char === "end_of_stream" || char === "past_end_of_stream") {
                  if (tokens === null || tokens.length === 0) {
                    stream2.position = "past_end_of_stream";
                    expr = {
                      value: new Term("end_of_file", []),
                      type: SUCCESS,
                      len: -1
                    };
                    break;
                  } else if (expr) {
                    thread.throw_error(pl.error.syntax(last_token, "unexpected end of file", false));
                    return;
                  } else {
                    thread.throw_error(pl.error.syntax(last_token, "token not found", true));
                    return;
                  }
                } else if (char === ".") {
                  stream2.position++;
                  text2 += char;
                }
                tokenizer = new Tokenizer(thread);
                tokenizer.new_text(text2);
                tokens = tokenizer.get_tokens();
                num_token = tokens !== null && tokens.length > 1 ? tokens[tokens.length - 2] : null;
                last_token = tokens !== null && tokens.length > 0 ? tokens[tokens.length - 1] : null;
                if (tokens === null)
                  continue;
                lexical_error = false;
                for (var i2 = 0; i2 < tokens.length && !lexical_error; i2++)
                  lexical_error = tokens[i2].name === "lexical";
                if (lexical_error)
                  continue;
                expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
                if (num_token && num_token.name === "number" && !num_token.float && !num_token.blank && last_token.value === ".") {
                  var next_char = stream2.stream.get(1, stream2.position);
                  if (next_char >= "0" && next_char <= "9") {
                    stream2.position++;
                    text2 += next_char;
                    last_token = null;
                    continue;
                  }
                }
              }
              if (last_token) {
                if (last_token.line_position === last_token.len)
                  stream2.line_position += last_token.line_position;
                else
                  stream2.line_position = last_token.line_position;
                stream2.line_count += last_token.line_count;
                stream2.char_count += last_token.len;
              }
              if (expr.type === SUCCESS && (expr.len === -1 || expr.len === tokens.length - 1 && last_token.value === ".")) {
                thread.session.renamed_variables = {};
                expr = expr.value.rename(thread);
                var eq = new Term("=", [term, expr]);
                if (obj_options.variables) {
                  var vars = arrayToList(map(nub(expr.variables()), function(v2) {
                    return new Var(v2);
                  }));
                  eq = new Term(",", [eq, new Term("=", [obj_options.variables, vars])]);
                }
                if (obj_options.variable_names) {
                  var vars = nub(expr.variables());
                  var plvars = [];
                  for (var i2 = 0; i2 < vars.length; i2++) {
                    var v = vars[i2];
                    for (var prop in thread.session.renamed_variables) {
                      if (thread.session.renamed_variables.hasOwnProperty(prop)) {
                        if (thread.session.renamed_variables[prop] === v) {
                          plvars.push(new Term("=", [new Term(prop, []), new Var(v)]));
                          break;
                        }
                      }
                    }
                  }
                  plvars = arrayToList(plvars);
                  eq = new Term(",", [eq, new Term("=", [obj_options.variable_names, plvars])]);
                }
                if (obj_options.singletons) {
                  var vars = nub(new Rule(expr, null).singleton_variables(true));
                  var plvars = [];
                  for (var i2 = 0; i2 < vars.length; i2++) {
                    var v = vars[i2];
                    for (var prop in thread.session.renamed_variables) {
                      if (thread.session.renamed_variables.hasOwnProperty(prop)) {
                        if (thread.session.renamed_variables[prop] === v) {
                          plvars.push(new Term("=", [new Term(prop, []), new Var(v)]));
                          break;
                        }
                      }
                    }
                  }
                  plvars = arrayToList(plvars);
                  eq = new Term(",", [eq, new Term("=", [obj_options.singletons, plvars])]);
                }
                thread.prepend([new State(point.goal.replace(eq), point.substitution, point)]);
              } else {
                if (expr.type === SUCCESS)
                  thread.throw_error(pl.error.syntax(tokens[expr.len], "unexpected token", false));
                else
                  thread.throw_error(expr.value);
              }
            }
          }
        },
        "write/1": [
          new Rule(new Term("write", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("write", [new Var("S"), new Var("T")])]))
        ],
        "write/2": function(thread, point, atom) {
          var stream = atom.args[0], term = atom.args[1];
          thread.prepend([new State(point.goal.replace(new Term("write_term", [
            stream,
            term,
            new Term(".", [
              new Term("quoted", [new Term("false", [])]),
              new Term(".", [
                new Term("ignore_ops", [new Term("false")]),
                new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]", [])])
              ])
            ])
          ])), point.substitution, point)]);
        },
        "writeq/1": [
          new Rule(new Term("writeq", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("writeq", [new Var("S"), new Var("T")])]))
        ],
        "writeq/2": function(thread, point, atom) {
          var stream = atom.args[0], term = atom.args[1];
          thread.prepend([new State(point.goal.replace(new Term("write_term", [
            stream,
            term,
            new Term(".", [
              new Term("quoted", [new Term("true", [])]),
              new Term(".", [
                new Term("ignore_ops", [new Term("false")]),
                new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]", [])])
              ])
            ])
          ])), point.substitution, point)]);
        },
        "write_canonical/1": [
          new Rule(new Term("write_canonical", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("write_canonical", [new Var("S"), new Var("T")])]))
        ],
        "write_canonical/2": function(thread, point, atom) {
          var stream = atom.args[0], term = atom.args[1];
          thread.prepend([new State(point.goal.replace(new Term("write_term", [
            stream,
            term,
            new Term(".", [
              new Term("quoted", [new Term("true", [])]),
              new Term(".", [
                new Term("ignore_ops", [new Term("true")]),
                new Term(".", [new Term("numbervars", [new Term("false")]), new Term("[]", [])])
              ])
            ])
          ])), point.substitution, point)]);
        },
        "write_term/2": [
          new Rule(new Term("write_term", [new Var("T"), new Var("O")]), new Term(",", [new Term("current_output", [new Var("S")]), new Term("write_term", [new Var("S"), new Var("T"), new Var("O")])]))
        ],
        "write_term/3": function(thread, point, atom) {
          var stream = atom.args[0], term = atom.args[1], options2 = atom.args[2];
          var stream2 = pl.type.is_stream(stream) ? stream : thread.get_stream_by_alias(stream.id);
          if (pl.type.is_variable(stream) || pl.type.is_variable(options2)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_list(options2)) {
            thread.throw_error(pl.error.type("list", options2, atom.indicator));
          } else if (!pl.type.is_stream(stream) && !pl.type.is_atom(stream)) {
            thread.throw_error(pl.error.domain("stream_or_alias", stream, atom.indicator));
          } else if (!pl.type.is_stream(stream2) || stream2.stream === null) {
            thread.throw_error(pl.error.existence("stream", stream, atom.indicator));
          } else if (stream2.input) {
            thread.throw_error(pl.error.permission("output", "stream", stream, atom.indicator));
          } else if (stream2.type === "binary") {
            thread.throw_error(pl.error.permission("output", "binary_stream", stream, atom.indicator));
          } else if (stream2.position === "past_end_of_stream" && stream2.eof_action === "error") {
            thread.throw_error(pl.error.permission("output", "past_end_of_stream", stream, atom.indicator));
          } else {
            var obj_options = {};
            var pointer = options2;
            var property;
            while (pl.type.is_term(pointer) && pointer.indicator === "./2") {
              property = pointer.args[0];
              if (pl.type.is_variable(property)) {
                thread.throw_error(pl.error.instantiation(atom.indicator));
                return;
              } else if (!pl.type.is_write_option(property)) {
                thread.throw_error(pl.error.domain("write_option", property, atom.indicator));
                return;
              }
              if (property.indicator === "variable_names/1")
                obj_options[property.id] = property.args[0];
              else
                obj_options[property.id] = property.args[0].id === "true";
              pointer = pointer.args[1];
            }
            if (pointer.indicator !== "[]/0") {
              if (pl.type.is_variable(pointer))
                thread.throw_error(pl.error.instantiation(atom.indicator));
              else
                thread.throw_error(pl.error.type("list", options2, atom.indicator));
              return;
            } else {
              obj_options.session = thread.session;
              var text2 = term.toString(obj_options);
              stream2.stream.put(text2, stream2.position);
              if (typeof stream2.position === "number")
                stream2.position += text2.length;
              var nl = (text2.match(/\n/g) || []).length;
              stream2.line_count += nl;
              if (nl > 0)
                stream2.line_position = text2.length - text2.lastIndexOf("\n") - 1;
              else
                stream2.line_position += text2.length;
              stream2.char_count += text2.length;
              thread.success(point);
            }
          }
        },
        "halt/0": function(thread, point, _) {
          if (thread.get_flag("nodejs").indicator === "true/0")
            process.exit();
          thread.points = [];
        },
        "halt/1": function(thread, point, atom) {
          var int = atom.args[0];
          if (pl.type.is_variable(int)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_integer(int)) {
            thread.throw_error(pl.error.type("integer", int, atom.indicator));
          } else {
            if (thread.get_flag("nodejs").indicator === "true/0")
              process.exit(int.value);
            thread.points = [];
          }
        },
        "current_prolog_flag/2": function(thread, point, atom) {
          var flag = atom.args[0], value = atom.args[1];
          if (!pl.type.is_variable(flag) && !pl.type.is_atom(flag)) {
            thread.throw_error(pl.error.type("atom", flag, atom.indicator));
          } else if (!pl.type.is_variable(flag) && !pl.type.is_flag(flag)) {
            thread.throw_error(pl.error.domain("prolog_flag", flag, atom.indicator));
          } else {
            var states = [];
            for (var name in pl.flag) {
              if (!pl.flag.hasOwnProperty(name))
                continue;
              var goal = new Term(",", [new Term("=", [new Term(name), flag]), new Term("=", [thread.get_flag(name), value])]);
              states.push(new State(point.goal.replace(goal), point.substitution, point));
            }
            thread.prepend(states);
          }
        },
        "set_prolog_flag/2": function(thread, point, atom) {
          var flag = atom.args[0], value = atom.args[1];
          if (pl.type.is_variable(flag) || pl.type.is_variable(value)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atom(flag)) {
            thread.throw_error(pl.error.type("atom", flag, atom.indicator));
          } else if (!pl.type.is_flag(flag)) {
            thread.throw_error(pl.error.domain("prolog_flag", flag, atom.indicator));
          } else if (!pl.type.is_modifiable_flag(flag)) {
            thread.throw_error(pl.error.permission("modify", "flag", flag, atom.indicator));
          } else if (!pl.type.is_value_flag(flag, value)) {
            thread.throw_error(pl.error.domain("flag_value", new Term("+", [flag, value]), atom.indicator));
          } else {
            thread.session.flag[flag.id] = value;
            thread.success(point);
          }
        },
        "consult/1": function(thread, point, atom) {
          var src = atom.args[0];
          var context_module = "user";
          if (src.indicator === ":/2") {
            context_module = src.args[0].id;
            src = src.args[1];
          }
          if (pl.type.is_variable(src)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_atom(src)) {
            thread.throw_error(pl.error.type("atom", src, atom.indicator));
          } else {
            if (thread.consult(src.id, {
              context_module,
              text: false,
              html: false,
              success: function() {
                thread.success(point);
                thread.again();
              },
              error: function(err) {
                thread.throw_error(err);
                thread.again();
              }
            }))
              ;
            return true;
          }
        },
        "get_time/1": function(thread, point, atom) {
          var time = atom.args[0];
          if (!pl.type.is_variable(time) && !pl.type.is_number(time)) {
            thread.throw_error(pl.error.type("number", time, atom.indicator));
          } else {
            var current = new Num(Date.now(), true);
            thread.prepend([new State(point.goal.replace(new Term("=", [time, current])), point.substitution, point)]);
          }
        },
        "time_property/2": function(thread, point, atom) {
          var time = atom.args[0], property = atom.args[1];
          if (pl.type.is_variable(time)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_variable(time) && !pl.type.is_number(time)) {
            thread.throw_error(pl.error.type("number", time, atom.indicator));
          } else if (!pl.type.is_variable(property) && !pl.type.is_time_property(property)) {
            thread.throw_error(pl.error.domain("time_property", property, atom.indicator));
          } else {
            var props;
            if (pl.type.is_variable(property)) {
              props = ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"];
            } else {
              props = [property.id];
            }
            var date = new Date(time.value);
            var value;
            var states = [];
            for (var i2 = 0; i2 < props.length; i2++) {
              switch (props[i2]) {
                case "year":
                  value = new Term("year", [new Num(date.getFullYear(), false)]);
                  break;
                case "month":
                  value = new Term("month", [new Num(date.getMonth(), false)]);
                  break;
                case "day":
                  value = new Term("day", [new Num(date.getDate(), false)]);
                  break;
                case "hours":
                  value = new Term("hours", [new Num(date.getHours(), false)]);
                  break;
                case "minutes":
                  value = new Term("minutes", [new Num(date.getMinutes(), false)]);
                  break;
                case "seconds":
                  value = new Term("seconds", [new Num(date.getSeconds(), false)]);
                  break;
                case "milliseconds":
                  value = new Term("milliseconds", [new Num(date.getMilliseconds(), false)]);
                  break;
                case "weekday":
                  value = new Term("weekday", [new Num(date.getDay(), false)]);
                  break;
              }
              states.push(new State(point.goal.replace(new Term("=", [property, value])), point.substitution, point));
            }
            thread.prepend(states);
          }
        },
        "time_year/2": function(thread, point, atom) {
          var time = atom.args[0], year = atom.args[1];
          if (pl.type.is_variable(time)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_number(time)) {
            thread.throw_error(pl.error.type("number", time, atom.indicator));
          } else if (!pl.type.is_variable(year) && !pl.type.is_integer(year)) {
            thread.throw_error(pl.error.type("integer", year, atom.indicator));
          } else {
            var value = new Num(new Date(time.value).getFullYear(), false);
            thread.prepend([new State(point.goal.replace(new Term("=", [year, value])), point.substitution, point)]);
          }
        },
        "time_month/2": function(thread, point, atom) {
          var time = atom.args[0], month = atom.args[1];
          if (pl.type.is_variable(time)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_number(time)) {
            thread.throw_error(pl.error.type("number", time, atom.indicator));
          } else if (!pl.type.is_variable(month) && !pl.type.is_integer(month)) {
            thread.throw_error(pl.error.type("integer", month, atom.indicator));
          } else {
            var value = new Num(new Date(time.value).getMonth(), false);
            thread.prepend([new State(point.goal.replace(new Term("=", [month, value])), point.substitution, point)]);
          }
        },
        "phrase/3": function(thread, point, atom) {
          var grbody = atom.args[0], s0 = atom.args[1], s2 = atom.args[2];
          var context_module = "user";
          if (grbody.indicator === ":/2") {
            context_module = grbody.args[0].id;
            grbody = grbody.args[1];
          }
          if (pl.type.is_variable(grbody)) {
            thread.throw_error(pl.error.instantiation(atom.indicator));
          } else if (!pl.type.is_callable(grbody)) {
            thread.throw_error(pl.error.type("callable", grbody, atom.indicator));
          } else {
            var goal = body_to_dcg(grbody.clone(), s0, thread);
            goal.value = new Term(":", [new Term(context_module), new Term("call", [goal.value])]);
            if (goal !== null) {
              thread.prepend([new State(point.goal.replace(new Term(",", [goal.value, new Term("=", [goal.variable, s2])])), point.substitution, point)]);
            }
          }
        },
        "phrase/2": function(thread, point, atom) {
          var grbody = atom.args[0], s0 = atom.args[1];
          thread.prepend([new State(point.goal.replace(new Term("phrase", [grbody, s0, new Term("[]", [])])), point.substitution, point)]);
        },
        "version/0": function(thread, point, atom) {
          var msg = "Welcome to Tau Prolog version " + version.major + "." + version.minor + "." + version.patch + "\n";
          msg += "Tau Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\n";
          msg += "Please run ?- license. for legal details.\n";
          msg += "For online help and background, visit http:/tau-prolog.org";
          thread.prepend([new State(point.goal.replace(new Term("write", [new Term(msg, [])])), point.substitution, point)]);
        },
        "license/0": function(thread, point, atom) {
          var msg = "Tau Prolog. A Prolog interpreter in JavaScript.\n";
          msg += "Copyright (C) 2017 - 2020 Jos\xE9 Antonio Riaza Valverde\n\n";
          msg += "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n";
          msg += "1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n";
          msg += "2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n";
          msg += "3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n";
          msg += 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n';
          msg += "You should have received a copy of the BSD 3-Clause License along with this program. If not, see https://opensource.org/licenses/BSD-3-Clause";
          thread.prepend([new State(point.goal.replace(new Term("write", [new Term(msg, [])])), point.substitution, point)]);
        }
      }, "all", {
        meta_predicates: {
          ";/2": new Term(";", [new Num(0, false), new Num(0, false)]),
          "->/2": new Term("->", [new Num(0, false), new Num(0, false)]),
          "\\+/1": new Term("\\+", [new Num(0, false)]),
          "abolish/1": new Term("abolish", [new Term(":")]),
          "asserta/1": new Term("asserta", [new Term(":")]),
          "assertz/1": new Term("assertz", [new Term(":")]),
          "bagof/3": new Term("bagof", [new Term("?"), new Term("^"), new Term("-")]),
          "call/1": new Term("call", [new Num(0, false)]),
          "call/2": new Term("call", [new Num(1, false), new Term("?")]),
          "call/3": new Term("call", [new Num(2, false), new Term("?"), new Term("?")]),
          "call/4": new Term("call", [new Num(3, false), new Term("?"), new Term("?"), new Term("?")]),
          "call/5": new Term("call", [new Num(4, false), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
          "call/6": new Term("call", [new Num(5, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
          "call/7": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
          "call/8": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
          "call_cleanup/2": new Term("call_cleanup", [new Num(0, false), new Num(0, false)]),
          "catch/3": new Term("catch", [new Num(0, false), new Term("?"), new Num(0, false)]),
          "consult/1": new Term("consult", [new Term(":")]),
          "clause/2": new Term("clause", [new Term(":"), new Term("?")]),
          "current_predicate/2": new Term("current_predicate", [new Term("?"), new Term(":")]),
          "findall/3": new Term("findall", [new Term("?"), new Num(0, false), new Term("-")]),
          "findall/4": new Term("findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
          "forall/2": new Term("forall", [new Num(0, false), new Num(0, false)]),
          "listing/1": new Term("listing", [new Term(":")]),
          "once/1": new Term("once", [new Num(0, false)]),
          "phrase/2": new Term("phrase", [new Term(":"), new Term("?")]),
          "phrase/3": new Term("phrase", [new Term(":"), new Term("?"), new Term("?")]),
          "retract/1": new Term("retract", [new Term(":")]),
          "retractall/1": new Term("retractall", [new Term(":")]),
          "setup_call_cleanup/3": new Term("setup_call_cleanup", [new Num(0, false), new Num(0, false), new Num(0, false)]),
          "setof/3": new Term("setof", [new Term("?"), new Term("^"), new Term("-")])
        }
      });
      if (typeof module2 !== "undefined") {
        module2.exports = pl;
      } else {
        window.pl = pl;
      }
    })();
  }
});

// main.ts
__export(exports, {
  default: () => ExecuteCodePlugin
});
var import_obsidian2 = __toModule(require("obsidian"));
var fs = __toModule(require("fs"));
var os = __toModule(require("os"));
var child_process = __toModule(require("child_process"));

// Outputter.ts
var Outputter = class {
  constructor(codeBlock) {
    this.codeBlockElement = codeBlock;
    this.stdoutText = "";
    this.stderrText = "";
  }
  clear() {
    if (this.outputElement) {
      this.stdoutElem.setText("");
      this.stderrElem.setText("");
    }
    this.stdoutText = "";
    this.stderrText = "";
  }
  delete() {
    if (this.outputElement)
      this.outputElement.style.display = "none";
    if (this.clearButton)
      this.clearButton.style.display = "none";
    this.clear();
  }
  write(text2) {
    if (!this.outputElement) {
      this.addOutputElement();
    }
    if (!this.clearButton) {
      this.addClearButton();
    }
    this.stdoutText += text2;
    if (!this.stderrText && !this.stdoutText)
      return;
    this.stdoutElem.innerHTML = this.stdoutText;
    this.outputElement.style.display = "block";
    this.clearButton.style.display = "block";
  }
  writeErr(text2) {
    if (!this.outputElement) {
      this.addOutputElement();
    }
    if (!this.clearButton) {
      this.addClearButton();
    }
    this.stderrText += text2;
    if (!this.stderrText && !this.stdoutText)
      return;
    this.stderrElem.setText(this.stderrText);
    this.outputElement.style.display = "block";
    this.clearButton.style.display = "block";
  }
  getParentElement() {
    return this.codeBlockElement.parentElement;
  }
  addClearButton() {
    const parentEl = this.getParentElement();
    this.clearButton = document.createElement("button");
    this.clearButton.className = "clear-button";
    this.clearButton.setText("Clear");
    this.clearButton.addEventListener("click", () => this.delete());
    parentEl.appendChild(this.clearButton);
  }
  addOutputElement() {
    const parentEl = this.getParentElement();
    let hr = document.createElement("hr");
    this.outputElement = document.createElement("code");
    this.outputElement.classList.add("language-output");
    this.stdoutElem = document.createElement("span");
    this.stdoutElem.addClass("stdout");
    this.stderrElem = document.createElement("span");
    this.stderrElem.addClass("stderr");
    this.outputElement.appendChild(hr);
    this.outputElement.appendChild(this.stdoutElem);
    this.outputElement.appendChild(this.stderrElem);
    parentEl.appendChild(this.outputElement);
  }
};

// SettingsTab.ts
var import_obsidian = __toModule(require("obsidian"));
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for the Code Execution Plugin." });
    containerEl.createEl("h3", { text: "Timout Settings" });
    new import_obsidian.Setting(containerEl).setName("Timeout (in seconds)").setDesc("The time after which a program gets shut down automatically. This is to prevent infinite loops. ").addText((text2) => text2.setValue("" + this.plugin.settings.timeout / 1e3).onChange((value) => __async(this, null, function* () {
      if (Number(value) * 1e3) {
        console.log("Timeout set to: " + value);
        this.plugin.settings.timeout = Number(value) * 1e3;
      }
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "JavaScript / Node Settings" });
    new import_obsidian.Setting(containerEl).setName("Node path").addText((text2) => text2.setValue(this.plugin.settings.nodePath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.nodePath = value;
      console.log("Node path set to: " + value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Node arguments").addText((text2) => text2.setValue(this.plugin.settings.nodeArgs).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.nodeArgs = value;
      console.log("Node args set to: " + value);
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Python Settings" });
    new import_obsidian.Setting(containerEl).setName("Python path").setDesc("The path to your Python installation.").addText((text2) => text2.setValue(this.plugin.settings.pythonPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pythonPath = value;
      console.log("Python path set to: " + value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Python arguments").addText((text2) => text2.setValue(this.plugin.settings.pythonArgs).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pythonArgs = value;
      console.log("Python args set to: " + value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Embed Python Plots").addToggle((toggle) => toggle.setValue(this.plugin.settings.pythonEmbedPlots).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.pythonEmbedPlots = value;
      console.log(value ? "Embedding Plots into Notes." : "Not embedding Plots into Notes.");
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Shell Settings" });
    new import_obsidian.Setting(containerEl).setName("Shell path").setDesc("The path to shell. Default is Bash but you can use any shell you want, e.g. bash, zsh, fish, ...").addText((text2) => text2.setValue(this.plugin.settings.shellPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shellPath = value;
      console.log("Shell path set to: " + value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Shell arguments").addText((text2) => text2.setValue(this.plugin.settings.shellArgs).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shellArgs = value;
      console.log("Shell args set to: " + value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Shell file extension").setDesc("Changes the file extension for generated shell scripts. This is useful if you want to use a shell other than bash.").addText((text2) => text2.setValue(this.plugin.settings.shellFileExtension).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.shellFileExtension = value;
      console.log("Shell file extension set to: " + value);
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Prolog Settings" });
    new import_obsidian.Setting(containerEl).setName("Prolog Answer Limit").setDesc("Maximal number of answers to be returned by the Prolog engine. This is to prevent creating too huge texts in the notebook.").addText((text2) => text2.setValue("" + this.plugin.settings.maxPrologAnswers).onChange((value) => __async(this, null, function* () {
      if (Number(value) * 1e3) {
        console.log("Answer limit set to: " + value);
        this.plugin.settings.maxPrologAnswers = Number(value);
      }
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h3", { text: "Groovy Settings" });
    new import_obsidian.Setting(containerEl).setName("Groovy path").setDesc("The path to your Groovy installation.").addText((text2) => text2.setValue(this.plugin.settings.groovyPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.groovyPath = value;
      console.log("Groovy path set to: " + value);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Groovy arguments").addText((text2) => text2.setValue(this.plugin.settings.groovyArgs).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.groovyArgs = value;
      console.log("Groovy args set to: " + value);
      yield this.plugin.saveSettings();
    })));
  }
};

// Magic.ts
var SHOW_REGEX = /@show\(["'](?<path>[^<>?*=!\n#()\[\]{}]+)["'](,\s*(?<width>[0-9]+[\w%]+),?\s*(?<height>[0-9]+[\w%]+))?(,\s*(?<align>left|center|right))?\)/g;
var VAULT_REGEX = /@vault/g;
var CURRENT_NOTE_REGEX = /@note/g;
var NOTE_TITLE_REGEX = /@title/g;
function insertVaultPath(source, vaultPath) {
  return source.replace(VAULT_REGEX, `"app://local/${vaultPath.replace(/\\/g, "/")}"`);
}
function insertNotePath(source, notePath) {
  return source.replace(CURRENT_NOTE_REGEX, `"app://local/${notePath.replace(/\\/g, "/")}"`);
}
function insertNoteTitle(source, noteTitle) {
  let t = "";
  if (noteTitle.contains("."))
    t = noteTitle.split(".").slice(0, -1).join(".");
  return source.replace(NOTE_TITLE_REGEX, `"${t}"`);
}
function addInlinePlotsToPython(source) {
  const showPlot = `import io; __obsidian_execute_code_temp_pyplot_var__=io.StringIO(); plt.plot(); plt.savefig(__obsidian_execute_code_temp_pyplot_var__, format='svg'); plt.close(); print(f"<div align=\\"center\\">{__obsidian_execute_code_temp_pyplot_var__.getvalue()}</div>")`;
  return source.replace(/plt\.show\(\)/g, showPlot);
}
function addMagicToPython(source) {
  source = pythonParseShowImage(source);
  return source;
}
function addMagicToJS(source) {
  source = jsParseShowImage(source);
  return source;
}
function pythonParseShowImage(source) {
  const matches = source.matchAll(SHOW_REGEX);
  for (const match of matches) {
    const imagePath = match.groups.path;
    const width = match.groups.width;
    const height = match.groups.height;
    const alignment = match.groups.align;
    const image = buildMagicShowImage(imagePath.replace(/\\/g, "\\\\"), width, height, alignment);
    source = source.replace(match[0], "print('" + image + "')");
    console.log(source);
  }
  return source;
}
function jsParseShowImage(source) {
  const matches = source.matchAll(SHOW_REGEX);
  for (const match of matches) {
    const imagePath = match.groups.path;
    const width = match.groups.width;
    const height = match.groups.height;
    const alignment = match.groups.align;
    const image = buildMagicShowImage(imagePath.replace(/\\/g, "\\\\"), width, height, alignment);
    source = source.replace(match[0], "console.log('" + image + "')");
    console.log(source);
  }
  return source;
}
function buildMagicShowImage(imagePath, width = "0", height = "0", alignment = "center") {
  if (imagePath.contains("+")) {
    let splittedPath = imagePath.replace(/['"]/g, "").split("+");
    splittedPath = splittedPath.map((element) => element.trim());
    imagePath = splittedPath.join("");
  }
  if (width == "0" || height == "0")
    return `<img src="${imagePath}" align="${alignment}">`;
  return `<img src="${imagePath}" width="${width}" height="${height}" align="${alignment}">`;
}

// main.ts
var JSCPP = __toModule(require_commonjs());
var prolog = __toModule(require_core());
var supportedLanguages = ["js", "javascript", "python", "cpp", "prolog", "shell", "bash", "groovy"];
var buttonText = "Run";
var runButtonClass = "run-code-button";
var runButtonDisabledClass = "run-button-disabled";
var hasButtonClass = "has-run-code-button";
var DEFAULT_SETTINGS = {
  timeout: 1e4,
  nodePath: "node",
  nodeArgs: "",
  pythonPath: "python",
  pythonArgs: "",
  pythonEmbedPlots: true,
  shellPath: "bash",
  shellArgs: "",
  shellFileExtension: "sh",
  groovyPath: "groovy",
  groovyArgs: "",
  groovyFileExtension: "groovy",
  maxPrologAnswers: 15
};
var ExecuteCodePlugin = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new SettingsTab(this.app, this));
      this.addRunButtons(document.body);
      this.registerMarkdownPostProcessor((element, _context) => {
        this.addRunButtons(element);
      });
      supportedLanguages.forEach((l) => {
        console.log(`registering renderer for ${l}`);
        this.registerMarkdownCodeBlockProcessor(`run-${l}`, (src, el, _ctx) => __async(this, null, function* () {
          yield import_obsidian2.MarkdownRenderer.renderMarkdown("```" + l + "\n" + src + "\n```", el, "", null);
        }));
      });
    });
  }
  onunload() {
    document.querySelectorAll("pre > code").forEach((codeBlock) => {
      const pre = codeBlock.parentElement;
      const parent = pre.parentElement;
      if (parent.hasClass(hasButtonClass)) {
        parent.removeClass(hasButtonClass);
      }
    });
    document.querySelectorAll("." + runButtonClass).forEach((button) => button.remove());
    document.querySelectorAll("." + runButtonDisabledClass).forEach((button) => button.remove());
    document.querySelectorAll(".clear-button").forEach((button) => button.remove());
    document.querySelectorAll(".language-output").forEach((out) => out.remove());
    console.log("Unloaded plugin: Execute Code");
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  addRunButtons(element) {
    element.querySelectorAll("code").forEach((codeBlock) => {
      const pre = codeBlock.parentElement;
      const parent = pre.parentElement;
      const language = codeBlock.className.toLowerCase();
      let srcCode = codeBlock.getText();
      const vars = this.getVaultVariables();
      srcCode = insertVaultPath(srcCode, vars.vaultPath);
      srcCode = insertNotePath(srcCode, vars.filePath);
      srcCode = insertNoteTitle(srcCode, vars.fileName);
      if (supportedLanguages.some((lang) => language.contains(`language-${lang}`)) && !parent.classList.contains(hasButtonClass)) {
        parent.classList.add(hasButtonClass);
        const button = this.createRunButton();
        pre.appendChild(button);
        const out = new Outputter(codeBlock);
        if (language.contains("language-js") || language.contains("language-javascript")) {
          srcCode = addMagicToJS(srcCode);
          button.addEventListener("click", () => {
            button.className = runButtonDisabledClass;
            this.runCode(srcCode, out, button, this.settings.nodePath, this.settings.nodeArgs, "js");
          });
        } else if (language.contains("language-python")) {
          button.addEventListener("click", () => __async(this, null, function* () {
            button.className = runButtonDisabledClass;
            if (this.settings.pythonEmbedPlots)
              srcCode = addInlinePlotsToPython(srcCode);
            srcCode = addMagicToPython(srcCode);
            this.runCode(srcCode, out, button, this.settings.pythonPath, this.settings.pythonArgs, "py");
          }));
        } else if (language.contains("language-shell") || language.contains("language-bash")) {
          button.addEventListener("click", () => {
            button.className = runButtonDisabledClass;
            this.runCode(srcCode, out, button, this.settings.shellPath, this.settings.shellArgs, this.settings.shellFileExtension);
          });
        } else if (language.contains("language-cpp")) {
          button.addEventListener("click", () => {
            button.className = runButtonDisabledClass;
            out.clear();
            this.runCpp(srcCode, out);
            button.className = runButtonClass;
          });
        } else if (language.contains("language-prolog")) {
          button.addEventListener("click", () => {
            button.className = runButtonDisabledClass;
            out.clear();
            const prologCode = srcCode.split(/\n+%+\s*query\n+/);
            if (prologCode.length < 2)
              return;
            this.runPrologCode(prologCode, out);
            button.className = runButtonClass;
          });
        } else if (language.contains("language-groovy")) {
          button.addEventListener("click", () => {
            button.className = runButtonDisabledClass;
            this.runCode(srcCode, out, button, this.settings.groovyPath, this.settings.groovyArgs, this.settings.groovyFileExtension);
          });
        }
      }
    });
  }
  getVaultVariables() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (activeView == null) {
      return null;
    }
    const adapter = app.vault.adapter;
    const vaultPath = adapter.getBasePath();
    const folder = activeView.file.parent.path;
    const fileName = activeView.file.name;
    const filePath = activeView.file.path;
    return {
      vaultPath,
      folder,
      fileName,
      filePath
    };
  }
  runCpp(cppCode, out) {
    new import_obsidian2.Notice("Running...");
    const config = {
      stdio: {
        write: (s2) => out.write(s2)
      },
      unsigned_overflow: "warn",
      maxTimeout: this.settings.timeout
    };
    const exitCode = JSCPP.run(cppCode, 0, config);
    console.log("C++ exit code: " + exitCode);
    out.write("\nprogram stopped with exit code " + exitCode);
    new import_obsidian2.Notice(exitCode === 0 ? "Done" : "Error");
  }
  createRunButton() {
    console.log("Add run button");
    const button = document.createElement("button");
    button.classList.add(runButtonClass);
    button.setText(buttonText);
    return button;
  }
  getTempFile(ext) {
    return `${os.tmpdir()}/temp_${Date.now()}.${ext}`;
  }
  runCode(codeBlockContent, outputter, button, cmd, cmdArgs, ext) {
    new import_obsidian2.Notice("Running...");
    const tempFileName = this.getTempFile(ext);
    console.log(`${tempFileName}`);
    fs.promises.writeFile(tempFileName, codeBlockContent).then(() => {
      console.log(`Execute ${this.settings.nodePath} ${tempFileName}`);
      const args = cmdArgs ? cmdArgs.split(" ") : [];
      args.push(tempFileName);
      var opts = {};
      if (ext === "groovy") {
        opts = { shell: true };
      }
      const child = child_process.spawn(cmd, args, opts);
      this.handleChildOutput(child, outputter, button, tempFileName);
    }).catch((err) => {
      console.log("Error in 'Obsidian Execute Code' Plugin while executing: " + err);
    });
  }
  runPrologCode(prologCode, out) {
    new import_obsidian2.Notice("Running...");
    const session = prolog.create();
    session.consult(prologCode[0], {
      success: () => {
        session.query(prologCode[1], {
          success: (goal) => __async(this, null, function* () {
            console.log(goal);
            let answersLeft = true;
            let counter = 0;
            while (answersLeft && counter < this.settings.maxPrologAnswers) {
              yield session.answer({
                success: function(answer) {
                  new import_obsidian2.Notice("Done!");
                  console.log(session.format_answer(answer));
                  out.write(session.format_answer(answer) + "\n");
                },
                fail: function() {
                  answersLeft = false;
                },
                error: function(err) {
                  new import_obsidian2.Notice("Error!");
                  console.error(err);
                  answersLeft = false;
                },
                limit: function() {
                  answersLeft = false;
                }
              });
              counter++;
            }
          }),
          error: (err) => {
            new import_obsidian2.Notice("Error!");
            out.writeErr("Query failed.\n");
            out.writeErr(err.toString());
          }
        });
      },
      error: (err) => {
        out.writeErr("Adding facts failed.\n");
        out.writeErr(err.toString());
      }
    });
  }
  handleChildOutput(child, outputter, button, fileName) {
    outputter.clear();
    child.stdout.on("data", (data) => {
      outputter.write(data.toString());
    });
    child.stderr.on("data", (data) => {
      outputter.writeErr(data.toString());
    });
    child.on("close", (code) => {
      button.className = runButtonClass;
      new import_obsidian2.Notice(code === 0 ? "Done!" : "Error!");
      fs.promises.rm(fileName).catch((err) => {
        console.log("Error in 'Obsidian Execute Code' Plugin while removing file: " + err);
      });
    });
  }
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
